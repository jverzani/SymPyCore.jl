<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · SymPyCore</title><meta name="title" content="Introduction · SymPyCore"/><meta property="og:title" content="Introduction · SymPyCore"/><meta property="twitter:title" content="Introduction · SymPyCore"/><meta name="description" content="Documentation for SymPyCore."/><meta property="og:description" content="Documentation for SymPyCore."/><meta property="twitter:description" content="Documentation for SymPyCore."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymPyCore</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#The-package"><span>The package</span></a></li><li><a class="tocitem" href="#Symbols"><span>Symbols</span></a></li><li><a class="tocitem" href="#Substitution"><span>Substitution</span></a></li><li><a class="tocitem" href="#Conversion-from-symbolic-to-numeric"><span>Conversion from symbolic to numeric</span></a></li><li><a class="tocitem" href="#Algebraic-expressions"><span>Algebraic expressions</span></a></li><li><a class="tocitem" href="#Polynomials"><span>Polynomials</span></a></li><li><a class="tocitem" href="#Solving-equations"><span>Solving equations</span></a></li><li><a class="tocitem" href="#Matrices"><span>Matrices</span></a></li></ul></li><li><span class="tocitem">SymPy Tutorial</span><ul><li><a class="tocitem" href="../Tutorial/">Home</a></li><li><a class="tocitem" href="../Tutorial/preliminaries/">Preliminaries</a></li><li><a class="tocitem" href="../Tutorial/intro/">Introduction</a></li><li><a class="tocitem" href="../Tutorial/basic_operations/">Basic operations</a></li><li><a class="tocitem" href="../Tutorial/simplification/">Simplification</a></li><li><a class="tocitem" href="../Tutorial/calculus/">Calculus</a></li><li><a class="tocitem" href="../Tutorial/solvers/">Solvers</a></li><li><a class="tocitem" href="../Tutorial/matrices/">Matrices</a></li><li><a class="tocitem" href="../Tutorial/manipulation/">Manipulation</a></li><li><a class="tocitem" href="../Tutorial/gotchas/">Gotchas</a></li><li><a class="tocitem" href="../Tutorial/printing/">printing</a></li><li><a class="tocitem" href="../Tutorial/next/">Next</a></li></ul></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../reference/">Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl/blob/main/docs/src/introduction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-SymPyCore-introduction"><a class="docs-heading-anchor" href="#A-SymPyCore-introduction">A SymPyCore introduction</a><a id="A-SymPyCore-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#A-SymPyCore-introduction" title="Permalink"></a></h1><p>This document provides an introduction to using SymPy within <code>Julia</code> via <code>SymPyCore</code> It has examples from the <a href="https://docs.sympy.org/latest/tutorials/intro-tutorial/index.html">Introductory Tutorial</a> of SymPy that is translated into <code>Julia</code> commands in this documentation.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>In this document, we use <code>SymPy</code> to refer to either the <code>SymPy</code> or <code>SymPyPythonCall</code> packages that interface <code>Julia</code> with SymPy from <code>Python</code> using <code>SymPyCore</code>. The only difference being the glue package for interop between <code>Julia</code> and <code>Python</code>.</p><p><code>SymPy</code> provides a <code>Julia</code>n interface to SymPy, a <code>Python</code> library for symbolic math, as alternative to working with <code>Python</code> objects directly using one of the glue packages. See the <a href="./overview.html">overview</a> page for more details. Some brief implementation details are:</p><ul><li><p>Symbolic values in <code>Python</code> are wrapped in a subtype, typically <code>Sym{T}</code>, of <code>SymbolicObject{T}</code> or a container holding such values. The conversion from a Python object to a symbolic object in <code>Julia</code> is implemented in the <code>↑</code> method. Similarly, the  <code>↓</code> method takes a symbolic object and finds a Python counterpart for passing to underlying methods of SymPy.</p></li><li><p>For many generic methods in <code>Base</code>, <code>LinearAlgebra</code>, or <code>SpecialFunctions</code> – when there is a SymPy counterpart – a method is made which dispatches on its first argument being symbolic. The basic pattern is akin to <code>Base.sin(x::Sym) = sympy.sin(x)</code> where <code>sympy.sin(x)</code> is essentially <code>↑(_sympy_.sin(↓(x)))</code> – here <code>_sympy_</code> is the object holding the reference to the Python module, and <code>_sympy_.sin</code> the reference to its <code>sin</code> function. The <code>sympy</code> object handles the up and down conversions.</p></li><li><p>For many primary functions of SymPy, such as <code>simplify</code>, <code>factor</code>, <code>expand</code>, etc., new methods are made for use within <code>Julia</code>. Less foundational functions of SymPy, such as <code>trigsimp</code> or <code>expand_log</code> are referenced as <code>sympy.trigsimp</code> or <code>sympy.expand_log</code>. The <code>sympy</code> object is not a <code>Julia</code> module, but this use is reminiscent of qualifying a function from a module.</p></li><li><p>SymPy, being a Python library, has many methods for its objects. For example, a symbolic object, <code>obj</code> has a <code>diff</code> method accessed by <code>obj.diff(...)</code>. A object also has a <code>subs</code> method for substitution, accessed through <code>obj.subs(...)</code>. The same &quot;dot&quot; style is used for Python and <code>Julia</code>.</p></li><li><p>For commonly used object methods, a <code>Julia</code>n interface is defined. For <code>diff</code> a <code>diff(obj::Sym, ...)</code> method is defined. For <code>subs</code> a <code>subs(obj::Sym, ...)</code> interface is defined, and exported. As <code>subs</code> has paired-off values, specifying the substitution, the <code>Julia</code>n interface allows pairs notation (<code>a =&gt; b</code>) to be used.</p></li></ul><h2 id="The-package"><a class="docs-heading-anchor" href="#The-package">The package</a><a id="The-package-1"></a><a class="docs-heading-anchor-permalink" href="#The-package" title="Permalink"></a></h2><p>Either the <code>SymPy</code> or <code>SymPyPythonCall</code> packages needs to be loaded, e.g., <code>using SymPy</code>. The two can&#39;t be used in the same session.</p><p>When either is installed, the <code>SymPyCore</code> package is installed; the underlying glue package (either <code>PyCall</code> or <code>PythonCall</code>) should be installed; and that glue package should install the <code>sympy</code> library of <code>Python</code>.</p><h2 id="Symbols"><a class="docs-heading-anchor" href="#Symbols">Symbols</a><a id="Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols" title="Permalink"></a></h2><p>At the core of <code>SymPy</code> is the introduction of symbolic variables that differ quite a bit from <code>Julia</code>&#39;s variables. Symbolic variables do not immediately evaluate to a value, rather the &quot;symbolicness&quot; propagates when interacted with. To keep things manageable, SymPy does some simplifications along the way.</p><p>Symbolic expressions are primarily of the <code>Sym</code> type and can be constructed in the standard way:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = Sym(&quot;x&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">x</code></pre><p>This creates a symbolic object <code>x</code>, which can be manipulated through further function calls.</p><h3 id="The-@syms-macro"><a class="docs-heading-anchor" href="#The-@syms-macro">The <code>@syms</code> macro</a><a id="The-@syms-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@syms-macro" title="Permalink"></a></h3><p>There is the <code>@syms</code> macro that makes creating multiple variables a bit less typing, as it creates variables in the local scope – no assignment is necessary. Compare these similar ways to create symbolic variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms a b c</code><code class="nohighlight hljs ansi" style="display:block;">(a, b, c)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a,b,c = Sym(&quot;a&quot;), Sym(&quot;b&quot;), Sym(&quot;c&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(a, b, c)</code></pre><p>Here are two ways to make related variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms xs[1:5]</code><code class="nohighlight hljs ansi" style="display:block;">(SymPyCore.Sym{PythonCall.Core.Py}[xs₁, xs₂, xs₃, xs₄, xs₅],)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ys = [Sym(&quot;y$i&quot;) for i in 1:5]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 y₁
 y₂
 y₃
 y₄
 y₅</code></pre><p>The former much more succinct, but the latter pattern of use when the number of terms is a variable.</p><p>The <code>@syms</code> macro is recommended, and will be modeled in the following, as it makes the specification of assumptions, collections of indexed variables,  and symbolic functions more natural.</p><h3 id="Assumptions"><a class="docs-heading-anchor" href="#Assumptions">Assumptions</a><a id="Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Assumptions" title="Permalink"></a></h3><p>In <code>Python</code>&#39;s SymPy documentation the <code>symbols</code> constructor is suggested as idiomatic for producing symbolic objects. This function can similarly be used within <code>Julia</code>. With <code>symbols</code> (and with <code>@syms</code>) it is possible to pass assumptions onto the variables. A list of possible assumptions is <a href="http://docs.sympy.org/dev/modules/core.html#module-sympy.core.assumptions">here</a>. Some examples are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = symbols(&quot;u&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">u</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = symbols(&quot;x&quot;, real=true)</code><code class="nohighlight hljs ansi" style="display:block;">x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y1, y2 = symbols(&quot;y1, y2&quot;, positive=true)</code><code class="nohighlight hljs ansi" style="display:block;">(y1, y2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; alpha = symbols(&quot;alpha&quot;, integer=true, positive=true)</code><code class="nohighlight hljs ansi" style="display:block;">α</code></pre><p>As seen, the <code>symbols</code> function can be used to make one or more variables with zero, one or more assumptions.</p><p>We jump ahead for a second to illustrate, but here we see that <code>solve</code> will respect these assumptions, by failing to find solutions to these equations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(x^2 + 1)   # ±i are not real</code><code class="nohighlight hljs ansi" style="display:block;">Any[]</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(y1 + 1)    # -1 is not positive</code><code class="nohighlight hljs ansi" style="display:block;">Any[]</code></pre><hr/><p>The <code>@syms</code> macro allows annotations, akin to type annotations, to specify assumptions on new variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms u1::positive u2::positive</code><code class="nohighlight hljs ansi" style="display:block;">(u1, u2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(u1 + u2)  # empty, though solving u1 - u2 is not.</code><code class="nohighlight hljs ansi" style="display:block;">Any[]</code></pre><p>Additionally you can rename arguments using pair notation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms a1=&gt;&quot;α₁&quot; a2=&gt;&quot;α₂&quot;</code><code class="nohighlight hljs ansi" style="display:block;">(α₁, α₂)</code></pre><p>In this example, the Julia variables <code>a1</code> and <code>a2</code> are defined to store SymPy symbols with the &quot;pretty&quot; names <code>α₁</code> and <code>α₂</code> respectively.</p><p>As can be seen, there are several ways to create symbolic values, but the recommended way is to use <code>@syms</code>.</p><h3 id="Special-constants"><a class="docs-heading-anchor" href="#Special-constants">Special constants</a><a id="Special-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Special-constants" title="Permalink"></a></h3><p><code>Julia</code> has its math constants, like <code>pi</code> and <code>e</code>, <code>SymPy</code> as well. A few of these have <code>Julia</code> counterparts provided by <code>SymPyCore</code>. For example, these two constants are defined (where <code>oo</code> is for infinity):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; PI,  oo  # also Sym(pi) or Sym(Inf)</code><code class="nohighlight hljs ansi" style="display:block;">(pi, oo)</code></pre><p>Numeric values themselves can be symbolic. This example shows the difference. The first <code>asin</code> call dispatches to <code>Julia</code>&#39;s <code>asin</code> function, the second to <code>SymPy</code>&#39;s:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [asin(1), asin(Sym(1))]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 1.57079632679490
             pi/2</code></pre><h2 id="Substitution"><a class="docs-heading-anchor" href="#Substitution">Substitution</a><a id="Substitution-1"></a><a class="docs-heading-anchor-permalink" href="#Substitution" title="Permalink"></a></h2><p>SymPy provides a means to substitute values in for the symbolic expressions. The specification requires an expression, a variable in the expression to substitute in for, and a new value. For example, this is one way to make a polynomial in a new variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x y</code><code class="nohighlight hljs ansi" style="display:block;">(x, y)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex = x^2 + 2x + 1</code><code class="nohighlight hljs ansi" style="display:block;"> 2
x  + 2⋅x + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex.subs(x, y)</code><code class="nohighlight hljs ansi" style="display:block;"> 2
y  + 2⋅y + 1</code></pre><p>Substitution can also be numeric:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex.subs(x, 0)</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>The output has no free variables, but is still symbolic.</p><p>Expressions with more than one variable can have multiple substitutions, where each is expressed as a tuple:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x,y,z</code><code class="nohighlight hljs ansi" style="display:block;">(x, y, z)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex = x + y + z</code><code class="nohighlight hljs ansi" style="display:block;">x + y + z</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex.subs([(x,1), (y, pi)])</code><code class="nohighlight hljs ansi" style="display:block;">z + 1 + π</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The SymPy documentation for many functions can be read from the terminal using <code>Base.Docs.getdoc(ex)</code>, as in <code>Base.Docs.getdoc(sin(x))</code>.</p></div></div><p>The <code>SymPyCore</code> package also offers a more <code>Julia</code>n interface, through the method <code>subs</code>. This replaces the specification of pairs by a tuple with the <code>=&gt;</code> infix operator for <code>Pair</code> construction:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(ex, x=&gt;1, y=&gt;pi)</code><code class="nohighlight hljs ansi" style="display:block;">z + 1 + π</code></pre><p>For <code>subs</code>, the simple substitution <code>ex.object(x,a)</code> or <code>subs(ex, x=&gt;s)</code> is similar to simple function evaluation, so <code>Julia</code>&#39;s call notation for symbolic expressions is reserved for substitution, where to specify the pairing off of <code>x</code> and <code>a</code>, the <code>=&gt;</code>  pairs notation is used.</p><p>This calling style will be equivalent to the last:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(x=&gt;1, y=&gt;pi)</code><code class="nohighlight hljs ansi" style="display:block;">z + 1 + π</code></pre><p>A straight call is also possible, where the order of the variables is determined by <code>free_symbols</code>. This is useful for expressions of a single variable, but being more explicit through the use of paired values is recommended.</p><h2 id="Conversion-from-symbolic-to-numeric"><a class="docs-heading-anchor" href="#Conversion-from-symbolic-to-numeric">Conversion from symbolic to numeric</a><a id="Conversion-from-symbolic-to-numeric-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-from-symbolic-to-numeric" title="Permalink"></a></h2><p>SymPy provides two identical means to convert a symbolic math expression to a number. One is <code>evalf</code>, the other <code>N</code>. Within <code>Julia</code> we decouple this, using <code>N</code> to also convert to a <code>Julian</code> value and <code>evalf</code> to leave the conversion as a symbolic object.  The <code>N</code> function converts symbolic integers, rationals, irrationals, and complex values, while attempting to find an appropriate <code>Julia</code> type for the value.</p><p>To see the difference, we use both on <code>PI</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; N(PI)  # converts to underlying pi irrational</code><code class="nohighlight hljs ansi" style="display:block;">π = 3.1415926535897...</code></pre><p>Whereas, <code>evalf</code> will produce a symbolic numeric value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (PI).evalf()</code><code class="nohighlight hljs ansi" style="display:block;">3.14159265358979</code></pre><p>The <code>evalf</code> call allows for a precision argument to be passed through the second argument. This is how 30 digits of <span>$\pi$</span> can be extracted:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; PI.evalf(30)</code><code class="nohighlight hljs ansi" style="display:block;">3.14159265358979323846264338328</code></pre><p>This is a SymPy, symbolic number, not a <code>Julia</code> object. Composing with <code>N</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; N(PI.evalf(30))</code><code class="nohighlight hljs ansi" style="display:block;">3.141592653589793115997963468544185161590576171875</code></pre><p>will produce a <code>Julia</code> number,</p><p>Explicit conversion via <code>convert(T, ex)</code> can also be done in some cases, but may need to be combined with a call to <code>evalf</code> in some compound cases.</p><h2 id="Algebraic-expressions"><a class="docs-heading-anchor" href="#Algebraic-expressions">Algebraic expressions</a><a id="Algebraic-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-expressions" title="Permalink"></a></h2><p><code>SymPyCore</code> overloads many of <code>Julia</code>&#39;s functions to work with symbolic objects, such as seen above with <code>asin</code>. The usual mathematical operations such as <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code> etc. work through <code>Julia</code>&#39;s promotion mechanism, where numbers are promoted to symbolic objects, others dispatch internally to related SymPy functions.</p><p>In most all  cases, thinking about this distinction between numbers and symbolic numbers is unnecessary, as numeric values passed to <code>SymPyCore</code> functions are typically promoted to symbolic expressions. This conversion will take math constants to their corresponding <code>SymPyCore</code> counterpart, rational expressions to rational expressions, and floating point values to floating point values. However there are edge cases. An expression like <code>1//2 * pi * x</code> will differ from the seemingly identical  <code>1//2 * (pi * x)</code>. The former will produce a floating point value from <code>1//2 * pi</code> before being promoted to a symbolic instance. Using the symbolic value <code>PI</code> makes this expression work either way.</p><p>Most of <code>Julia</code>&#39;s <a href="http://julia.readthedocs.org/en/latest/manual/mathematical-operations/#elementary-functions">mathematical</a> functions are overloaded to work with symbolic expressions. <code>Julia</code>&#39;s generic definitions are used, as possible. This also introduces some edge cases. For example, <code>x^(-2)</code> will balk due to the negative, integer exponent, but either <code>x^(-2//1)</code> or <code>x^Sym(-2)</code> will work as expected, as the former call first dispatches to a generic definition, but the latter two expressions do not.</p><h3 id="The-expand,-factor,-collect,-and-simplify-functions"><a class="docs-heading-anchor" href="#The-expand,-factor,-collect,-and-simplify-functions">The expand, factor, collect, and simplify functions</a><a id="The-expand,-factor,-collect,-and-simplify-functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-expand,-factor,-collect,-and-simplify-functions" title="Permalink"></a></h3><p>`SymPyCore makes it very easy to work with polynomial and rational expressions.</p><p>First we create some variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x y z</code><code class="nohighlight hljs ansi" style="display:block;">(x, y, z)</code></pre><p>A typical polynomial expression in a single variable can be written in two common ways, expanded or factored form. Using <code>factor</code> and <code>expand</code> can move between the two.</p><p>For example,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = x^2 + 3x + 2</code><code class="nohighlight hljs ansi" style="display:block;"> 2
x  + 3⋅x + 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; factor(p)</code><code class="nohighlight hljs ansi" style="display:block;">(x + 1)⋅(x + 2)</code></pre><p>Or</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expand(prod((x-i) for i in 1:5))</code><code class="nohighlight hljs ansi" style="display:block;"> 5       4       3        2
x  - 15⋅x  + 85⋅x  - 225⋅x  + 274⋅x - 120</code></pre><p>The <code>factor</code> function factors over the rational numbers, so something like this with obvious factors is not finished:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; factor(x^2 - 2)</code><code class="nohighlight hljs ansi" style="display:block;"> 2
x  - 2</code></pre><p>When expressions involve one or more variables, it can be convenient to be able to manipulate them. For example, if we define <code>q</code> by:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = x*y + x*y^2 + x^2*y + x</code><code class="nohighlight hljs ansi" style="display:block;"> 2        2
x ⋅y + x⋅y  + x⋅y + x</code></pre><p>Then we can collect the terms by the variable <code>x</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.collect(q, x)</code><code class="nohighlight hljs ansi" style="display:block;"> 2       ⎛ 2        ⎞
x ⋅y + x⋅⎝y  + y + 1⎠</code></pre><p>or the variable <code>y</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.collect(q, y)</code><code class="nohighlight hljs ansi" style="display:block;">   2         ⎛ 2    ⎞
x⋅y  + x + y⋅⎝x  + x⎠</code></pre><p>These are identical expressions, though viewed differently.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>SymPy</code>&#39;s <code>collect</code> function has a different meaning than the <code>collect</code> generic, which turns an iterable into a vector or, more generally, an array. The expression above dispatches to <code>SymPy</code>&#39;s as <code>q</code> is symbolic.</p></div></div><p>A more broad-brush approach is to let <code>SymPyCore</code> simplify the values. In this case, the common value of <code>x</code> is factored out:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(q)</code><code class="nohighlight hljs ansi" style="display:block;">  ⎛       2        ⎞
x⋅⎝x⋅y + y  + y + 1⎠</code></pre><p>The <code>simplify</code> function attempts to apply the dozens of functions related to simplification that are part of SymPy. It is also possible to apply these functions one at a time, for example <code>sympy.trigsimp</code> does trigonometric simplifications.</p><p>The SymPy tutorial illustrates that <code>expand</code> can also result in simplifications through this example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expand((x + 1)*(x - 2) - (x - 1)*x)</code><code class="nohighlight hljs ansi" style="display:block;">-2</code></pre><p>These methods are not restricted to polynomial expressions and will work with other expressions. For example, <code>factor</code> identifies the following as a factorable object in terms of the variable <code>exp(x)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; factor(exp(2x) + 3exp(x) + 2)</code><code class="nohighlight hljs ansi" style="display:block;">⎛ x    ⎞ ⎛ x    ⎞
⎝ℯ  + 1⎠⋅⎝ℯ  + 2⎠</code></pre><h3 id="Rational-expressions:-apart,-together,-cancel"><a class="docs-heading-anchor" href="#Rational-expressions:-apart,-together,-cancel">Rational expressions: apart, together, cancel</a><a id="Rational-expressions:-apart,-together,-cancel-1"></a><a class="docs-heading-anchor-permalink" href="#Rational-expressions:-apart,-together,-cancel" title="Permalink"></a></h3><p>When working with rational expressions, SymPy does not do much simplification unless asked. For example this expression is not simplified:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; r = 1/x + 1/x^2</code><code class="nohighlight hljs ansi" style="display:block;">1   1
─ + ──
x    2
    x</code></pre><p>To put the terms of <code>r</code> over a common denominator, the <code>together</code> function is available:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; together(r)</code><code class="nohighlight hljs ansi" style="display:block;">x + 1
─────
  2
 x</code></pre><p>The <code>apart</code> function does the reverse, creating a partial fraction decomposition from a ratio of polynomials:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; apart( (4x^3 + 21x^2 + 10x + 12) /  (x^4 + 5x^3 + 5x^2 + 4x))</code><code class="nohighlight hljs ansi" style="display:block;"> 2⋅x - 1       1     3
────────── - ───── + ─
 2           x + 4   x
x  + x + 1</code></pre><p>Some times SymPy will cancel factors, as here:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; top = (x-1)*(x-2)*(x-3)</code><code class="nohighlight hljs ansi" style="display:block;">(x - 3)⋅(x - 2)⋅(x - 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bottom = (x-1)*(x-4)</code><code class="nohighlight hljs ansi" style="display:block;">(x - 4)⋅(x - 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; top/bottom</code><code class="nohighlight hljs ansi" style="display:block;">(x - 3)⋅(x - 2)
───────────────
     x - 4</code></pre><p>(This might make math faculty a bit upset, but it is in line with student thinking.)</p><p>However, with expanded terms, the common factor of <code>(x-1)</code> is not cancelled:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; r = expand(top) / expand(bottom)</code><code class="nohighlight hljs ansi" style="display:block;"> 3      2
x  - 6⋅x  + 11⋅x - 6
────────────────────
     2
    x  - 5⋅x + 4</code></pre><p>The <code>cancel</code> function instructs SymPy to perform cancellations. It takes rational functions and puts them in a canonical <span>$p/q$</span> form with no common (rational) factors and leading terms which are integers:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; cancel(r)</code><code class="nohighlight hljs ansi" style="display:block;"> 2
x  - 5⋅x + 6
────────────
   x - 4</code></pre><h3 id="Powers"><a class="docs-heading-anchor" href="#Powers">Powers</a><a id="Powers-1"></a><a class="docs-heading-anchor-permalink" href="#Powers" title="Permalink"></a></h3><p>The SymPy <a href="http://docs.sympy.org/dev/tutorial/simplification.html#powers">tutorial</a> offers a thorough explanation on powers and which get simplified and under what conditions. Basically</p><ul><li><p>The simplicfication <span>$x^a x^b = x^{a+b}$</span> is always true. However</p></li><li><p>The simplification <span>$x^a y^a=(xy)^a$</span> is only true with assumptions, such as <span>$x,y \geq 0$</span> and <span>$a$</span> is real, but not in general. For example, <span>$x=y=-1$</span> and <span>$a=1/2$</span> has <span>$x^a \cdot y^a = i \cdot i =  -1$</span>, where as <span>$(xy)^a = 1$</span>.</p></li><li><p>As well, the simplification <span>$(x^a)^b = x^{ab}$</span> is only true with assumptions. For example <span>$x=-1, a=2$</span>, and <span>$b=1/2$</span> gives <span>$(x^a)^b = 1^{1/2} = 1$</span>, whereas <span>$x^{ab} = -1^1 = -1$</span>.</p></li></ul><p>We see that with assumptions, the following expression does simplify to <span>$0$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x::nonnegatve y::nonnegative  a::real</code><code class="nohighlight hljs ansi" style="display:block;">(x, y, a)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(x^a * y^a - (x*y)^a)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>However, without assumptions this is not the case</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x,y,a</code><code class="nohighlight hljs ansi" style="display:block;">(x, y, a)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(x^a * y^a - (x*y)^a)</code><code class="nohighlight hljs ansi" style="display:block;"> a  a        a
x ⋅y  - (x⋅y)</code></pre><p>The <code>simplify</code> function calls <code>powsimp</code> to simplify powers, as above. The <code>powsimp</code> function has the keyword argument <code>force=true</code> to force simplification even if assumptions are not specified:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.powsimp(x^a * y^a - (x*y)^a, force=true)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><h3 id="Trigonometric-simplification"><a class="docs-heading-anchor" href="#Trigonometric-simplification">Trigonometric simplification</a><a id="Trigonometric-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Trigonometric-simplification" title="Permalink"></a></h3><p>For trigonometric expressions, <code>simplify</code> will use <code>trigsimp</code> to simplify:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms theta::real</code><code class="nohighlight hljs ansi" style="display:block;">(theta,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = cos(theta)^2 + sin(theta)^2</code><code class="nohighlight hljs ansi" style="display:block;">   2         2
sin (θ) + cos (θ)</code></pre><p>Calling either <code>simplify</code> or <code>trigsimp</code> will apply the Pythagorean identity:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(p)</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>The <code>trigsimp</code> function is, of course,  aware of the double angle formulas:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(sin(2theta) - 2sin(theta)*cos(theta))</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>The <code>expand_trig</code> function will expand such expressions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.expand_trig(sin(2theta))</code><code class="nohighlight hljs ansi" style="display:block;">2⋅sin(θ)⋅cos(θ)</code></pre><h2 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h2><h3 id="Coefficients-of-a-polynomial"><a class="docs-heading-anchor" href="#Coefficients-of-a-polynomial">Coefficients of a polynomial</a><a id="Coefficients-of-a-polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficients-of-a-polynomial" title="Permalink"></a></h3><p>Returning to polynomials, there are a few functions to find various pieces of the polynomials. First we make a general quadratic polynomial:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms a,b,c,x</code><code class="nohighlight hljs ansi" style="display:block;">(a, b, c, x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = a*x^2 + b*x + c</code><code class="nohighlight hljs ansi" style="display:block;">   2
a⋅x  + b⋅x + c</code></pre><p>If given a polynomial, like <code>p</code>, there are different means to extract the coefficients:</p><ul><li><p>SymPy provides a <code>coeffs</code> method for <code>Poly</code> objects, but <code>p</code> must first be converted to one.</p></li><li><p>SymPy provides the <code>coeff</code> method for expressions, which allows extraction of a coefficient for a given monomial</p></li></ul><p>The <code>ex.coeff(monom)</code> call will return the corresponding coefficient of the monomial:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p.coeff(x^2) # a</code><code class="nohighlight hljs ansi" style="display:block;">a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p.coeff(x)   # b</code><code class="nohighlight hljs ansi" style="display:block;">b</code></pre><p>The constant can be found through substitution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p(x=&gt;0)</code><code class="nohighlight hljs ansi" style="display:block;">c</code></pre><p>Though one could use some trick like this to find all the coefficients, that is cumbersome, at best.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; vcat([p.coeff(x^i) for i in N(degree(p,gen=x)):-1:1], [p(x=&gt;0)])</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 a
 b
 c</code></pre><p>Polynomials are a special class in SymPy and must be constructed. The <code>poly</code> constructor can be used. As there is more than one free variable in <code>p</code>, we specify the variable <code>x</code> below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = sympy.poly(p, x)</code><code class="nohighlight hljs ansi" style="display:block;">Poly(a*x^2 + b*x + c, x, domain=&#39;ZZ[a,b,c]&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q.coeffs()</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 a
 b
 c</code></pre><h3 id="Polynomial-roots:-solve,-real_roots,-polyroots,-nroots"><a class="docs-heading-anchor" href="#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots">Polynomial roots: solve, real_roots, polyroots, nroots</a><a id="Polynomial-roots:-solve,-real_roots,-polyroots,-nroots-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots" title="Permalink"></a></h3><p>SymPy provides functions to find the roots of a polynomial. In general, a polynomial with real coefficients of degree <span>$n$</span> will have <span>$n$</span> roots when multiplicities and complex roots are accounted for. The number of real roots is consequently between <span>$0$</span> and <span>$n$</span>.</p><p>For a <em>univariate</em> polynomial expression (a single variable), the real roots, when available, are returned by <code>real_roots</code>. For example,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_roots(x^2 - 2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 -√2
  √2</code></pre><p>Unlike <code>factor</code> – which only factors over rational factors – <code>real_roots</code> finds the two irrational roots here. It is well known (the <a href="http://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem">Abel-Ruffini theorem</a>) that for degree 5 polynomials, or higher, it is not always possible to express the roots in terms of radicals. However, when the roots are rational SymPy can have success:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = (x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1)</code><code class="nohighlight hljs ansi" style="display:block;">         2                         ⎛ 2        ⎞
x⋅(x - 3) ⋅(x - 2)⋅(x - 1)⋅(x + 1)⋅⎝x  + x + 1⎠</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_roots(p)</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 -1
  0
  1
  2
  3
  3</code></pre><p>In this example, the degree of <code>p</code> is 8, but only the 6 real roots returned, the double root of <span>$3$</span> is accounted for. The two complex roots of <code>x^2 + x+ 1</code> are not considered by this function. The complete set of distinct roots can be found with <code>solve</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(p)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
                 -1
                  0
                  1
                  2
                  3
 -1/2 - sqrt(3)*I/2
 -1/2 + sqrt(3)*I/2</code></pre><p>This finds the complex roots, but does not account for the double root. The <code>roots</code> function of SymPy does.</p><p>The output of calling <code>roots</code> will be a dictionary whose keys are the roots and values the multiplicity.</p><pre><code class="language-julia hljs">roots(p)</code></pre><p>When exact answers are not provided, the <code>roots</code> call is contentless:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = x^5 - x + 1</code><code class="nohighlight hljs ansi" style="display:block;"> 5
x  - x + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.roots(p)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Any, Any}()</code></pre><p>Calling <code>solve</code> seems to produce very little as well:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rts = solve(p)</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 CRootOf(x^5 - x + 1, 0)
 CRootOf(x^5 - x + 1, 1)
 CRootOf(x^5 - x + 1, 2)
 CRootOf(x^5 - x + 1, 3)
 CRootOf(x^5 - x + 1, 4)</code></pre><p>But in fact, <code>rts</code> contains lots of information. We can extract numeric values quite easily with <code>N</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; N.(rts)</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Number}:
                     -1.1673039782614187
 -0.18123244446987538 - 1.0839541013177107im
 -0.18123244446987538 + 1.0839541013177107im
   0.7648844336005847 - 0.35247154603172626im
   0.7648844336005847 + 0.35247154603172626im</code></pre><p>These are numeric approximations to irrational values. For numeric approximations to polynomial roots, the <code>nroots</code> function is also provided. The answers are still symbolic:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nroots(p)</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
                       -1.16730397826142
 -0.181232444469875 - 1.08395410131771⋅ⅈ
 -0.181232444469875 + 1.08395410131771⋅ⅈ
 0.764884433600585 - 0.352471546031726⋅ⅈ
 0.764884433600585 + 0.352471546031726⋅ⅈ</code></pre><h2 id="Solving-equations"><a class="docs-heading-anchor" href="#Solving-equations">Solving equations</a><a id="Solving-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-equations" title="Permalink"></a></h2><h3 id="The-solve-function"><a class="docs-heading-anchor" href="#The-solve-function">The solve function</a><a id="The-solve-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-solve-function" title="Permalink"></a></h3><p>The <code>solve</code> function is more general purpose than just finding roots of univariate polynomials. The function tries to solve for when an expression is <span>$0$</span>, or a set of expressions are all <span>$0$</span>.</p><p>For example, it can be used to solve when <span>$\cos(x) = \sin(x)$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(cos(x) - sin(x))</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 pi/4</code></pre><p>Though there are infinitely many correct solutions, these are within a certain range.</p><p>The <a href="http://docs.sympy.org/latest/modules/solvers/solveset.html">solveset</a> function appears in version 1.0 of SymPy and is an intended replacement for <code>solve</code>. Here we see it describes all solutions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = solveset(cos(x) - sin(x))</code><code class="nohighlight hljs ansi" style="display:block;">⎧        5⋅π │      ⎫   ⎧        π │      ⎫
⎨2⋅n⋅π + ─── │ n ∊ ℤ⎬ ∪ ⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬
⎩         4  │      ⎭   ⎩        4 │      ⎭</code></pre><p>The output of <code>solveset</code> is a set, rather than a vector or dictionary.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = solveset(x^2 - 4)</code><code class="nohighlight hljs ansi" style="display:block;">Set{SymPyCore.Sym{PythonCall.Core.Py}} with 2 elements:
  2
  -2</code></pre><p>Solving within Sympy has limits. For example, there is no symbolic solution here:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; try  solve(cos(x) - x)  catch err &quot;error&quot; end # wrap command for doctest of error</code><code class="nohighlight hljs ansi" style="display:block;">&quot;error&quot;</code></pre><p>(And hence the error message generated.)</p><p>For such an equation, a numeric method would be needed, similar to the <code>Roots</code> package. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nsolve(cos(x) - x, 1)</code><code class="nohighlight hljs ansi" style="display:block;">0.739085133215161</code></pre><p>Though it can&#39;t solve everything, the <code>solve</code> function can also solve equations of a more general type. For example, here it is used to derive the quadratic equation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms a::real, b::real, c::real</code><code class="nohighlight hljs ansi" style="display:block;">(a, b, c)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = a*x^2 + b*x + c</code><code class="nohighlight hljs ansi" style="display:block;">   2
a⋅x  + b⋅x + c</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs = solve(p, x);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>The extra argument <code>x</code> is passed to <code>solve</code> so that <code>solve</code> knows which variable to solve for.</p><h3 id="The-solveset-function"><a class="docs-heading-anchor" href="#The-solveset-function">The <code>solveset</code> function</a><a id="The-solveset-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-solveset-function" title="Permalink"></a></h3><p>The <code>solveset</code> function is similar:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solveset(p, x); # Set with two elements</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>If the <code>x</code> value is not given, <code>solveset</code> will error and  <code>solve</code> will try to find a solution over all the free variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(p)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Dict{SymPyCore.Sym{PythonCall.Core.Py}, SymPyCore.Sym{PythonCall.Core.Py}}}:
 Dict(a =&gt; (-b*x - c)/x^2)</code></pre><p>The output of <code>solveset</code> in Python is always a set, which may be finite or not. Finite sets are converted to <code>Set</code>s in <code>Julia</code>. Infinite sets have no natural counterpart and are not realized. Rather, they can be queried, as with &quot;needle <code>in</code> haystack&quot;. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = solveset(sin(x) ≧ 0)  # [\geqq] or with u  = solveset(Ge(sin(x), 0))</code><code class="nohighlight hljs ansi" style="display:block;">{x │ x ∊ ℂ ∧ (sin(x) ≥ 0)}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; PI/2 in u</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 3PI/2 in u</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>Infinite sets can have unions and intersections taken:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = solveset(cos(x) ≧ 0)</code><code class="nohighlight hljs ansi" style="display:block;">{x │ x ∊ ℂ ∧ (cos(x) ≥ 0)}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [3PI/4 in A for A ∈ (u, v, intersect(u, v), union(u, v))]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Bool}:
 1
 0
 0
 1</code></pre><p>Infinite sets can be filtered by intersecting them with an interval. For example,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = solveset(sin(x) ~ 1//2, x)</code><code class="nohighlight hljs ansi" style="display:block;">⎧        π │      ⎫   ⎧        5⋅π │      ⎫
⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬ ∪ ⎨2⋅n⋅π + ─── │ n ∊ ℤ⎬
⎩        6 │      ⎭   ⎩         6  │      ⎭</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; intersect(u, sympy.Interval(0, 2PI))  # a finite set after intersection</code><code class="nohighlight hljs ansi" style="display:block;">Set{SymPyCore.Sym{PythonCall.Core.Py}} with 2 elements:
  pi/6
  5*pi/6</code></pre><p>There are more sympy methods for working with sets, beyond those mirroring <code>Julia</code> generics.</p><hr/><p>Systems of equations can be solved as well. We specify them within a tuple of expressions, <code>(ex1, ex2, ..., exn)</code> where a found solution is one where all the expressions are 0. For example, to solve this linear system: <span>$2x + 3y = 6, 3x - 4y=12$</span>, we have:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x::real, y::real</code><code class="nohighlight hljs ansi" style="display:block;">(x, y)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; exs = (2x+3y-6, 3x-4y-12)</code><code class="nohighlight hljs ansi" style="display:block;">(2*x + 3*y - 6, 3*x - 4*y - 12)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = solve(exs); # Dict(x=&gt;60/17, y=&gt;-6/17)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>We can &quot;check our work&quot; by plugging into each equation. We take advantage of how the <code>subs</code> function allows us to pass in a dictionary:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(ex -&gt; ex.subs(d), exs)</code><code class="nohighlight hljs ansi" style="display:block;">(0, 0)</code></pre><p>The more <code>Julia</code>n way to solve a linear  equation, like this   would be as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = Sym[2 3; 3  -4]; b = Sym[6, 12]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SymPyCore.Sym}:
  6
 12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A \ b</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SymPyCore.Sym}:
 60/17
 -6/17</code></pre><p>(Rather than use a generic  <code>lu</code> solver through <code>Julia</code> (which  proved slow for larger  systems),  the <code>\</code> operator utilizes  <code>solve</code> to perform this  computation.)</p><p>In the previous example, the system had two equations and two unknowns. When that is not the case, one can specify the variables to solve for as a vector. In this example, we find a quadratic polynomial that approximates <span>$\cos(x)$</span> near <span>$0$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a,b,c,h = symbols(&quot;a,b,c,h&quot;, real=true)</code><code class="nohighlight hljs ansi" style="display:block;">(a, b, c, h)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = a*x^2 + b*x + c</code><code class="nohighlight hljs ansi" style="display:block;">   2
a⋅x  + b⋅x + c</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fn = cos;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; exs = [fn(0*h)-p(x=&gt;0), fn(h)-p(x =&gt; h), fn(2h)-p(x =&gt; 2h)]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
                           1 - c
       -a*h^2 - b*h - c + cos(h)
 -4*a*h^2 - 2*b*h - c + cos(2*h)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = solve(exs, (a,b,c));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d[a], d[b], d[c]</code><code class="nohighlight hljs ansi" style="display:block;">(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2), 2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h), 1)</code></pre><p>Again, a dictionary is returned, though we display its named elements individually. The polynomial itself can be found by substituting back in for <code>a</code>, <code>b</code>, and <code>c</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; quad_approx = p.subs(d)</code><code class="nohighlight hljs ansi" style="display:block;"> 2 ⎛  cos(h)   cos(2⋅h)    1  ⎞     ⎛2⋅cos(h)   cos(2⋅h)    3 ⎞
x ⋅⎜- ────── + ──────── + ────⎟ + x⋅⎜──────── - ──────── - ───⎟ + 1
   ⎜     2          2        2⎟     ⎝   h         2⋅h      2⋅h⎠
   ⎝    h        2⋅h      2⋅h ⎠</code></pre><p>Taking the &quot;limit&quot; as <span>$h$</span> goes to 0 produces the answer <span>$1 - x^2/2$</span>, as  will be shown.</p><p>Finally for <code>solve</code>, we show one way to re-express the polynomial <span>$a_2x^2 + a_1x + a_0$</span> as <span>$b_2(x-c)^2 + b_1(x-c) + b_0$</span> using <code>solve</code> (and not, say, an expansion theorem.)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 3</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x, c</code><code class="nohighlight hljs ansi" style="display:block;">(x, c)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms as[1:3]</code><code class="nohighlight hljs ansi" style="display:block;">(SymPyCore.Sym{PythonCall.Core.Py}[as₁, as₂, as₃],)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms bs[1:3]</code><code class="nohighlight hljs ansi" style="display:block;">(SymPyCore.Sym{PythonCall.Core.Py}[bs₁, bs₂, bs₃],)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = sum(as[i]*x^(i-1) for i ∈ 1:n)</code><code class="nohighlight hljs ansi" style="display:block;">                   2
as₁ + as₂⋅x + as₃⋅x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = sum(bs[i]*(x-c)^(i-1) for i ∈ 1:n)</code><code class="nohighlight hljs ansi" style="display:block;">                                 2
bs₁ + bs₂⋅(-c + x) + bs₃⋅(-c + x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = solve(p-q, bs)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{SymPyCore.Sym{PythonCall.Core.Py}, SymPyCore.Sym{PythonCall.Core.Py}} with 3 entries:
  bs₃ =&gt; as₃
  bs₂ =&gt; as₂ + 2*as₃*c
  bs₁ =&gt; as₁ + as₂*c + as₃*c^2</code></pre><h3 id="Solving-using-logical-operators"><a class="docs-heading-anchor" href="#Solving-using-logical-operators">Solving using logical operators</a><a id="Solving-using-logical-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-using-logical-operators" title="Permalink"></a></h3><p>The <code>solve</code> function does not need to just solve <code>ex = 0</code>. There are other means to specify an equation. Ideally, it would be nice to say <code>ex1 == ex2</code>, but the interpretation of <code>==</code> is not for this. Rather, <code>SymPyCore</code> introduces <code>Eq</code> for equality. So this expression</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(Eq(x, 1))</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 1</code></pre><p>gives <span>$1$</span>, as expected from solving <code>x == 1</code>.</p><div class="admonition is-info"><header class="admonition-header">Equals</header><div class="admonition-body"><p>Mathematics uses <code>=</code> for equations. <code>Julia</code> uses <code>=</code> for assignment and <code>==</code> for generic equality, and <code>===</code> to test for identical values. There is no general infix equation operation in <code>Julia</code>, though <code>~</code> is used by the <code>Symbolics</code> package its ecosystem. SymPy uses <code>Eq</code> for expressing an equation. For <code>SymPyCore</code>, both <code>Eq</code> and <code>~</code> may be used to indicate an equation between unknowns.</p></div></div><p>In addition to <code>Eq</code>, there are <code>Lt</code>, <code>Le</code>, <code>Ge</code>, <code>Gt</code>. The Unicode operators (e.g., <code>\leq</code>  and not  <code>\leq</code>)  are not aliased to these, but there are alternatives <code>\ll[tab]</code>, <code>\leqq[tab]</code>, <code>\Equal[tab]</code>, <code>\geqq[tab]</code>, <code>\gg[tab]</code> and <code>\neg[tab]</code> to negate.</p><p>So, the above could have been written with the following nearly identical expression, though it is entered with <code>\Equal[tab]</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(x ⩵ 1)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 1</code></pre><p>Or as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(x ~ 1)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymPyCore.Sym{PythonCall.Core.Py}}:
 1</code></pre><p>Here is an alternative way of asking a previous question on a pair of linear equations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x::real, y::real</code><code class="nohighlight hljs ansi" style="display:block;">(x, y)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; exs = (2x+3y ~ 6, 3x-4y ~ 12)</code><code class="nohighlight hljs ansi" style="display:block;">(Eq(2*x + 3*y, 6), Eq(3*x - 4*y, 12))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = solve(exs);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Here  is  one other way  to  express  the same</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Eq.( (2x+3y,3x-4y), (6,12)) |&gt;  solve == d</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="Solving-a-linear-recurrence"><a class="docs-heading-anchor" href="#Solving-a-linear-recurrence">Solving a linear recurrence</a><a id="Solving-a-linear-recurrence-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-a-linear-recurrence" title="Permalink"></a></h3><p>The <code>rsolve</code> function solves univariate recurrence with rational coefficients. It&#39;s use is like <code>solve</code>, though we need to qualify it, as the function does not have a <code>Julia</code>n counterpart:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms y() n</code><code class="nohighlight hljs ansi" style="display:block;">(y, n)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eqn = y(n) ~ y(n-1) + y(n-2)</code><code class="nohighlight hljs ansi" style="display:block;">y(n) = y(n - 2) + y(n - 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.rsolve(eqn ,y(n))</code><code class="nohighlight hljs ansi" style="display:block;">           n              n
   ⎛1   √5⎞       ⎛1   √5⎞
C₀⋅⎜─ - ──⎟  + C₁⋅⎜─ + ──⎟
   ⎝2   2 ⎠       ⎝2   2 ⎠</code></pre><p>A possibly familiar solution to the Fibonacci pattern is produced.</p><h2 id="Matrices"><a class="docs-heading-anchor" href="#Matrices">Matrices</a><a id="Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Matrices" title="Permalink"></a></h2><p>A matrix of symbolic values could be represented in <code>Julia</code> as either a symbolic matrix or a matrix of symbolic elements. In <code>SymPy</code> the default is to use the latter:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x y</code><code class="nohighlight hljs ansi" style="display:block;">(x, y)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1 x; x^2 x^3]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{SymPyCore.Sym{PythonCall.Core.Py}}:
   1    x
 x^2  x^3</code></pre><p>The <code>getproperty</code> method for matrices with symbolic values is overridden to allow object methods to be called:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A.det()</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>In addition, many of the generic methods from the <code>LinearAlgebra</code> package will work, as shown here where the trace is taken:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tr(A)</code><code class="nohighlight hljs ansi" style="display:block;"> 3
x  + 1</code></pre><p>To create symbolic matrices, a bit of work is needed, as <code>↑</code> converts symbolic matrices to matrices of symbolic values. Here are few ways</p><p>Using an immutable matrix will work, but we specify the matrix through a tuple of row vectors, as the <code>ImmutableMatrix</code> type of SymPy is preserved by <code>↑</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = [1 2 3; 3 4 5]</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Int64}:
 1  2  3
 3  4  5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.ImmutableMatrix(tuple(eachrow(B)...))</code><code class="nohighlight hljs ansi" style="display:block;">⎡1  2  3⎤
⎢       ⎥
⎣3  4  5⎦</code></pre><p>A mutable <code>Matrix</code> can be created by inhibiting the call to <code>↑</code> and calling <code>Sym</code> directly. (This is not recommended, as matrices with symbolic values require an extra call with <code>↓</code>.)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt;  Sym(↓(sympy).Matrix(tuple(eachrow(B)...)))</code><code class="nohighlight hljs ansi" style="display:block;">⎡1  2  3⎤
⎢       ⎥
⎣3  4  5⎦</code></pre><p>The <code>MatrixSymbol</code> feature of <code>SymPy</code> allows for the definition of sized matrices where the element values are not of interest:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A, B = sympy.MatrixSymbol(&quot;A&quot;, 2, 3), sympy.MatrixSymbol(&quot;B&quot;, 3, 1)</code><code class="nohighlight hljs ansi" style="display:block;">(A, B)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A * B</code><code class="nohighlight hljs ansi" style="display:block;">A⋅B</code></pre><p>As seen, <code>A * B</code> is defined. The values can be seen through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.Matrix(A * B)</code><code class="nohighlight hljs ansi" style="display:block;">2×1 Matrix{SymPyCore.Sym{PythonCall.Core.Py}}:
 A₀₀⋅B₀₀ + A₀₁⋅B₁₀ + A₀₂⋅B₂₀
 A₁₀⋅B₀₀ + A₁₁⋅B₁₀ + A₁₂⋅B₂₀</code></pre><p>However, <code>B * A</code> will error:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; try  B * A catch err &quot;Error&quot; end</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Error&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Tutorial/">Home »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 28 January 2025 22:42">Tuesday 28 January 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
