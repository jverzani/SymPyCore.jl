<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference/API · SymPyCore</title><meta name="title" content="Reference/API · SymPyCore"/><meta property="og:title" content="Reference/API · SymPyCore"/><meta property="twitter:title" content="Reference/API · SymPyCore"/><meta name="description" content="Documentation for SymPyCore."/><meta property="og:description" content="Documentation for SymPyCore."/><meta property="twitter:description" content="Documentation for SymPyCore."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymPyCore</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">SymPy Tutorial</span><ul><li><a class="tocitem" href="../Tutorial/">Home</a></li><li><a class="tocitem" href="../Tutorial/preliminaries/">Preliminaries</a></li><li><a class="tocitem" href="../Tutorial/intro/">Introduction</a></li><li><a class="tocitem" href="../Tutorial/basic_operations/">Basic operations</a></li><li><a class="tocitem" href="../Tutorial/simplification/">Simplification</a></li><li><a class="tocitem" href="../Tutorial/calculus/">Calculus</a></li><li><a class="tocitem" href="../Tutorial/solvers/">Solvers</a></li><li><a class="tocitem" href="../Tutorial/matrices/">Matrices</a></li><li><a class="tocitem" href="../Tutorial/manipulation/">Manipulation</a></li><li><a class="tocitem" href="../Tutorial/gotchas/">Gotchas</a></li><li><a class="tocitem" href="../Tutorial/printing/">printing</a></li><li><a class="tocitem" href="../Tutorial/next/">Next</a></li></ul></li><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference/API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference/API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.sympy_plotting" href="#SymPyCore.sympy_plotting"><code>SymPyCore.sympy_plotting</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Plotting of symbolic objects.</p><p>The <code>Plots</code> package provide a uniform interface to many of <code>Julia</code>&#39;s plotting packages. <code>SymPy</code> plugs into <code>Plots</code>&#39; &quot;recipes.&quot;</p><p>The basic goal is that when <code>Plots</code> provides an interface for function objects, this package extends the interface to symbolic expressions.</p><p>In particular:</p><ul><li><code>plot(ex::Sym, a, b; kwargs...)</code> will plot a function evaluating <code>ex</code> over [a,b]</li></ul><p>Example. Here we use the default backend for <code>Plots</code> to make a plot:</p><pre><code class="language-julia hljs">using Plots
@syms x
plot(x^2 - 2x, 0, 4)</code></pre><ul><li><code>plot(ex1, ex2, a, b; kwargs...)</code> will plot the two expressions in a parametric plot over the interval <code>[a,b]</code>.</li></ul><p>Example:</p><pre><code class="language-julia hljs">@syms x
plot(sin(2x), cos(3x), 0, 4pi) ## also</code></pre><p>For a few backends (those that support <code>:path3d</code>) a third symbolic expression may be added to have a 3d parametric plot rendered:</p><pre><code class="language-julia hljs">plot(sin(x), cos(x), x, 0, 4pi) # helix in 3d</code></pre><ul><li><code>plot(xs, ys, expression)</code> will make a contour plot (for many backends).</li></ul><pre><code class="language-julia hljs">@syms x y
plot(range(0,stop=5, length=50), range(0,stop=5, length=50), x*y)</code></pre><ul><li>To plot the surface  <code>z=ex(x,y)</code> over a region we have <code>Plots.surface</code>. For example,</li></ul><pre><code class="language-julia hljs">@syms x y
surface(-5:5, -5:5, 25 - x^2 - y^2)</code></pre><ul><li>To plot two or more functions at once, the style <code>plot([ex1, ex2], a, b)</code> does not work. Rather, use   <code>plot(ex1, a, b); plot!(ex2)</code>, as in:</li></ul><pre><code class="language-julia hljs">@syms x
plot(sin(x), 0, 2pi)
plot!(cos(x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/plot_recipes.jl#L1-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Differential" href="#SymPyCore.Differential"><code>SymPyCore.Differential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Differential(x)</code></pre><p>Use to find (partial) derivatives.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@syms x y u()
Dx = Differential(x)
Dx(u(x,y))  # resolves to diff(u(x,y),x)
Dx(u)       # will evaluate diff(u(x), x)
(Dx^2)(u(x))  # two derivatives in x; not () to avoid 2u(x) eager evaluation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L104-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Doc" href="#SymPyCore.Doc"><code>SymPyCore.Doc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymPy.Doc(f::Symbol, [module=sympy])</code></pre><p>Return docstring of <code>f</code> found within the specified module.</p><p>Examples</p><pre><code class="nohighlight hljs">SymPy.Doc(:sin)
SymPy.Doc(:det, sympy.matrices)
## add module to query
SymPy.pyimport_conda(&quot;sympy.crypto.crypto&quot;, &quot;sympy&quot;)
SymPy.Doc(:padded_key, sympy.crypto)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/utils.jl#L173-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Introspection" href="#SymPyCore.Introspection"><code>SymPyCore.Introspection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> Introspection</code></pre><p>Struct holding functions used to inspect an object</p><ul><li><code>Introspection.func</code>: Return pointer to Python function.</li><li><code>Introspection.operation</code>: Return <code>Julia</code> generic function for given underlying function</li><li><code>Introspection.funcname</code>: Returns name of function</li><li><code>Introspection.args</code>: Returns arguments for expression or empty tuple</li><li><code>Introspection.arguments</code>: Return arguments</li><li><code>Introspection.istree</code>: Check if object is an expression (with operation and arguments) or not</li><li><code>Introspection.class</code>: Returns <code>__class__</code> value</li><li><code>Introspection.classname</code>: Returns <code>__class__</code> value as a string</li><li><code>Introspection.similarterm</code>: Create a similar term</li></ul><p><a href="http://docs.sympy.org/dev/tutorial/manipulation.html">Invariant:</a></p><p>As <code>args</code> returns symbolic objects, this becomes: every well-formed SymPy expression <code>ex</code> must either have <code>length(args(ex)) == 0</code> or <code>func(ex)(↓(args(ex))...) = ex</code>.</p><p>Using the methods designed for <code>SymbolicUtils</code> usage, this becomes every expression one of <code>!istree(ex)</code>  or <code>operation(ex)(args(ex)...) == ex</code> should hold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/lambdify.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Sym" href="#SymPyCore.Sym"><code>SymPyCore.Sym</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sym{T}</code></pre><p>Main wrapper for symbolic Python objects.</p><p>This is useful for dispatching methods for generic functions. <code>Sym</code> is also used to make symbolic values, in particular numeric values can be made into symbolic values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/types.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.SymFunction" href="#SymPyCore.SymFunction"><code>SymPyCore.SymFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymFunction</code></pre><p>A type and constructor to create symbolic functions. Such objects can be used for specifying differential equations. The macro <a href="@ref"><code>@syms</code></a> is also available for constructing <code>SymFunction</code>s (<code>@syms f()</code>)</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; @syms t, v(); # recommended way to create a symbolic function

julia&gt; u = SymFunction(&quot;u&quot;) # alternate
u

julia&gt; diff(v(t), t) |&gt; show
Derivative(v(t), t)</code></pre><p><strong>Extended help</strong></p><p>For symbolic functions <em>not</em> wrapped in the <code>SymFunction</code> type, the <code>sympy.Function</code> constructor can be used, as can the <a href="#SymPyCore.symbols-Tuple{}"><code>symbols</code></a> function to construct symbolic functions (<code>F=sympy.Function(&quot;F&quot;, real=true)</code>; <code>F = sympy.symbols(&quot;F&quot;, cls=sympy.Function, real=true)</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; @syms u(), v()::real, t
(u, v, t)

julia&gt; sqrt(u(t)^2), sqrt(v(t)^2) # real values have different simplification rules
(sqrt(u(t)^2), Abs(v(t)))
</code></pre><p>Such functions are undefined functions in SymPy, and can be used symbolically, such as with taking derivatives:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x y u()
(x, y, u)

julia&gt; diff(u(x), x) |&gt; show
Derivative(u(x), x)

julia&gt; diff(u(x, y), x) |&gt; show
Derivative(u(x, y), x)</code></pre><p>Here is one way to find the second derivative of an inverse function to <code>f</code>, utilizing the <code>SymFunction</code> class and the convenience <code>Differential</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms f() f⁻¹() x;

julia&gt; D = Differential(x) # ∂(f) is diff(f(x),x)
Differential(x)

julia&gt; D² = D∘D
Differential(x) ∘ Differential(x)

julia&gt; u1 = only(solve(D((f⁻¹∘f)(x))  ~ 1, D(f⁻¹)(f(x)))); show(u1)
1/Derivative(f(x), x)

julia&gt; u2 = only(solve(D²((f⁻¹∘f)(x)) ~ 0, D²(f⁻¹)(f(x)))); show(u2)
-Derivative(f(x), (x, 2))*Derivative(f⁻¹(f(x)), f(x))/Derivative(f(x), x)^2

julia&gt; u2(D(f⁻¹)(f(x)) =&gt; u1) |&gt; show # f&#39;&#39;/[f&#39;]^3
-Derivative(f(x), (x, 2))/Derivative(f(x), x)^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/types.jl#L47-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.SymbolicCallable" href="#SymPyCore.SymbolicCallable"><code>SymPyCore.SymbolicCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymbolicCallable</code></pre><p>Wrapper for python objects with a <code>__call__</code> method. This is used by <code>sympy.λ</code> to call the underlying <code>λ</code> function without the user needing to manually convert <code>Julia</code> objects into <code>Python</code> objects and back.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are <em>some</em> times where this doesn&#39;t work well, and using <code>sympy.o.λ</code> along with <code>↓</code> and <code>↑</code> will work.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L197-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:~-Tuple{Number, SymPyCore.SymbolicObject}" href="#Base.:~-Tuple{Number, SymPyCore.SymbolicObject}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhs ~ rhs</code></pre><p>Specify an equation.</p><p>Alternative syntax to <code>Eq(lhs, rhs)</code> or <code>lhs ⩵ rhs</code> (<code>\Equal[tab]</code>). Notation borrowed from <code>Symbolics.jl</code>.</p><p>See <a href="#SymPyCore.rhs"><code>rhs</code></a> or <code>lhs</code> to extract the two sides.</p><p>Inequalities may be defined using other functions imported from <code>CommonEq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L131-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.match-Tuple{SymPyCore.Sym, SymPyCore.Sym, Vararg{Any}}" href="#Base.match-Tuple{SymPyCore.Sym, SymPyCore.Sym, Vararg{Any}}"><code>Base.match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match(pattern, expression, ...)</code></pre><p>Match a pattern against an expression; returns a dictionary of matches.</p><p>If a match is unsuccessful, returns an <em>empty</em> dictionary. (SymPy returns &quot;nothing&quot;)</p><p>The order of the arguments follows <code>Julia</code>&#39;s <code>match</code> function, not <code>sympy.match</code>, which can be used directly, otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/patternmatch.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.replace-Tuple{SymPyCore.Sym, SymPyCore.Sym, Function}" href="#Base.replace-Tuple{SymPyCore.Sym, SymPyCore.Sym, Function}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace(expression, pattern, value, ...)
replace(expression, pattern =&gt; value; kwargs...)</code></pre><p>In the expression replace a matching pattern with the value. Returns the modified expression.</p><p><strong>Extended help</strong></p><p>From: <a href="http://docs.sympy.org/dev/modules/core.html">SymPy Docs</a></p><p>Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, <code>simultaneous</code> can be set to <code>false</code>. In addition, if an expression containing more than one <code>Wild</code> symbol is being used to match subexpressions and the <code>exact</code> flag is <code>true</code>, then the match will only succeed if non-zero values are received for each <code>Wild</code> that appears in the match pattern.</p><p>Differences from SymPy:</p><ul><li><p>&quot;types&quot; are specified via calling <code>func</code> on the head of an expression: <code>func(sin(x))</code> -&gt; <code>sin</code>, or directly through <code>sympy.sin</code></p></li><li><p>functions are only supported by calling into the glue package.</p></li></ul><p>Examples (from the SymPy docs)</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall


julia&gt; @syms x, y, z
(x, y, z)

julia&gt; f = log(sin(x)) + tan(sin(x^2)); show(f)
log(sin(x)) + tan(sin(x^2))
</code></pre><p><strong>&quot;type&quot; -&gt; &quot;type&quot;</strong></p><p>Types are specified through <code>func</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; func = Introspection.func
#399 (generic function with 1 method)

julia&gt; replace(f, func(sin(x)), func(cos(x))) |&gt; show # type -&gt; type
log(cos(x)) + tan(cos(x^2))
</code></pre><p>The value <code>sympy.sin</code> does not work, as it is wrapped. Using <code>↓(sympy).sin</code> will work:</p><pre><code class="nohighlight hljs">julia&gt; replace(f, ↓(sympy).sin, ↓(sympy).cos)
log(cos(x)) + tan(cos(x^2))</code></pre><p><strong>&quot;pattern&quot; -&gt; &quot;expression&quot;</strong></p><p>Using &quot;<code>Wild</code>&quot; variables allows a pattern to be replaced by an expression:</p><pre><code class="language-julia-repl hljs">julia&gt; a, b = Wild(&quot;a&quot;), Wild(&quot;b&quot;)
(a_, b_)

julia&gt; replace(f, sin(a), tan(2a)) |&gt; show
log(tan(2*x)) + tan(tan(2*x^2))

julia&gt; replace(f, sin(a), tan(a/2)) |&gt; show
log(tan(x/2)) + tan(tan(x^2/2))

julia&gt; f.replace(sin(a), a) |&gt; show
log(x) + tan(x^2)

julia&gt; (x*y).replace(a*x, a)
y
</code></pre><p>In the SymPy docs we have:</p><p>Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols.&quot;</p><pre><code class="language-julia-repl hljs">julia&gt; replace(2x + y, a*x+b, b-a)  # y - 2
y - 2

julia&gt; replace(2x + y, a*x+b, b-a, exact=false) |&gt; show
y + 2/x</code></pre><p><strong>&quot;type&quot; -&gt; &quot;function&quot;</strong></p><p>To replace with a more complicated function, requires some assistance from <code>Python</code>, as an anonymous function must be defined within Python, not <code>Julia</code>. This is how it might be done:</p><pre><code class="language-julia hljs">julia&gt; import PyCall

julia&gt; ## Anonymous function a -&gt; sin(2a)
       PyCall.py&quot;&quot;&quot;
       from sympy import sin, Mul
       def anonfn(*args):
           return sin(2*Mul(*args))
       &quot;&quot;&quot;)


julia&gt; replace(f, sympy.sin, PyCall.py&quot;anonfn&quot;)
                   ⎛   ⎛   2⎞⎞
log(sin(2⋅x)) + tan⎝sin⎝2⋅x ⎠⎠</code></pre><p><strong>&quot;pattern&quot; -&gt; &quot;func&quot;</strong></p><p>The function is redefined, as a fixed argument is passed:</p><pre><code class="language-julia hljs">julia&gt; PyCall.py&quot;&quot;&quot;
       from sympy import sin
       def anonfn(a):
           return sin(2*a)
       &quot;&quot;&quot;

julia&gt; replace(f, sin(a), PyCall.py&quot;anonfn&quot;)
                   ⎛   ⎛   2⎞⎞
log(sin(2⋅x)) + tan⎝sin⎝2⋅x ⎠⎠</code></pre><p><strong>&quot;func&quot; -&gt; &quot;func&quot;</strong></p><pre><code class="language-julia hljs">
julia&gt; PyCall.py&quot;&quot;&quot;
       def fn1(expr):
           return expr.is_Number

       def fn2(expr):
           return expr**2
       &quot;&quot;&quot;

julia&gt; replace(2*sin(x^3), PyCall.py&quot;fn1&quot;, PyCall.py&quot;fn2&quot;)
     ⎛ 9⎞
4⋅sin⎝x ⎠</code></pre><pre><code class="language-julia hljs">julia&gt; PyCall.py&quot;&quot;&quot;
       def fn1(x):
           return x.is_Mul

       def fn2(x):
           return 2*x
       &quot;&quot;&quot;

julia&gt; replace(x*(x*y + 1), PyCall.py&quot;fn1&quot;, PyCall.py&quot;fn2&quot;)
2⋅x⋅(2⋅x⋅y + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/patternmatch.jl#L26-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve-Tuple{}" href="#CommonSolve.solve-Tuple{}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve</code></pre><p>Use <code>solve</code> to solve algebraic equations.</p><p><strong>Extended help</strong></p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall


julia&gt; @syms x y a b c d
(x, y, a, b, c, d)

julia&gt; solve(x^2 + 2x + 1, x) # [-1]
1-element Vector{Sym{PythonCall.Py}}:
 -1

julia&gt; solve(x^2 + 2a*x + a^2, x) # [-a]
1-element Vector{Sym{PythonCall.Py}}:
 -a

julia&gt; u = solve([a*x + b*y-3, c*x + b*y - 1], [x,y]); show(u[x])
2/(a - c)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A very nice example using <code>solve</code> is a <a href="https://newptcai.github.io/euclidean-plane-geometry-with-julia.html">blog</a> entry on <a href="https://en.wikipedia.org/wiki/Napoleon%27s_theorem">Napoleon&#39;s theorem</a> by Xing Shi Cai.</p></div></div><div class="admonition is-info"><header class="admonition-header">Systems</header><div class="admonition-body"><p>Use a tuple, not a vector, of equations when there is more than one.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L147-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.:↑-Tuple{SymPyCore.Sym}" href="#SymPyCore.:↑-Tuple{SymPyCore.Sym}"><code>SymPyCore.:↑</code></a> — <span class="docstring-category">Method</span></header><section><div><p>↑(::SymbolicObject)</p><p>Method to lift a python object into a symbolic counterpart.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.:↓-Tuple{SymPyCore.SymbolicObject}" href="#SymPyCore.:↓-Tuple{SymPyCore.SymbolicObject}"><code>SymPyCore.:↓</code></a> — <span class="docstring-category">Method</span></header><section><div><p>↓(::SymbolicObject)    ↓ₖ([kwargs...])</p><p>The <code>\downarrrow[tab]</code> and <code>\downarrow[tab]\_k[tab]</code> operators push a symbolic object (or a container of symbolic objects) into a Python counterpart for passing to an underlying Python function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Heaviside-Tuple{}" href="#SymPyCore.Heaviside-Tuple{}"><code>SymPyCore.Heaviside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Heaviside</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=Heaviside&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L421-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Permutation" href="#SymPyCore.Permutation"><code>SymPyCore.Permutation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Permutation
PermutationGroup</code></pre><p>Give access to the <code>sympy.combinatorics.permutations</code> module</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; p = Permutation([1,2,3,0])
(0 1 2 3)

julia&gt; p^2
(0 2)(1 3)

julia&gt; p^2 * p^2
()</code></pre><p>Rubik&#39;s cube example from SymPy documentation</p><pre><code class="language-julia-repl hljs">julia&gt; F = Permutation([(2, 19, 21, 8),(3, 17, 20, 10),(4, 6, 7, 5)])
(2 19 21 8)(3 17 20 10)(4 6 7 5)

julia&gt; R = Permutation([(1, 5, 21, 14),(3, 7, 23, 12),(8, 10, 11, 9)])
(1 5 21 14)(3 7 23 12)(8 10 11 9)

julia&gt; D = Permutation([(6, 18, 14, 10),(7, 19, 15, 11),(20, 22, 23, 21)])
(6 18 14 10)(7 19 15 11)(20 22 23 21)

julia&gt; G = PermutationGroup(F,R,D);

julia&gt; G.order()
3674160</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L296-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.PermutationGroup" href="#SymPyCore.PermutationGroup"><code>SymPyCore.PermutationGroup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Permutation
PermutationGroup</code></pre><p>Give access to the <code>sympy.combinatorics.permutations</code> module</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; p = Permutation([1,2,3,0])
(0 1 2 3)

julia&gt; p^2
(0 2)(1 3)

julia&gt; p^2 * p^2
()</code></pre><p>Rubik&#39;s cube example from SymPy documentation</p><pre><code class="language-julia-repl hljs">julia&gt; F = Permutation([(2, 19, 21, 8),(3, 17, 20, 10),(4, 6, 7, 5)])
(2 19 21 8)(3 17 20 10)(4 6 7 5)

julia&gt; R = Permutation([(1, 5, 21, 14),(3, 7, 23, 12),(8, 10, 11, 9)])
(1 5 21 14)(3 7 23 12)(8 10 11 9)

julia&gt; D = Permutation([(6, 18, 14, 10),(7, 19, 15, 11),(20, 22, 23, 21)])
(6 18 14 10)(7 19 15 11)(20 22 23 21)

julia&gt; G = PermutationGroup(F,R,D);

julia&gt; G.order()
3674160</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L296-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.Wild-Tuple{Symbol}" href="#SymPyCore.Wild-Tuple{Symbol}"><code>SymPyCore.Wild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wild(x)</code></pre><p>Create a &quot;wild card&quot; for pattern matching</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/patternmatch.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.apart-Tuple{}" href="#SymPyCore.apart-Tuple{}"><code>SymPyCore.apart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apart</code></pre><p>Partial fraction decomposition. See <a href="#SymPyCore.together-Tuple{}"><code>together</code></a>. <a href="https://docs.sympy.org/latest/search.html?q=apart&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.ask-Tuple{}" href="#SymPyCore.ask-Tuple{}"><code>SymPyCore.ask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ask</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=ask&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L407-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.cancel-Tuple{}" href="#SymPyCore.cancel-Tuple{}"><code>SymPyCore.cancel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cancel</code></pre><p>Take any rational expression and put it into the standard canonical form, <span>$p/q$</span>. <a href="https://docs.sympy.org/latest/search.html?q=cancel&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L282-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.degree-Tuple{}" href="#SymPyCore.degree-Tuple{}"><code>SymPyCore.degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree</code></pre><p>Return degree of expression in a given variable. Not exported.</p><p><a href="https://docs.sympy.org/latest/search.html?q=degree&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.doit-Tuple{T} where T&lt;:SymPyCore.SymbolicObject" href="#SymPyCore.doit-Tuple{T} where T&lt;:SymPyCore.SymbolicObject"><code>SymPyCore.doit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">doit</code></pre><p>Evaluates objects that are not evaluated by default. Alias for object method.</p><p><strong>Extended help</strong></p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; @syms x f()
(x, f)

julia&gt; D = Differential(x)
Differential(x)

julia&gt; df = D(f(x)); show(df)
Derivative(f(x), x)

julia&gt; dfx = subs(df, (f(x), x^2));  show(dfx)
Derivative(x^2, x)

julia&gt; doit(dfx)
2⋅x</code></pre><p>Set <code>deep=true</code> to apply <code>doit</code> recursively to force evaluation of nested expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms g()
(g,)

julia&gt; dgfx = g(dfx);  show(dgfx)
g(Derivative(x^2, x))

julia&gt; doit(dgfx) |&gt; show
g(Derivative(x^2, x))

julia&gt; doit(dgfx, deep=true)
g(2⋅x)</code></pre><p>There is also a curried form of <code>doit</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; dfx |&gt; doit
2⋅x

julia&gt; dgfx |&gt; doit(deep=true)
g(2⋅x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/utils.jl#L104-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.dsolve-Tuple{}" href="#SymPyCore.dsolve-Tuple{}"><code>SymPyCore.dsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dsolve(eqn, var, args..,; ics=nothing, kwargs...)</code></pre><p>Calls <code>sympy.dsolve</code>.</p><p>ics: The initial conditions are specified with a dictionary or <code>nothing</code></p><p><strong>Extended help</strong></p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; @syms α, x, f(), g()
(α, x, f, g)

julia&gt; ∂ = Differential(x)
Differential(x)

julia&gt; eqn = ∂(f(x)) ~ α * x; show(eqn)
Eq(Derivative(f(x), x), x*α)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; dsolve(eqn) |&gt; show
Eq(f(x), C1 + x^2*α/2)</code></pre><pre><code class="language-julia hljs">julia&gt; dsolve(eqn(α=&gt;2); ics=Dict(f(0)=&gt;1))
        2
f(x) = x  + 1

julia&gt; eqn = ∂(∂(f(x))) ~ -f(x);

julia&gt; dsolve(eqn)
f(x) = C₁⋅sin(x) + C₂⋅cos(x)

julia&gt; dsolve(eqn; ics = Dict(f(0)=&gt;1, ∂(f)(0) =&gt; -1))
f(x) = -sin(x) + cos(x)

julia&gt; eqn = ∂(∂(f(x))) - f(x) - exp(x);

julia&gt; dsolve(eqn, ics=Dict(f(0) =&gt; 1, f(1) =&gt; Sym(1//2))) |&gt; show
Eq(f(x), (x/2 + (-exp(2) - 2 + E)/(-2 + 2*exp(2)))*exp(x) + (-E + 3*exp(2))*exp(-x)/(-2 + 2*exp(2)))</code></pre><div class="admonition is-info"><header class="admonition-header">Systems</header><div class="admonition-body"><p>Use a tuple, not a vector, of equations when there is more than one.</p></div></div><pre><code class="language-julia hljs">julia&gt; @syms x() y() t g
(x, y, t, g)

julia&gt; ∂ = Differential(t)
Differential(t)

julia&gt; eqns = (∂(x(t)) ~ y(t), ∂(y(t)) ~ x(t));

julia&gt; dsolve(eqns)
2-element Vector{Sym{PythonCall.Py}}:
 Eq(x(t), -C1*exp(-t) + C2*exp(t))
  Eq(y(t), C1*exp(-t) + C2*exp(t))

julia&gt; dsolve(eqns, ics = Dict(x(0) =&gt; 1, y(0) =&gt; 2))
2-element Vector{Sym{PythonCall.Py}}:
 Eq(x(t), 3*exp(t)/2 - exp(-t)/2)
 Eq(y(t), 3*exp(t)/2 + exp(-t)/2)

julia&gt; eqns = (∂(∂(x(t))) ~ 0, ∂(∂(y(t))) ~ -g)
(Eq(Derivative(x(t), (t, 2)), 0), Eq(Derivative(y(t), (t, 2)), -g))

julia&gt; dsolve(eqns)  # can&#39;t solve for initial conditions though! (NotAlgebraic)
2-element Vector{Sym{PythonCall.Py}}:
           x(t) = C₁ + C₂⋅t
 Eq(y(t), C3 + C4*t - g*t^2/2)

julia&gt; @syms t x() y()
(t, x, y)

julia&gt; eq = (∂(x)(t) ~ x(t)*y(t)*sin(t), ∂(y)(t) ~ y(t)^2 * sin(t));</code></pre><pre><code class="language-julia hljs">julia&gt; dsolve(eq)
Set{Sym{PythonCall.Py}} with 2 elements:
  Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t)))
  Eq(y(t), -1/(C1 - cos(t)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L186-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.expand-Tuple{}" href="#SymPyCore.expand-Tuple{}"><code>SymPyCore.expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand</code></pre><p>Expand a symbolic expression. See <a href="#SymPyCore.factor-Tuple{}"><code>factor</code></a>.</p><p><a href="https://docs.sympy.org/latest/search.html?q=expand&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L248-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.factor-Tuple{}" href="#SymPyCore.factor-Tuple{}"><code>SymPyCore.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factor</code></pre><p>Factor an expression. See <a href="#SymPyCore.expand-Tuple{}"><code>expand</code></a>. <a href="https://docs.sympy.org/latest/search.html?q=factor&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.free_symbols-Union{Tuple{S}, Tuple{T}} where {T, S&lt;:SymPyCore.SymbolicObject{T}}" href="#SymPyCore.free_symbols-Union{Tuple{S}, Tuple{T}} where {T, S&lt;:SymPyCore.SymbolicObject{T}}"><code>SymPyCore.free_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free_symbols(ex)
free_symbols(ex::Vector{Sym})</code></pre><p>Return vector of free symbols of expression or vector of expressions. The results are orderded by <code>sortperm(string.(fs))</code>.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; @syms x y z a
(x, y, z, a)

julia&gt; free_symbols(2*x + a*y) # [a, x, y]
3-element Vector{Sym{PythonCall.Py}}:
 a
 x
 y


julia&gt; free_symbols([x^2, x^2 - 2x*y + y^2])
2-element Vector{Sym{PythonCall.Py}}:
 x
 y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/utils.jl#L198-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.funcname" href="#SymPyCore.funcname"><code>SymPyCore.funcname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Introspection.funcname(x)</code></pre><p>Return name or &quot;&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/lambdify.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.integrate-Tuple{}" href="#SymPyCore.integrate-Tuple{}"><code>SymPyCore.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate</code></pre><p>Integrate an expression. Can return definite or indefinite integral.</p><p><a href="https://docs.sympy.org/latest/search.html?q=integrate&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L299-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.lambdify" href="#SymPyCore.lambdify"><code>SymPyCore.lambdify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lambdify(ex, vars=free_symbols();
         fns=Dict(), values=Dict, use_julia_code=false,
         invoke_latest=true)</code></pre><p>Take a symbolic expression and return a <code>Julia</code> function or expression to build a function.</p><ul><li><p><code>ex::Sym</code> a symbolic expression with 0, 1, or more free symbols</p></li><li><p><code>vars</code> a container of symbols to use for the function arguments. The default is <code>free_symbols</code> which has a specific ordering. Specifying <code>vars</code> allows this default ordering of arguments to be customized. If <code>vars</code> is empty, such as when the symbolic expression has <em>no</em> free symbols, a variable arg constant function is returned.</p></li><li><p><code>fns::Dict</code>, <code>vals::Dict</code>: Dictionaries that allow customization of the function that walks the expression <code>ex</code> and creates the corresponding AST for a Julia expression. See <code>SymPy.fn_map</code> and <code>SymPy.val_map</code> for the default mappings of sympy functions and values into <code>Julia</code>&#39;s AST.</p></li><li><p><code>use_julia_code::Bool</code>: use SymPy&#39;s conversion to an expression, the default is <code>false</code></p></li><li><p><code>invoke_latest=true</code>: if <code>true</code> will call <code>eval</code> and <code>Base.invokelatest</code> to return a function that should not have any world age issue. If <code>false</code> will return a Julia expression that can be <code>eval</code>ed to produce a function.</p></li></ul><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall

julia&gt; @syms x y z
(x, y, z)

julia&gt; ex = x^2 * sin(x)
 2
x ⋅sin(x)

julia&gt; fn = lambdify(ex);

julia&gt; fn(pi)
0.0

julia&gt; ex = x + 2y + 3z
x + 2⋅y + 3⋅z

julia&gt; fn = lambdify(ex);

julia&gt; fn(1,2,3) # order is by free_symbols
14

julia&gt; ex(x=&gt;1, y=&gt;2, z=&gt;3)
14

julia&gt; fn = lambdify(ex, (y,x,z));

julia&gt; fn(1,2,3)
13</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The default produces slower functions due to the calls to <code>eval</code> and <code>Base.invokelatest</code>.  In the following <code>g2</code> (which, as seen, requires additional work to compute) is as fast as calling <code>f</code> (on non symbolic types), whereas <code>g1</code> is an order of magnitude slower in this example.</p></div></div><pre><code class="language-julia hljs">julia&gt; @syms x
(x,)

julia&gt; f(x) = exp(cot(x))
f (generic function with 1 method)

julia&gt; g1 = lambdify(f(x));

julia&gt; ex = lambdify(f(x), invoke_latest=false);

julia&gt; @eval g2(x) = ($ex)(x)
g2 (generic function with 1 method)</code></pre><p>An alternative, say, is to use <code>GeneralizedGenerated</code>&#39;s <code>mk_function</code>, as follows:</p><pre><code class="language-julia hljs">julia&gt; using GeneralizedGenerated

julia&gt; body = convert(Expr, f(x))
:(exp(cot(x)))

julia&gt; g3 = mk_function((:x,), (), body)
function = (x;) -&gt; begin
    (Main).exp((Main).cot(x))
end</code></pre><p>This function will be about 2-3 times slower than <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/lambdify.jl#L270-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.lhs" href="#SymPyCore.lhs"><code>SymPyCore.lhs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rhs(eqn)
lhs(eqn)</code></pre><p>Returns right (or left) side of an equation object. Wrappers around <code>eqn.rhs()</code> and <code>eqn.lhs()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L283-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.linsolve-Tuple{}" href="#SymPyCore.linsolve-Tuple{}"><code>SymPyCore.linsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linsolve</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=linsolve&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.nonlinsolve-Tuple{}" href="#SymPyCore.nonlinsolve-Tuple{}"><code>SymPyCore.nonlinsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonlinsolve</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=nonlinsolve&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p><div class="admonition is-info"><header class="admonition-header">Systems</header><div class="admonition-body"><p>Use a tuple, not a vector, of equations when there is more than one.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L356-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.nroots-Tuple{}" href="#SymPyCore.nroots-Tuple{}"><code>SymPyCore.nroots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nroots</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=nroots&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.nsolve-Tuple{}" href="#SymPyCore.nsolve-Tuple{}"><code>SymPyCore.nsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nsolve</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=nsolve&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L342-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.real_roots-Tuple{}" href="#SymPyCore.real_roots-Tuple{}"><code>SymPyCore.real_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real_roots</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=real_roots&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.refine-Tuple{}" href="#SymPyCore.refine-Tuple{}"><code>SymPyCore.refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=refine&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L414-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.rhs" href="#SymPyCore.rhs"><code>SymPyCore.rhs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rhs(eqn)
lhs(eqn)</code></pre><p>Returns right (or left) side of an equation object. Wrappers around <code>eqn.rhs()</code> and <code>eqn.lhs()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/mathfuns.jl#L283-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.roots-Tuple{}" href="#SymPyCore.roots-Tuple{}"><code>SymPyCore.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots</code></pre><p>Find roots of a polynomial. Not exported, so needs to be qualified, as in <code>sympy.roots</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; sympy.roots(x^2 - 2x - 3)
Dict{} with 2 entries:
  3  =&gt; 1
  -1 =&gt; 1</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=roots&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L308-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.series-Tuple{}" href="#SymPyCore.series-Tuple{}"><code>SymPyCore.series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">series</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=series&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L392-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.simplify-Tuple{Any, Vararg{Any}}" href="#SymPyCore.simplify-Tuple{Any, Vararg{Any}}"><code>SymPyCore.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify</code></pre><p>SymPy has dozens of functions to perform various kinds of simplification. There is also one general function called <code>simplify</code> that attempts to apply all of these functions in an intelligent way to arrive at the simplest form of an expression. (See <a href="https://docs.sympy.org/latest/tutorial/simplification.html">Simplification</a> for details on <code>simplify</code> and other related functionality). Other simplification functions are available through the <code>sympy</code> object.</p><p>For non-symbolic expressions, <code>simplify</code> returns its first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/utils.jl#L161-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.simplify-Tuple{}" href="#SymPyCore.simplify-Tuple{}"><code>SymPyCore.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify</code></pre><p>Simplify symbolic expressions.</p><p><a href="https://docs.sympy.org/latest/search.html?q=simplify&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L238-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.solveset-Tuple{}" href="#SymPyCore.solveset-Tuple{}"><code>SymPyCore.solveset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solveset</code></pre><p>Like <code>solve</code> but returns a set object. Finite sets are returned as <code>Set</code> objects in <code>Julia</code>. Infinite sets must be queried.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; @syms x
(x,)

julia&gt; u = solveset(sin(x) ~ 1//2, x)
⎧        5⋅π │      ⎫   ⎧        π │      ⎫
⎨2⋅n⋅π + ───  │ n ∊ ℤ⎬ ∪ ⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬
⎩         6  │      ⎭   ⎩        6 │      ⎭

julia&gt; intersect(u, sympy.Interval(0, 2PI))
Set{Sym} with 2 elements:
  pi/6
  5*pi/6</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=solveset&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L367-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T&lt;:SymPyCore.SymbolicObject" href="#SymPyCore.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T&lt;:SymPyCore.SymbolicObject"><code>SymPyCore.subs</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>subs</code> is used to substitute a value in an expression with another value. Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall



julia&gt; @syms x,y
(x, y)

julia&gt; ex = (x-y)*(x+2y)
(x - y)⋅(x + 2⋅y)

julia&gt; subs(ex, (y, y^2)) |&gt; show
(x - y^2)*(x + 2*y^2)

julia&gt; subs(ex, (x,1), (y,2))
-5

julia&gt; subs(ex, (x,y^3), (y,2))
72

julia&gt; subs(ex, y, 3)
(x - 3)⋅(x + 6)</code></pre><p>There is a curried form of <code>subs</code> to use with the chaining <code>|&gt;</code> operator</p><pre><code class="language-julia-repl hljs">julia&gt; ex |&gt; subs(x,ℯ)
(ℯ - y)⋅(2⋅y + ℯ)</code></pre><p>The use of pairs gives a convenient alternative:</p><pre><code class="language-julia-repl hljs">julia&gt; subs(ex, x=&gt;1, y=&gt;2)
-5

julia&gt; ex |&gt; subs(x=&gt;1, y=&gt;2)
-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/utils.jl#L36-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.summation-Tuple{}" href="#SymPyCore.summation-Tuple{}"><code>SymPyCore.summation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">summation</code></pre><p><a href="https://docs.sympy.org/latest/search.html?q=summation&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L399-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.symbols-Tuple{}" href="#SymPyCore.symbols-Tuple{}"><code>SymPyCore.symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbols(arg; kwargs...)</code></pre><p>Construct symbolic values using <code>sympy.symbols</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.together-Tuple{}" href="#SymPyCore.together-Tuple{}"><code>SymPyCore.together</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">together</code></pre><p>Combine rational expressions. See <a href="#SymPyCore.apart-Tuple{}"><code>apart</code></a>.</p><p><a href="https://docs.sympy.org/latest/search.html?q=together&amp;check_keywords=yes&amp;area=default">SymPy documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/gen_methods.jl#L257-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymPyCore.walk_expression-Tuple{Any}" href="#SymPyCore.walk_expression-Tuple{Any}"><code>SymPyCore.walk_expression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walk_expression(ex; values=Dict(), fns=Dict())</code></pre><p>Convert a symbolic SymPy expression into a <code>Julia</code> expression. This is needed to use functions in external packages in lambdified functions.</p><p><strong>Extended help</strong></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using SymPy
@syms x y
ex = sympy.hyper((2,2),(3,3),x) * y</code></pre><p>Calling <code>lambdify(ex)</code> will fail to make a valid function, as <code>hyper</code> is implemented in <code>HypergeometricFunctions.pFq</code>. So, we have:</p><pre><code class="language-julia hljs">using HypergeometricFunctions
d = Dict(&quot;hyper&quot; =&gt; :pFq)
body = SymPy.walk_expression(ex, fns=d)
syms = Symbol.(free_symbols(ex))
fn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));
fn(1,1) # 1.6015187080185656</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SymPyCore.jl/blob/3b44de8e708a52eb5d33c73e9820c4365c4a514e/src/lambdify.jl#L201-L227">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 26 December 2023 19:30">Tuesday 26 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
