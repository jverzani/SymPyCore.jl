<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gotchas · SymPyCore</title><meta name="title" content="Gotchas · SymPyCore"/><meta property="og:title" content="Gotchas · SymPyCore"/><meta property="twitter:title" content="Gotchas · SymPyCore"/><meta name="description" content="Documentation for SymPyCore."/><meta property="og:description" content="Documentation for SymPyCore."/><meta property="twitter:description" content="Documentation for SymPyCore."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymPyCore</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><span class="tocitem">SymPy Tutorial</span><ul><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../preliminaries/">Preliminaries</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../basic_operations/">Basic operations</a></li><li><a class="tocitem" href="../simplification/">Simplification</a></li><li><a class="tocitem" href="../calculus/">Calculus</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../matrices/">Matrices</a></li><li><a class="tocitem" href="../manipulation/">Manipulation</a></li><li class="is-active"><a class="tocitem" href>Gotchas</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Symbols"><span>Symbols</span></a></li><li class="toplevel"><a class="tocitem" href="#Equals-signs"><span>Equals signs</span></a></li><li class="toplevel"><a class="tocitem" href="#Two-Final-Notes:-and-/"><span>Two Final Notes: <code>^</code> and <code>/</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Further-Reading"><span>Further Reading</span></a></li></ul></li><li><a class="tocitem" href="../printing/">printing</a></li><li><a class="tocitem" href="../next/">Next</a></li></ul></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../reference/">Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SymPy Tutorial</a></li><li class="is-active"><a href>Gotchas</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gotchas</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl/blob/main/docs/src/Tutorial/gotchas.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Gotchas"><a class="docs-heading-anchor" href="#Gotchas">Gotchas</a><a id="Gotchas-1"></a><a class="docs-heading-anchor-permalink" href="#Gotchas" title="Permalink"></a></h1><p>To begin, we should make something about SymPy clear.  SymPy is nothing more than a Python library, like <code>NumPy</code>, <code>Django</code>, or even modules in the Python standard library <code>sys</code> or <code>re</code>.  What this means is that SymPy does not add anything to the Python language.  Limitations that are inherent in the Python language are also inherent in SymPy.  It also means that SymPy tries to use Python idioms whenever possible, making programming with SymPy easy for those already familiar with programming with Python.  As a simple example, SymPy uses Python syntax to build expressions.  Implicit multiplication (like <code>3x</code> or <code>3 x</code>) is not allowed in Python, and thus not allowed in SymPy. To multiply <code>3</code> and <code>x</code>, you must type <code>3*x</code> with the <code>*</code>.</p><h1 id="Symbols"><a class="docs-heading-anchor" href="#Symbols">Symbols</a><a id="Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols" title="Permalink"></a></h1><p>One consequence of this fact is that SymPy can be used in any environment where Python is available.  We just import it, like we would any other library.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p><code>SymPyCore</code> is loaded as a backend by either <code>using SymPy</code> or <code>using SymPyPythonCall</code>.</p></div></div><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; from sympy import *</code></pre></details><hr/><p>This imports all the functions and classes from SymPy into our interactive Python session.  Now, suppose we start to do a computation.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>Only a select set of functions and classes are imported in <code>julia</code>, others can be accessed from the <code>sympy</code> module that is created when the package is loaded. Further SymPy libraries can be imported, as shown in the Overview documentation page.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x + 1</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `x` not defined</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x + 1
    Traceback (most recent call last):
    ...
    NameError: name &#39;x&#39; is not defined</code></pre></details><hr/><p>Oops! What happened here?  We tried to use the variable <code>x</code>, but it tells us that <code>x</code> is not defined.  In Python, variables have no meaning until they are defined.  SymPy is no different.  Unlike many symbolic manipulation systems you may have used, in SymPy, variables are not defined automatically. To define variables, we must use <code>symbols</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>The <code>symbols</code> constructor, used in the <code>Python</code> version of this tutorial, is replaced here by <code>@syms</code>, though it can be also be used as illustrated in the Python examples: <code>x = symbols(&quot;x&quot;)</code>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x     # x = symbols(&quot;x&quot;) is an alternative</code><code class="nohighlight hljs ansi" style="display:block;">(x,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x + 1</code><code class="nohighlight hljs ansi" style="display:block;">x + 1</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x = symbols(&#39;x&#39;)
    &gt;&gt;&gt; x + 1
    x + 1</code></pre></details><hr/><p><code>symbols</code> takes a string of variable names separated by spaces or commas, and creates Symbols out of them.  We can then assign these to variable names. Later, we will investigate some convenient ways we can work around this issue. For now, let us just define the most common variable names, <code>x</code>, <code>y</code>, and <code>z</code>, for use through the rest of this section</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>The <code>@syms</code> macro does not need assignment, it creates variables in local scope.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x, y, z</code><code class="nohighlight hljs ansi" style="display:block;">(x, y, z)</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x, y, z = symbols(&#39;x y z&#39;)</code></pre></details><hr/><p>As a final note, we note that the name of a Symbol and the name of the variable it is assigned to need not have anything to do with one another.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>This kind of name mangling can be done using <code>=&gt;</code> with the <code>@syms</code> constructor.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms a=&gt;&quot;b&quot;, b=&gt;&quot;a&quot;</code><code class="nohighlight hljs ansi" style="display:block;">(b, a)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a # prints as &quot;b&quot;</code><code class="nohighlight hljs ansi" style="display:block;">b</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; a, b = symbols(&#39;b a&#39;)
    &gt;&gt;&gt; a
    b
    &gt;&gt;&gt; b
    a</code></pre></details><hr/><p>Here we have done the very confusing thing of assigning a Symbol with the name <code>a</code> to the variable <code>b</code>, and a Symbol of the name <code>b</code> to the variable <code>a</code>.  Now the Python variable named <code>a</code> points to the SymPy Symbol named <code>b</code>, and vice versa.  How confusing.  We could have also done something like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms crazy =&gt; &quot;unrelated&quot;</code><code class="nohighlight hljs ansi" style="display:block;">(unrelated,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; crazy + 1</code><code class="nohighlight hljs ansi" style="display:block;">unrelated + 1</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; crazy = symbols(&#39;unrelated&#39;)
    &gt;&gt;&gt; crazy + 1
    unrelated + 1</code></pre></details><hr/><p>This also shows that Symbols can have names longer than one character if we want.</p><p>Usually, the best practice is to assign Symbols to Python variables of the same name, although there are exceptions:  Symbol names can contain characters that are not allowed in Python variable names, or may just want to avoid typing long names by assigning Symbols with long names to single letter Python variables.</p><p>To avoid confusion, throughout this tutorial, Symbol names and Python variable names will always coincide.  Furthermore, the word &quot;Symbol&quot; will refer to a SymPy Symbol and the word &quot;variable&quot; will refer to a Python variable.</p><p>Finally, let us be sure we understand the difference between SymPy Symbols and Python variables.  Consider the following::</p><pre><code class="nohighlight hljs">  x = symbols(&#39;x&#39;)
  expr = x + 1
  x = 2
  print(expr)</code></pre><p>What do you think the output of this code will be?  If you thought <code>3</code>, you&#39;re wrong.  Let&#39;s see what really happens</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x</code><code class="nohighlight hljs ansi" style="display:block;">(x,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = x + 1</code><code class="nohighlight hljs ansi" style="display:block;">x + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr</code><code class="nohighlight hljs ansi" style="display:block;">x + 1</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x = symbols(&#39;x&#39;)
    &gt;&gt;&gt; expr = x + 1
    &gt;&gt;&gt; x = 2
    &gt;&gt;&gt; print(expr)
    x + 1</code></pre></details><hr/><p>Changing <code>x</code> to <code>2</code> had no effect on <code>expr</code>.  This is because <code>x = 2</code> changes the Python variable <code>x</code> to <code>2</code>, but has no effect on the SymPy Symbol <code>x</code>, which was what we used in creating <code>expr</code>.  When we created <code>expr</code>, the Python variable <code>x</code> was a Symbol.  After we created, it, we changed the Python variable <code>x</code> to 2.  But <code>expr</code> remains the same.  This behavior is not unique to SymPy.  All Python programs work this way: if a variable is changed, expressions that were already created with that variable do not change automatically.  For example</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>This is similar in <code>Julia</code></p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = &quot;abc&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abc&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = x * &quot;def&quot; # * not +</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abcdef&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abcdef&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = &quot;ABC&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;ABC&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abcdef&quot;</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x = &#39;abc&#39;
    &gt;&gt;&gt; expr = x + &#39;def&#39;
    &gt;&gt;&gt; expr
    &#39;abcdef&#39;
    &gt;&gt;&gt; x = &#39;ABC&#39;
    &gt;&gt;&gt; expr
    &#39;abcdef&#39;</code></pre></details><hr/><div class="admonition is-info"><header class="admonition-header">Quick Tip</header><div class="admonition-body"><p>To change the value of a Symbol in an expression, use <code>subs</code></p><pre><code class="nohighlight hljs"> &gt;&gt;&gt; x = symbols(&#39;x&#39;)
 &gt;&gt;&gt; expr = x + 1
 &gt;&gt;&gt; expr.subs(x, 2)
 3</code></pre></div></div><p>In this example, if we want to know what <code>expr</code> is with the new value of <code>x</code>, we need to reevaluate the code that created <code>expr</code>, namely, <code>expr = x + 1</code>.  This can be complicated if several lines created <code>expr</code>.  One advantage of using a symbolic computation system like SymPy is that we can build a symbolic representation for <code>expr</code>, and then substitute <code>x</code> with values.  The correct way to do this in SymPy is to use <code>subs</code>, which will be discussed in more detail later.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We use the more <code>Julia</code>n <code>subs(expr, ...)</code> in lieu of <code>expr.subs(...)</code>, which is also possible, though does not allow the <code>Julia</code>n specification of paired data using <code>=&gt;</code>..</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x</code><code class="nohighlight hljs ansi" style="display:block;">(x,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = x + 1</code><code class="nohighlight hljs ansi" style="display:block;">x + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, x =&gt; 2)</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x = symbols(&#39;x&#39;)
    &gt;&gt;&gt; expr = x + 1
    &gt;&gt;&gt; expr.subs(x, 2)
    3</code></pre></details><hr/><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>Add link to basic operations section</p></div></div><h1 id="Equals-signs"><a class="docs-heading-anchor" href="#Equals-signs">Equals signs</a><a id="Equals-signs-1"></a><a class="docs-heading-anchor-permalink" href="#Equals-signs" title="Permalink"></a></h1><p>Another very important consequence of the fact that SymPy does not extend Python syntax is that <code>=</code> does not represent equality in SymPy.  Rather it is Python variable assignment.  This is hard-coded into the Python language, and SymPy makes no attempts to change that.</p><p>You may think, however, that <code>==</code>, which is used for equality testing in Python, is used for SymPy as equality.  This is not quite correct either.  Let us see what happens when we use <code>==</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>In math <span>$=$</span> is for specifying an equation, but in <code>Julia</code> (as with <code>Python</code>), <code>=</code> is for assignment. The <code>==</code> checks for equality (<code>Julia</code> also uses <code>===</code> and <code>isequal</code> for related, but different tests of equality). Equations in <code>SymPy</code> use either <code>Eq</code> as a function or <code>~</code> as an infix operator.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x + 1 == 4</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x + 1 == 4
    False</code></pre></details><hr/><p>Instead of treating <code>x + 1 == 4</code> symbolically, we just got <code>False</code>.  In SymPy, <code>==</code> represents exact structural equality testing.  This means that <code>a == b</code> means that we are <em>asking</em> if <code>a = b</code>.  We always get a <code>bool</code> as the result of <code>==</code>. There is a separate object, called Eq, which can be used to create symbolic equalities.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>In <code>Julia</code>, in addition to <code>Eq</code> as a function, the infix operator <code>~</code> can also be utilized to make equations.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x + 1 ~ 4</code><code class="nohighlight hljs ansi" style="display:block;">x + 1 = 4</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; Eq(x + 1, 4)
    Eq(x + 1, 4)</code></pre></details><hr/><p>There is one additional caveat about <code>==</code> as well.  Suppose we want to know if <code>(x + 1)^2 = x^2 + 2x + 1</code>.  We might try something like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (x+1)^2 == x^2 + 2x + 1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; (x + 1)**2 == x**2 + 2*x + 1
    False</code></pre></details><hr/><p>We got <code>False</code> again. However, <code>(x + 1)^2</code> <em>does</em> equal <code>x^2 + 2x + 1</code>. What is going on here?  Did we find a bug in SymPy, or is it just not powerful enough to recognize this basic algebraic fact?</p><p>Recall from above that <code>==</code> represents <em>exact</em> structural equality testing. &quot;Exact&quot; here means that two expressions will compare equal with <code>==</code> only if they are exactly equal structurally.  Here, <code>(x + 1)^2</code> and <code>x^2 + 2x + 1</code> are not the same structurally. One is the power of an addition of two terms, and the other is the addition of three terms.</p><p>It turns out that when using SymPy as a library, having <code>==</code> test for exact structural equality is far more useful than having it represent symbolic equality, or having it test for mathematical equality.  However, as a new user, you will probably care more about the latter two.  We have already seen an alternative to representing equalities symbolically, <code>Eq</code>.  To test if two things are equal, it is best to recall the basic fact that if <code>a = b</code>, then <code>a - b = 0</code>.  Thus, the best way to check if <code>a = b</code> is to take <code>a - b</code> and simplify it, and see if it goes to 0.  We will learn <a href="tutorial-simplify">later</a> that the function to do this is called <code>simplify</code>. This method is not infallible–-in fact, it can be <a href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">theoretically proven</a> that it is impossible to determine if two symbolic expressions are identically equal in general–-but for most common expressions, it works quite well.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = (x+1)^2</code><code class="nohighlight hljs ansi" style="display:block;">       2
(x + 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = x^2 + 2x + 1</code><code class="nohighlight hljs ansi" style="display:block;"> 2
x  + 2⋅x + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(a - b)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = x^2 - 2x +1</code><code class="nohighlight hljs ansi" style="display:block;"> 2
x  - 2⋅x + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(a - c)</code><code class="nohighlight hljs ansi" style="display:block;">4⋅x</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; a = (x + 1)**2
    &gt;&gt;&gt; b = x**2 + 2*x + 1
    &gt;&gt;&gt; simplify(a - b)
    0
    &gt;&gt;&gt; c = x**2 - 2*x + 1
    &gt;&gt;&gt; simplify(a - c)
    4*x</code></pre></details><hr/><p>There is also a method called <code>equals</code> that tests if two expressions are equal by evaluating them numerically at random points.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = cos(x)^2 - sin(x)^2</code><code class="nohighlight hljs ansi" style="display:block;">     2         2
- sin (x) + cos (x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = cos(2*x)</code><code class="nohighlight hljs ansi" style="display:block;">cos(2⋅x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a.equals(b)</code><code class="nohighlight hljs ansi" style="display:block;">True</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; a = cos(x)**2 - sin(x)**2
    &gt;&gt;&gt; b = cos(2*x)
    &gt;&gt;&gt; a.equals(b)
    True</code></pre></details><hr/><h1 id="Two-Final-Notes:-and-/"><a class="docs-heading-anchor" href="#Two-Final-Notes:-and-/">Two Final Notes: <code>^</code> and <code>/</code></a><a id="Two-Final-Notes:-and-/-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Final-Notes:-and-/" title="Permalink"></a></h1><p>You may have noticed that we have been using <code>**</code> for exponentiation instead of the standard <code>^</code>.  That&#39;s because SymPy follows Python&#39;s conventions.  In Python, <code>^</code> represents logical exclusive or.  SymPy follows this convention:</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>The <code>^</code> is for exponents; use <code>&amp;</code> or <code>|</code> instead</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sym(true) &amp; Sym(false)</code><code class="nohighlight hljs ansi" style="display:block;">False</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sym(true) | Sym(true)</code><code class="nohighlight hljs ansi" style="display:block;">True</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xor(x, y)</code><code class="nohighlight hljs ansi" style="display:block;">x ⊻ y</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; True ^ False
    True
    &gt;&gt;&gt; True ^ True
    False
    &gt;&gt;&gt; Xor(x, y)
    x ^ y</code></pre></details><hr/><p>Finally, a small technical discussion on how SymPy works is in order.  When you type something like <code>x + 1</code>, the SymPy Symbol <code>x</code> is added to the Python int <code>1</code>.  Python&#39;s operator rules then allow SymPy to tell Python that SymPy objects know how to be added to Python ints, and so <code>1</code> is automatically converted to the SymPy Integer object.</p><p>This sort of operator magic happens automatically behind the scenes, and you rarely need to even know that it is happening.  However, there is one exception.  Whenever you combine a SymPy object and a SymPy object, or a SymPy object and a Python object, you get a SymPy object, but whenever you combine two Python objects, SymPy never comes into play, and so you get a Python object.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>This is also how promotion works within <code>Julia</code> in that promotion to symbolic types is sticky</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Sym(1) + 1)</code><code class="nohighlight hljs ansi" style="display:block;">SymPyCore.Sym{PythonCall.Core.Py}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1 + 1)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; type(Integer(1) + 1)
    &lt;class &#39;sympy.core.numbers.Integer&#39;&gt;
    &gt;&gt;&gt; type(1 + 1)
    &lt;... &#39;int&#39;&gt;</code></pre></details><hr/><p>This is usually not a big deal. Python ints work much the same as SymPy Integers, but there is one important exception:  division.  In SymPy, the division of two Integers gives a Rational:</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>In <code>Julia</code> <code>Sym(1//3)</code> will also produce a symbolic rational, but not <code>Sym(1/3)</code>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = Sym(1) / Sym(3)</code><code class="nohighlight hljs ansi" style="display:block;">1/3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(u)</code><code class="nohighlight hljs ansi" style="display:block;">SymPyCore.Sym{PythonCall.Core.Py}</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; Integer(1)/Integer(3)
    1/3
    &gt;&gt;&gt; type(Integer(1)/Integer(3))
    &lt;class &#39;sympy.core.numbers.Rational&#39;&gt;</code></pre></details><hr/><p>But in Python <code>/</code> represents either integer division or floating point division, depending on whether you are in Python 2 or Python 3, and depending on whether or not you have run <code>from __future__ import division</code> in Python 2 which is no longer supported from versions above SymPy 1.5.1:</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>In <code>Julia</code> <code>/</code> is division and for integers returns a floating point value.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 1/2</code><code class="nohighlight hljs ansi" style="display:block;">0.5</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; from __future__ import division
    &gt;&gt;&gt; 1/2
    0.5</code></pre></details><hr/><p>To avoid this, we can construct the rational object explicitly</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>While <code>sympy.Rational(1, 2)</code> produces a rational number, a more <code>Julia</code>n way is to convert a rational into a symbolic value</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sym(1//2)</code><code class="nohighlight hljs ansi" style="display:block;">1/2</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; Rational(1, 2)
    1/2</code></pre></details><hr/><p>This problem also comes up whenever we have a larger symbolic expression with <code>int/int</code> in it.  For example:</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>This is also a problem in <code>Julia</code></p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x + 1/2</code><code class="nohighlight hljs ansi" style="display:block;">x + 0.5</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x + 1/2
    x + 0.5</code></pre></details><hr/><p>This happens because Python first evaluates <code>1/2</code> into <code>0.5</code>, and then that is cast into a SymPy type when it is added to <code>x</code>.  Again, we can get around this by explicitly creating a Rational:</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>Use a rational, in the same way:</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x + 1//2</code><code class="nohighlight hljs ansi" style="display:block;">x + 1/2</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; x + Rational(1, 2)
    x + 1/2</code></pre></details><hr/><p>There are several tips on avoiding this situation in the :ref:<code>gotchas</code> document.</p><h1 id="Further-Reading"><a class="docs-heading-anchor" href="#Further-Reading">Further Reading</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></h1><p>For more discussion on the topics covered in this section, see :ref:<code>gotchas</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manipulation/">« Manipulation</a><a class="docs-footer-nextpage" href="../printing/">printing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 28 January 2025 23:16">Tuesday 28 January 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
