<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic operations · SymPyCore</title><meta name="title" content="Basic operations · SymPyCore"/><meta property="og:title" content="Basic operations · SymPyCore"/><meta property="twitter:title" content="Basic operations · SymPyCore"/><meta name="description" content="Documentation for SymPyCore."/><meta property="og:description" content="Documentation for SymPyCore."/><meta property="twitter:description" content="Documentation for SymPyCore."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymPyCore</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><span class="tocitem">SymPy Tutorial</span><ul><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../preliminaries/">Preliminaries</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Basic operations</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Substitution"><span>Substitution</span></a></li><li class="toplevel"><a class="tocitem" href="#Converting-Strings-to-SymPy-Expressions"><span>Converting Strings to SymPy Expressions</span></a></li><li class="toplevel"><a class="tocitem" href="#evalf"><span><code>evalf</code></span></a></li><li class="toplevel"><a class="tocitem" href="#lambdify"><span><code>lambdify</code></span></a></li></ul></li><li><a class="tocitem" href="../simplification/">Simplification</a></li><li><a class="tocitem" href="../calculus/">Calculus</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../matrices/">Matrices</a></li><li><a class="tocitem" href="../manipulation/">Manipulation</a></li><li><a class="tocitem" href="../gotchas/">Gotchas</a></li><li><a class="tocitem" href="../printing/">printing</a></li><li><a class="tocitem" href="../next/">Next</a></li></ul></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../reference/">Reference/API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SymPy Tutorial</a></li><li class="is-active"><a href>Basic operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyCore.jl/blob/main/docs/src/Tutorial/basic_operations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Operations"><a class="docs-heading-anchor" href="#Basic-Operations">Basic Operations</a><a id="Basic-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Operations" title="Permalink"></a></h1><p>Here we discuss some of the most basic operations needed for expression manipulation in SymPy.  Some more advanced operations will be discussed later in the <a href="tutorial-manipulation">advanced expression manipulation</a> section.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We access SymPy from <code>Julia</code> by loading either the <code>SymPy</code> or <code>SymPyPythonCall</code> packages. Once loaded, commands like the following one should run without complaint.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @syms x, y, z</code><code class="nohighlight hljs ansi" style="display:block;">(x, y, z)</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; from sympy import *
    &gt;&gt;&gt; x, y, z = symbols(&quot;x y z&quot;)</code></pre></details><hr/><h1 id="Substitution"><a class="docs-heading-anchor" href="#Substitution">Substitution</a><a id="Substitution-1"></a><a class="docs-heading-anchor-permalink" href="#Substitution" title="Permalink"></a></h1><p>One of the most common things you might want to do with a mathematical expression is substitution.  Substitution replaces all instances of something in an expression with something else.  It is done using the <code>subs</code> method. For example</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We can call <code>subs</code> using the <code>Julia</code>n notation of <code>subs(expr, ...)</code> rather than the object methoc syntax more common in Python, <code>expr.subs(...)</code>. Further, we can use &quot;pairs&quot; notation when calling <code>subs</code> in this manner.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = cos(x) + 1</code><code class="nohighlight hljs ansi" style="display:block;">cos(x) + 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, x=&gt;y)</code><code class="nohighlight hljs ansi" style="display:block;">cos(y) + 1</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = cos(x) + 1
    &gt;&gt;&gt; expr.subs(x, y)
    cos(y) + 1</code></pre></details><hr/><p>Substitution is usually done for one of two reasons:</p><ol><li>Evaluating an expression at a point. For example, if our expression is <code>cos(x) + 1</code> and we want to evaluate it at the point <code>x = 0</code>, so that we get <code>cos(0) + 1</code>, which is 2.</li></ol><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We can also use the object-method syntax.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr.subs(x,0)</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">   &gt;&gt;&gt; expr.subs(x, 0)
   2</code></pre></details><hr/><ol><li>Replacing a subexpression with another subexpression.  There are two reasons we might want to do this.  The first is if we are trying to build an expression that has some symmetry, such as <code>x^{x^{x^x}}</code>.  To build this, we might start with <code>x**y</code>, and replace <code>y</code> with <code>x**y</code>.  We would then get <code>x**(x**y)</code>.  If we replaced <code>y</code> in this new expression with <code>x**x</code>, we would get <code>x**(x**(x**x))</code>, the desired expression.</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = x^y</code><code class="nohighlight hljs ansi" style="display:block;"> y
x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = subs(expr, y =&gt; x^y)</code><code class="nohighlight hljs ansi" style="display:block;"> ⎛ y⎞
 ⎝x ⎠
x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, y =&gt; x^x)</code><code class="nohighlight hljs ansi" style="display:block;"> ⎛ ⎛ x⎞⎞
 ⎜ ⎝x ⎠⎟
 ⎝x    ⎠
x</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">   &gt;&gt;&gt; expr = x**y
   &gt;&gt;&gt; expr
   x**y
   &gt;&gt;&gt; expr = expr.subs(y, x**y)
   &gt;&gt;&gt; expr
   x**(x**y)
   &gt;&gt;&gt; expr = expr.subs(y, x**x)
   &gt;&gt;&gt; expr
   x**(x**(x**x))</code></pre></details><hr/><p>The second is if we want to perform a very controlled simplification, or    perhaps a simplification that SymPy is otherwise unable to do.  For    example, say we have <code>\sin(2x) + \cos(2x)</code>, and we want to replace    <code>\sin(2x)</code> with <code>2\sin(x)\cos(x)</code>.  As we will learn later, the function    <code>expand_trig</code> does this.  However, this function will also expand    <code>\cos(2x)</code>, which we may not want.  While there are ways to perform such    precise simplification, and we will learn some of them in the    <a href="tutorial-manipulation">advanced expression manipulation</a> section, an    easy way is to just replace <code>\sin(2x)</code> with <code>2\sin(x)\cos(x)</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>As <code>expand_trig</code> is not exposed, it is called as a function from the <code>sympy</code> module, using the dot notation to access underlying values in the module.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = sin(2x) + cos(2x)</code><code class="nohighlight hljs ansi" style="display:block;">sin(2⋅x) + cos(2⋅x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sympy.expand_trig(expr)</code><code class="nohighlight hljs ansi" style="display:block;">                       2
2⋅sin(x)⋅cos(x) + 2⋅cos (x) - 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, sin(2x) =&gt; 2*sin(x)* cos(x))</code><code class="nohighlight hljs ansi" style="display:block;">2⋅sin(x)⋅cos(x) + cos(2⋅x)</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">   &gt;&gt;&gt; expr = sin(2*x) + cos(2*x)
   &gt;&gt;&gt; expand_trig(expr)
   2*sin(x)*cos(x) + 2*cos(x)**2 - 1
   &gt;&gt;&gt; expr.subs(sin(2*x), 2*sin(x)*cos(x))
   2*sin(x)*cos(x) + cos(2*x)</code></pre></details><hr/><p>There are two important things to note about <code>subs</code>.  First, it returns a new expression.  SymPy objects are immutable.  That means that <code>subs</code> does not modify it in-place.  For example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = cos(x)</code><code class="nohighlight hljs ansi" style="display:block;">cos(x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, x=&gt;0)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr</code><code class="nohighlight hljs ansi" style="display:block;">cos(x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x</code><code class="nohighlight hljs ansi" style="display:block;">x</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">   &gt;&gt;&gt; expr = cos(x)
   &gt;&gt;&gt; expr.subs(x, 0)
   1
   &gt;&gt;&gt; expr
   cos(x)
   &gt;&gt;&gt; x
   x</code></pre></details><hr/><div class="admonition is-info"><header class="admonition-header">Quick Tip</header><div class="admonition-body"><p>SymPy expressions are immutable.  No function will change them in-place.</p></div></div><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>As with <code>Pytbon</code>, <code>SymPy</code> expressions are immutable.  No function will change them in-place.</p></div></div><p>Here, we see that performing <code>expr.subs(x, 0)</code> leaves <code>expr</code> unchanged. In fact, since SymPy expressions are immutable, no function will change them in-place.  All functions will return new expressions.</p><p>To perform multiple substitutions at once, pass a list of <code>(old, new)</code> pairs to <code>subs</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = x^3 + 4x*y - z</code><code class="nohighlight hljs ansi" style="display:block;"> 3
x  + 4⋅x⋅y - z</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, x=&gt;2, y=&gt;4, z=&gt;0)</code><code class="nohighlight hljs ansi" style="display:block;">40</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = x**3 + 4*x*y - z
    &gt;&gt;&gt; expr.subs([(x, 2), (y, 4), (z, 0)])
    40</code></pre></details><hr/><p>It is often useful to combine this with a list comprehension to do a large set of similar replacements all at once.  For example, say we had <code>x^4 - 4x^3 + 4x^2 - 2x + 3</code> and we wanted to replace all instances of <code>x</code> that have an even power with <code>y</code>, to get <code>y^4 - 4x^3 + 4y^2 - 2x + 3</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We use pairs notation, though tuples could also be used</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = x^4 - 4x^3 + 4x^2 - 2x + 3</code><code class="nohighlight hljs ansi" style="display:block;"> 4      3      2
x  - 4⋅x  + 4⋅x  - 2⋅x + 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; replacements = [x^i =&gt; y^i for i in 0:4 if iseven(i)]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Pair{SymPyCore.Sym{PythonCall.Core.Py}, SymPyCore.Sym{PythonCall.Core.Py}}}:
   1 =&gt; 1
 x^2 =&gt; y^2
 x^4 =&gt; y^4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, replacements...)</code><code class="nohighlight hljs ansi" style="display:block;">     3          4      2
- 4⋅x  - 2⋅x + y  + 4⋅y  + 3</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = x**4 - 4*x**3 + 4*x**2 - 2*x + 3
    &gt;&gt;&gt; replacements = [(x**i, y**i) for i in range(5) if i % 2 == 0]
    &gt;&gt;&gt; expr.subs(replacements)
    -4*x**3 - 2*x + y**4 + 4*y**2 + 3</code></pre></details><hr/><h1 id="Converting-Strings-to-SymPy-Expressions"><a class="docs-heading-anchor" href="#Converting-Strings-to-SymPy-Expressions">Converting Strings to SymPy Expressions</a><a id="Converting-Strings-to-SymPy-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Strings-to-SymPy-Expressions" title="Permalink"></a></h1><p>The <code>sympify</code> function (that&#39;s <code>sympify</code>, not to be confused with <code>simplify</code>) can be used to convert strings into SymPy expressions.</p><p>For example</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We can&#39;t use <code>3x</code> (literal multiplication) as it isn&#39;t parsed correctly. We do not need to use a rational (e.g. <code>1//2</code>), as that is parsed as desired.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str_expr = &quot;x^3 + 3*x - 1/2&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;x^3 + 3*x - 1/2&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = sympify(str_expr)</code><code class="nohighlight hljs ansi" style="display:block;"> 3         1
x  + 3⋅x - ─
           2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subs(expr, x=&gt;2)</code><code class="nohighlight hljs ansi" style="display:block;">27/2</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; str_expr = &quot;x**2 + 3*x - 1/2&quot;
    &gt;&gt;&gt; expr = sympify(str_expr)
    &gt;&gt;&gt; expr
    x**2 + 3*x - 1/2
    &gt;&gt;&gt; expr.subs(x, 2)
    19/2</code></pre></details><hr/><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>sympify</code> uses <code>eval</code>.  Don&#39;t use it on unsanitized input.</p></div></div><h1 id="evalf"><a class="docs-heading-anchor" href="#evalf"><code>evalf</code></a><a id="evalf-1"></a><a class="docs-heading-anchor-permalink" href="#evalf" title="Permalink"></a></h1><p>To evaluate a numerical expression into a floating point number, use <code>evalf</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We need to wrap <code>8</code> in <code>Sym</code> otherwise, <code>sqrt</code> will dispatch to the base function in <code>Julia</code>. Also, we could use <code>N(expr)</code> to get a <code>Julia</code> value, as <code>evalf</code> returns a symbolic value.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = sqrt(Sym(8))</code><code class="nohighlight hljs ansi" style="display:block;">2⋅√2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr.evalf()</code><code class="nohighlight hljs ansi" style="display:block;">2.82842712474619</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = sqrt(8)
    &gt;&gt;&gt; expr.evalf()
    2.82842712474619</code></pre></details><hr/><p>SymPy can evaluate floating point expressions to arbitrary precision.  By default, 15 digits of precision are used, but you can pass any number as the argument to <code>evalf</code>.  Let&#39;s compute the first 100 digits of <code>\pi</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We use <code>PI</code> of <code>Sym(pi)</code> to express the symbolic value of <span>$\pi$</span>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; PI.evalf(100)</code><code class="nohighlight hljs ansi" style="display:block;">3.1415926535897932384626433832795028841971693993751058209749445923078164062862 ↪

↪ 08998628034825342117068</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; pi.evalf(100)
    3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068</code></pre></details><hr/><p>To numerically evaluate an expression with a Symbol at a point, we might use <code>subs</code> followed by <code>evalf</code>, but it is more efficient and numerically stable to pass the substitution to <code>evalf</code> using the <code>subs</code> flag, which takes a dictionary of <code>Symbol: point</code> pairs.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>A <code>Julia</code> <code>Dict</code> can be used when the underlying sympy method expects a Python dict.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = cos(2x)</code><code class="nohighlight hljs ansi" style="display:block;">cos(2⋅x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr.evalf(subs=Dict(x=&gt;2.4))</code><code class="nohighlight hljs ansi" style="display:block;">0.0874989834394464</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; expr = cos(2*x)
    &gt;&gt;&gt; expr.evalf(subs={x: 2.4})
    0.0874989834394464</code></pre></details><hr/><p>Sometimes there are roundoff errors smaller than the desired precision that remain after an expression is evaluated. Such numbers can be removed at the user&#39;s discretion by setting the <code>chop</code> flag to True.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>We don&#39;t use the reserved name <code>one</code>, as it is a base function name in <code>Julia</code></p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; o = cos(Sym(1))^2 + sin(Sym(1))^2</code><code class="nohighlight hljs ansi" style="display:block;">   2         2
cos (1) + sin (1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (o-1).evalf()</code><code class="nohighlight hljs ansi" style="display:block;">-0.e-124</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (o - 1).evalf(chop=true)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: Python: TypeError: must be real number, not BooleanTrue
Python stacktrace:
 [1] <span class="sgr1">evalf</span>
<span class="sgr90">   @ </span><span class="sgr32">sympy.core.evalf </span><span class="sgr90">~/work/SymPyCore.jl/SymPyCore.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/sympy/core/evalf.py:1528</span>
 [2] <span class="sgr1">&lt;listcomp&gt;</span>
<span class="sgr90">   @ </span><span class="sgr32">sympy.core.evalf </span><span class="sgr90">~/work/SymPyCore.jl/SymPyCore.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/sympy/core/evalf.py:601</span>
 [3] <span class="sgr1">evalf_add</span>
<span class="sgr90">   @ </span><span class="sgr32">sympy.core.evalf </span><span class="sgr90">~/work/SymPyCore.jl/SymPyCore.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/sympy/core/evalf.py:601</span>
 [4] <span class="sgr1">evalf</span>
<span class="sgr90">   @ </span><span class="sgr32">sympy.core.evalf </span><span class="sgr90">~/work/SymPyCore.jl/SymPyCore.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/sympy/core/evalf.py:1483</span>
 [5] <span class="sgr1">evalf</span>
<span class="sgr90">   @ </span><span class="sgr32">sympy.core.evalf </span><span class="sgr90">~/work/SymPyCore.jl/SymPyCore.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/sympy/core/evalf.py:1648</span></code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; one = cos(1)**2 + sin(1)**2
    &gt;&gt;&gt; (one - 1).evalf()
    -0.e-124
    &gt;&gt;&gt; (one - 1).evalf(chop=True)
    0</code></pre></details><hr/><h1 id="lambdify"><a class="docs-heading-anchor" href="#lambdify"><code>lambdify</code></a><a id="lambdify-1"></a><a class="docs-heading-anchor-permalink" href="#lambdify" title="Permalink"></a></h1><p><code>subs</code> and <code>evalf</code> are good if you want to do simple evaluation, but if you intend to evaluate an expression at many points, there are more efficient ways.  For example, if you wanted to evaluate an expression at a thousand points, using SymPy would be far slower than it needs to be, especially if you only care about machine precision.  Instead, you should use libraries like <a href="https://numpy.org/">NumPy</a> and <a href="https://scipy.org/">SciPy</a>.</p><p>The easiest way to convert a SymPy expression to an expression that can be numerically evaluated is to use the <code>lambdify</code> function.  <code>lambdify</code> acts like a <code>lambda</code> function, except it converts the SymPy names to the names of the given numerical library, usually NumPy.  For example</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>The <code>lambdify</code> function does not use sympy&#39;s <code>lambdify</code> and has room for improvement, as compared to that in the <code>Symbolics</code> suite.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 0:9</code><code class="nohighlight hljs ansi" style="display:block;">0:9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = sin(x)</code><code class="nohighlight hljs ansi" style="display:block;">sin(x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fn = lambdify(expr)</code><code class="nohighlight hljs ansi" style="display:block;">Callable function with a single variable x</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fn.(a)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Float64}:
  0.0
  0.8414709848078965
  0.9092974268256817
  0.1411200080598672
 -0.7568024953079282
 -0.9589242746631385
 -0.27941549819892586
  0.6569865987187891
  0.9893582466233818
  0.4121184852417566</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; import numpy # doctest:+SKIP
    &gt;&gt;&gt; a = numpy.arange(10) # doctest:+SKIP
    &gt;&gt;&gt; expr = sin(x)
    &gt;&gt;&gt; f = lambdify(x, expr, &quot;numpy&quot;) # doctest:+SKIP
    &gt;&gt;&gt; f(a) # doctest:+SKIP
    [ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427
     -0.2794155   0.6569866   0.98935825  0.41211849]</code></pre></details><hr/><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>lambdify</code> uses <code>eval</code>.  Don&#39;t use it on unsanitized input.</p></div></div><p>You can use other libraries than NumPy. For example, to use the standard library math module, use <code>&quot;math&quot;</code>.</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>The library option is not available though some function equivalences may be needed</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fn(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">0.09983341664682815</code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; f = lambdify(x, expr, &quot;math&quot;)
    &gt;&gt;&gt; f(0.1)
    0.0998334166468</code></pre></details><hr/><p>To use lambdify with numerical libraries that it does not know about, pass a dictionary of <code>sympy_name:numerical_function</code> pairs.  For example</p><div class="admonition is-success"><header class="admonition-header">Julia differences</header><div class="admonition-body"><p>While passing in a map of function values is supported, creating an arbitrary function is not. In <code>Symbolics</code> one can <code>@register</code> a function, this could be added.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><hr/><details><summary>Expand for Python example</summary><pre><code class="language-python hljs">    &gt;&gt;&gt; def mysin(x):
    ...     &quot;&quot;&quot;
    ...     My sine. Note that this is only accurate for small x.
    ...     &quot;&quot;&quot;
    ...     return x
    &gt;&gt;&gt; f = lambdify(x, expr, {&quot;sin&quot;:mysin})
    &gt;&gt;&gt; f(0.1)
    0.1</code></pre></details><hr/><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>Write an advanced numerics section</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../simplification/">Simplification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 16 February 2025 16:02">Sunday 16 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
