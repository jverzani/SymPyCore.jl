var documenterSearchIndex = {"docs":
[{"location":"Tutorial/calculus/#Calculus","page":"Calculus","title":"Calculus","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"This section covers how to do basic calculus tasks such as derivatives, integrals, limits, and series expansions in SymPy.  If you are not familiar with the math of any part of this section, you may safely skip it.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"@syms x y z","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> from sympy import *\n    >>> x, y, z = symbols('x y z')\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Derivatives","page":"Calculus","title":"Derivatives","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To take derivatives, use the diff function.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"diff(cos(x), x)\ndiff(exp(x^2), x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> diff(cos(x), x)\n    -sin(x)\n    >>> diff(exp(x**2), x)\n         ⎛ 2⎞\n         ⎝x ⎠\n    2⋅x⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"diff can take multiple derivatives at once.  To take multiple derivatives, pass the variable as many times as you wish to differentiate, or pass a number after the variable.  For example, both of the following find the third derivative of x^4.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"diff(x^4, x, x, x)\ndiff(x^4, x, 3)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> diff(x**4, x, x, x)\n    24⋅x\n    >>> diff(x**4, x, 3)\n    24⋅x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"You can also take derivatives with respect to many variables at once.  Just pass each derivative in order, using the same syntax as for single variable derivatives.  For example, each of the following will compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"fracpartial^7partial xpartial y^2partial z^4 e^x y z","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr = exp(x*y*z)\ndiff(expr, x, y, y, z, z, z, z)\ndiff(expr, x, y, 2, z, 4)\ndiff(expr, x, y, y, z, 4)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = exp(x*y*z)\n    >>> diff(expr, x, y, y, z, z, z, z)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ\n    >>> diff(expr, x, y, 2, z, 4)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ\n    >>> diff(expr, x, y, y, z, 4)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"diff can also be called as a method.  The two ways of calling diff are exactly the same, and are provided only for convenience.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr.diff(x, y, y, z, 4)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr.diff(x, y, y, z, 4)\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To create an unevaluated derivative, use the Derivative class.  It has the same syntax as diff.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nDerivative must be qualified by sympy, as it is not exposed by SymPyCore","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"deriv = sympy.Derivative(expr, x, y, y, z, 4)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> deriv = Derivative(expr, x, y, y, z, 4)\n    >>> deriv\n         7\n        ∂     ⎛ x⋅y⋅z⎞\n    ──────────⎝ℯ     ⎠\n      4   2\n    ∂z  ∂y  ∂x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To evaluate an unevaluated derivative, use the doit method.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"deriv.doit()","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> deriv.doit()\n     3  2 ⎛ 3  3  3       2  2  2                ⎞  x⋅y⋅z\n    x ⋅y ⋅⎝x ⋅y ⋅z  + 14⋅x ⋅y ⋅z  + 52⋅x⋅y⋅z + 48⎠⋅ℯ","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"These unevaluated objects are useful for delaying the evaluation of the derivative, or for printing purposes.  They are also used when SymPy does not know how to compute the derivative of an expression (for example, if it contains an undefined function, which are described in the Solving Differential Equations section).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Derivatives of unspecified order can be created using tuple (x, n) where n is the order of the derivative with respect to x.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"@syms m, n, a, b\nexpr = (a*x + b)^m\nexpr.diff((x,n))","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"   >>> m, n, a, b = symbols('m n a b')\n    >>> expr = (a*x + b)**m\n    >>> expr.diff((x, n))\n      n\n     ∂ ⎛         m⎞\n    ───⎝(a⋅x + b) ⎠\n      n\n    ∂x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Integrals","page":"Calculus","title":"Integrals","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To compute an integral, use the integrate function.  There are two kinds of integrals, definite and indefinite.  To compute an indefinite integral, that is, an antiderivative, or primitive, just pass the variable after the expression.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"integrate(cos(x), x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integrate(cos(x), x)\n    sin(x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Note that SymPy does not include the constant of integration.  If you want it, you can add one yourself, or rephrase your problem as a differential equation and use dsolve to solve it, which does add the constant (see tutorial-dsolve).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"note: Quick Tip\ninfty in SymPy is oo (that's the lowercase letter \"oh\" twice).  This is because oo looks like infty, and is easy to type.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To compute a definite integral, pass the argument (integration_variable, lower_limit, upper_limit).  For example, to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"int_0^infty e^-xdx","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"we would do","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"integrate(exp(-x), (x, 0, oo))","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integrate(exp(-x), (x, 0, oo))\n    1","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"As with indefinite integrals, you can pass multiple limit tuples to perform a multiple integral.  For example, to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"int_-infty^inftyint_-infty^infty e^- x^2 - y^2 dx dy","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"do","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"integrate(exp(-x^2 - y^2), (x, -oo, oo), (y, -oo, oo))","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integrate(exp(-x**2 - y**2), (x, -oo, oo), (y, -oo, oo))\n    π","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If integrate is unable to compute an integral, it returns an unevaluated Integral object.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr = integrate(x^x, x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = integrate(x**x, x)\n    >>> print(expr)\n    Integral(x**x, x)\n    >>> expr\n    ⌠\n    ⎮  x\n    ⎮ x  dx\n    ⌡","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"As with Derivative, you can create an unevaluated integral using Integral.  To later evaluate this integral, call doit.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nIntegral must be qualified as it not exposed by SymPyCore","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr = sympy.Integral(log(x)^2, x)\nexpr.doit()","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = Integral(log(x)**2, x)\n    >>> expr\n    ⌠\n    ⎮    2\n    ⎮ log (x) dx\n    ⌡\n    >>> expr.doit()\n             2\n    x⋅log (x) - 2⋅x⋅log(x) + 2⋅x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"integrate uses powerful algorithms that are always improving to compute both definite and indefinite integrals, including heuristic pattern matching type algorithms, a partial implementation of the Risch algorithm, and an algorithm using Meijer G-functions that is useful for computing integrals in terms of special functions, especially definite integrals.  Here is a sampling of some of the power of integrate.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"integ = sympy.Integral((x^4 + x^2*exp(x) - x^2 - 2*x*exp(x) - 2*x - exp(x))*exp(x)/((x - 1)^2*(x + 1)^2*(exp(x) + 1)), x)\ninteg.doit()\ninteg = sympy.Integral(sin(x^2), x)\ninteg.doit()\ninteg = sympy.Integral(x^y*exp(-x), (x, 0, oo))\ninteg.doit()","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> integ = Integral((x**4 + x**2*exp(x) - x**2 - 2*x*exp(x) - 2*x -\n    ...     exp(x))*exp(x)/((x - 1)**2*(x + 1)**2*(exp(x) + 1)), x)\n    >>> integ\n    ⌠\n    ⎮ ⎛ 4    2  x    2        x          x⎞  x\n    ⎮ ⎝x  + x ⋅ℯ  - x  - 2⋅x⋅ℯ  - 2⋅x - ℯ ⎠⋅ℯ\n    ⎮ ──────────────────────────────────────── dx\n    ⎮               2        2 ⎛ x    ⎞\n    ⎮        (x - 1) ⋅(x + 1) ⋅⎝ℯ  + 1⎠\n    ⌡\n    >>> integ.doit()\n                     x\n       ⎛ x    ⎞     ℯ\n    log⎝ℯ  + 1⎠ + ──────\n                   2\n                  x  - 1\n\n    >>> integ = Integral(sin(x**2), x)\n    >>> integ\n    ⌠\n    ⎮    ⎛ 2⎞\n    ⎮ sin⎝x ⎠ dx\n    ⌡\n    >>> integ.doit()\n             ⎛√2⋅x⎞\n    3⋅√2⋅√π⋅S⎜────⎟⋅Γ(3/4)\n             ⎝ √π ⎠\n    ──────────────────────\n           8⋅Γ(7/4)\n\n    >>> integ = Integral(x**y*exp(-x), (x, 0, oo))\n    >>> integ\n    ∞\n    ⌠\n    ⎮  y  -x\n    ⎮ x ⋅ℯ   dx\n    ⌡\n    0\n    >>> integ.doit()\n    ⎧ Γ(y + 1)    for re(y) > -1\n    ⎪\n    ⎪∞\n    ⎪⌠\n    ⎨⎮  y  -x\n    ⎪⎮ x ⋅ℯ   dx    otherwise\n    ⎪⌡\n    ⎪0\n    ⎩","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"This last example returned a Piecewise expression because the integral does not converge unless Re(y)  1","category":"page"},{"location":"Tutorial/calculus/#Limits","page":"Calculus","title":"Limits","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"SymPy can compute symbolic limits with the limit function.  The syntax to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"lim_xto x_0 f(x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"is limit(f(x), x, x0).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nWe use Pairs notation x => x0 to associate the variable and the limiting value","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"limit(sin(x)/x, x=>0)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> limit(sin(x)/x, x, 0)\n    1","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"limit should be used instead of subs whenever the point of evaluation is a singularity.  Even though SymPy has objects to represent infty, using them for evaluation is not reliable because they do not keep track of things like rate of growth.  Also, things like infty - infty and fracinftyinfty return mathrmnan (not-a-number).  For example","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr = x^2 / exp(x)\nexpr(x => oo)\nlimit(expr, x => oo)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = x**2/exp(x)\n    >>> expr.subs(x, oo)\n    nan\n    >>> limit(expr, x, oo)\n    0","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"Like Derivative and Integral, limit has an unevaluated counterpart, Limit.  To evaluate it, use doit.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nLimit must be qualified, as it is not exposed by SymPyCore. Also, the pair notation is not available.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr = sympy.Limit((cos(x) - 1)/x, x, 0) # no => here\nexpr.doit()","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = Limit((cos(x) - 1)/x, x, 0)\n    >>> expr\n         ⎛cos(x) - 1⎞\n     lim ⎜──────────⎟\n    x─→0⁺⎝    x     ⎠\n    >>> expr.doit()\n    0","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"To evaluate a limit at one side only, pass '+' or '-' as a fourth argument to limit.  For example, to compute","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"lim_xto 0^+frac1x","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"do","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nThe limit function in SymPy uses a keyword argument for dir.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"limit(1/x, x=>0, dir=\"+\")","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> limit(1/x, x, 0, '+')\n    ∞","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"As opposed to","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"limit(1/x, x =>0, dir=\"-\")","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> limit(1/x, x, 0, '-')\n    -∞","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Series-Expansion","page":"Calculus","title":"Series Expansion","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"SymPy can compute asymptotic series expansions of functions around a point. To compute the expansion of f(x) around the point x = x_0 terms of order x^n, use f(x).series(x, x0, n).  x0 and n can be omitted, in which case the defaults x0=0 and n=6 will be used.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nWe may use series as a generic method, not an object method","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"expr = exp(sin(x))\nseries(expr, x, 0, 4)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr = exp(sin(x))\n    >>> expr.series(x, 0, 4)\n             2\n            x     ⎛ 4⎞\n    1 + x + ── + O⎝x ⎠\n            2","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"The Oleft(x^4right) term at the end represents the Landau order term at x=0 (not to be confused with big O notation used in computer science, which generally represents the Landau order term at x where x rightarrow infty).  It means that all x terms with power greater than or equal to x^4 are omitted.  Order terms can be created and manipulated outside of series.  They automatically absorb higher order terms.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nO needs qualifying","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":" x + x^3 + x^6 + sympy.O(x^4)\n x * sympy.O(1)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> x + x**3 + x**6 + O(x**4)\n         3    ⎛ 4⎞\n    x + x  + O⎝x ⎠\n    >>> x*O(1)\n    O(x)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If you do not want the order term, use the removeO method.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"series(expr, x, 0, 4).removeO()","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> expr.series(x, 0, 4).removeO()\n     2\n    x\n    ── + x + 1\n    2","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"The O notation supports arbitrary limit points (other than 0):","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"exp(x - 6).series(x, x0=6)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> exp(x - 6).series(x, x0=6)\n                2          3          4          5\n         (x - 6)    (x - 6)    (x - 6)    (x - 6)         ⎛       6       ⎞\n    -5 + ──────── + ──────── + ──────── + ──────── + x + O⎝(x - 6) ; x → 6⎠\n            2          6          24        120","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/#Finite-differences","page":"Calculus","title":"Finite differences","text":"","category":"section"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"So far we have looked at expressions with analytic derivatives and primitive functions respectively. But what if we want to have an expression to estimate a derivative of a curve for which we lack a closed form representation, or for which we don't know the functional values for yet. One approach would be to use a finite difference approach.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"The simplest way the differentiate using finite differences is to use the differentiate_finite function:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nThe differentiate_finite function needs qualifying.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"@syms f(), g()\nsympy.differentiate_finite(f(x)*g(x))","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> f, g = symbols('f g', cls=Function)\n    >>> differentiate_finite(f(x)*g(x))\n    -f(x - 1/2)⋅g(x - 1/2) + f(x + 1/2)⋅g(x + 1/2)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If you already have a Derivative instance, you can use the as_finite_difference method to generate approximations of the derivative to arbitrary order:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"@syms f()\ndfdx = f(x).diff(x)\ndfdx.as_finite_difference()","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> f = Function('f')\n    >>> dfdx = f(x).diff(x)\n    >>> dfdx.as_finite_difference()\n    -f(x - 1/2) + f(x + 1/2)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"here the first order derivative was approximated around x using a minimum number of points (2 for 1st order derivative) evaluated equidistantly using a step-size of 1. We can use arbitrary steps (possibly containing symbolic expressions):","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"@syms f()\nd2fdx2 = f(x).diff(x, 2)\n@syms h\nd2fdx2.as_finite_difference([-3*h,-h,2*h])","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> f = Function('f')\n    >>> d2fdx2 = f(x).diff(x, 2)\n    >>> h = Symbol('h')\n    >>> d2fdx2.as_finite_difference([-3*h,-h,2*h])\n    f(-3⋅h)   f(-h)   2⋅f(2⋅h)\n    ─────── - ───── + ────────\n         2        2        2\n      5⋅h      3⋅h     15⋅h","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If you are just interested in evaluating the weights, you can do so manually:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nThis function needs qualifying. The indexing is different from Python for the array arr, as there is no -1, rather we use Julia's end.","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"arr = sympy.finite_diff_weights(2, [-3, -1, 2], 0)\narr[end][end]","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> finite_diff_weights(2, [-3, -1, 2], 0)[-1][-1]\n    [1/5, -1/3, 2/15]","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"note that we only need the last element in the last sublist returned from finite_diff_weights. The reason for this is that the function also generates weights for lower derivatives and using fewer points (see the documentation of finite_diff_weights for more details).","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"If using finite_diff_weights directly looks complicated, and the as_finite_difference method of Derivative instances is not flexible enough, you can use apply_finite_diff which takes order, x_list, y_list and x0 as parameters:","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"tip: Julia differences\nThe apply_finite_diff function needs qualifying. The y_list construction below would be easier with numbered variables, as with y_list = @syms y[1:3].","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"x_list = [-3, 1, 2]\n@syms a b c\ny_list = [a, b, c]\nsympy.apply_finite_diff(1, x_list, y_list, 0)","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"    >>> x_list = [-3, 1, 2]\n    >>> ylist = symbols(\"a b c\")\n    >>> apply_finite_diff(1, x_list, y_list, 0)\n      3⋅a   b   2⋅c\n    - ─── - ─ + ───\n       20   4    5","category":"page"},{"location":"Tutorial/calculus/","page":"Calculus","title":"Calculus","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/#Advanced-Expression-Manipulation","page":"Manipulation","title":"Advanced Expression Manipulation","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"In this section, we discuss some ways that we can perform advanced manipulation of expressions.","category":"page"},{"location":"Tutorial/manipulation/#Understanding-Expression-Trees","page":"Manipulation","title":"Understanding Expression Trees","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Before we can do this, we need to understand how expressions are represented in SymPy.  A mathematical expression is represented as a tree.  Let us take the expression x^2 + xy, i.e., x**2 + x*y.  We can see what this expression looks like internally by using srepr","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nThe srepr function needs qualification","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"@syms x, y, z\nexpr = x^2 + x*y\nsympy.srepr(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> from sympy import *\n    >>> x, y, z = symbols('x y z')\n\n    >>> expr = x**2 + x*y\n    >>> srepr(expr)\n    \"Add(Pow(Symbol('x'), Integer(2)), Mul(Symbol('x'), Symbol('y')))\"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"The easiest way to tear this apart is to look at a diagram of the expression tree:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nThe diagram is not presented here","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":".. This comes from dotprint(x**2 + x*y, labelfunc=srepr)\n\n.. graphviz::\n\n    digraph{\n\n    # Graph style\n    \"ordering\"=\"out\"\n    \"rankdir\"=\"TD\"\n\n    #########\n    # Nodes #\n    #########\n\n    \"Add(Pow(Symbol('x'), Integer(2)), Mul(Symbol('x'), Symbol('y')))_()\" [\"color\"=\"black\", \"label\"=\"Add\", \"shape\"=\"ellipse\"];\n    \"Pow(Symbol('x'), Integer(2))_(0,)\" [\"color\"=\"black\", \"label\"=\"Pow\", \"shape\"=\"ellipse\"];\n    \"Symbol('x')_(0, 0)\" [\"color\"=\"black\", \"label\"=\"Symbol('x')\", \"shape\"=\"ellipse\"];\n    \"Integer(2)_(0, 1)\" [\"color\"=\"black\", \"label\"=\"Integer(2)\", \"shape\"=\"ellipse\"];\n    \"Mul(Symbol('x'), Symbol('y'))_(1,)\" [\"color\"=\"black\", \"label\"=\"Mul\", \"shape\"=\"ellipse\"];\n    \"Symbol('x')_(1, 0)\" [\"color\"=\"black\", \"label\"=\"Symbol('x')\", \"shape\"=\"ellipse\"];\n    \"Symbol('y')_(1, 1)\" [\"color\"=\"black\", \"label\"=\"Symbol('y')\", \"shape\"=\"ellipse\"];\n\n    #########\n    # Edges #\n    #########\n\n    \"Add(Pow(Symbol('x'), Integer(2)), Mul(Symbol('x'), Symbol('y')))_()\" -> \"Pow(Symbol('x'), Integer(2))_(0,)\";\n    \"Add(Pow(Symbol('x'), Integer(2)), Mul(Symbol('x'), Symbol('y')))_()\" -> \"Mul(Symbol('x'), Symbol('y'))_(1,)\";\n    \"Pow(Symbol('x'), Integer(2))_(0,)\" -> \"Symbol('x')_(0, 0)\";\n    \"Pow(Symbol('x'), Integer(2))_(0,)\" -> \"Integer(2)_(0, 1)\";\n    \"Mul(Symbol('x'), Symbol('y'))_(1,)\" -> \"Symbol('x')_(1, 0)\";\n    \"Mul(Symbol('x'), Symbol('y'))_(1,)\" -> \"Symbol('y')_(1, 1)\";\n    }","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"note: Note\nThe above diagram was made using Graphviz and the dotprint function.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"First, let's look at the leaves of this tree.  Symbols are instances of the class Symbol.  While we have been doing","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"@syms x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> x = symbols('x')","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"we could have also done","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"x = symbols(\"x\")","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> x = Symbol('x')","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Either way, we get a Symbol with the name \"x\".  For the number in the expression, 2, we got Integer(2).  Integer is the SymPy class for integers.  It is similar to the Python built-in type int, except that Integer plays nicely with other SymPy types.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"When we write x**2, this creates a Pow object.  Pow is short for \"power\".","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.srepr(x^2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> srepr(x**2)\n    \"Pow(Symbol('x'), Integer(2))\"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"We could have created the same object by calling Pow(x, 2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.Pow(x, 2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> Pow(x, 2)\n    x**2","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Note that in the srepr output, we see Integer(2), the SymPy version of integers, even though technically, we input 2, a Python int.  In general, whenever you combine a SymPy object with a non-SymPy object via some function or operation, the non-SymPy object will be converted into a SymPy object.  The function that does this is sympify [#sympify-fn]_.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nUsing Sym(2) is more idiomatic. It uses sympify, though a more perfomant means would be to create a Python object (which differs between PyCall (PyObect(2)) and PythonCall (Py(2))) and call Sym on that.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympify(2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> type(2)\n    <... 'int'>\n    >>> type(sympify(2))\n    <class 'sympy.core.numbers.Integer'>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"We have seen that x**2 is represented as Pow(x, 2).  What about x*y?  As we might expect, this is the multiplication of x and y. The SymPy class for multiplication is Mul.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.srepr(x * y)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> srepr(x*y)\n    \"Mul(Symbol('x'), Symbol('y'))\"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Thus, we could have created the same object by writing Mul(x, y).","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.Mul(x, y)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> Mul(x, y)\n    x*y","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Now we get to our final expression, x**2 + x*y.  This is the addition of our last two objects, Pow(x, 2), and Mul(x, y).  The SymPy class for addition is Add, so, as you might expect, to create this object, we use Add(Pow(x, 2), Mul(x, y)).","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.Add(sympy.Pow(x, 2), sympy.Mul(x, y))","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> Add(Pow(x, 2), Mul(x, y))\n    x**2 + x*y","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"SymPy expression trees can have many branches, and can be quite deep or quite broad.  Here is a more complicated example","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = sin(x*2)/2 - x^2 + 1/y\nsympy.srepr(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = sin(x*y)/2 - x**2 + 1/y\n    >>> srepr(expr)\n    \"Add(Mul(Integer(-1), Pow(Symbol('x'), Integer(2))), Mul(Rational(1, 2),\n    sin(Mul(Symbol('x'), Symbol('y')))), Pow(Symbol('y'), Integer(-1)))\"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Here is a diagram","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nThis is not present in this translation","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":".. dotprint(sin(x*y)/2 - x**2 + 1/y, labelfunc=srepr)\n\n.. graphviz::\n\n    digraph{\n\n    # Graph style\n    \"rankdir\"=\"TD\"\n\n    #########\n    # Nodes #\n    #########\n\n    \"Half()_(0, 0)\" [\"color\"=\"black\", \"label\"=\"Rational(1, 2)\", \"shape\"=\"ellipse\"];\n    \"Symbol(y)_(2, 0)\" [\"color\"=\"black\", \"label\"=\"Symbol('y')\", \"shape\"=\"ellipse\"];\n    \"Symbol(x)_(1, 1, 0)\" [\"color\"=\"black\", \"label\"=\"Symbol('x')\", \"shape\"=\"ellipse\"];\n    \"Integer(2)_(1, 1, 1)\" [\"color\"=\"black\", \"label\"=\"Integer(2)\", \"shape\"=\"ellipse\"];\n    \"NegativeOne()_(2, 1)\" [\"color\"=\"black\", \"label\"=\"Integer(-1)\", \"shape\"=\"ellipse\"];\n    \"NegativeOne()_(1, 0)\" [\"color\"=\"black\", \"label\"=\"Integer(-1)\", \"shape\"=\"ellipse\"];\n    \"Symbol(y)_(0, 1, 0, 1)\" [\"color\"=\"black\", \"label\"=\"Symbol('y')\", \"shape\"=\"ellipse\"];\n    \"Symbol(x)_(0, 1, 0, 0)\" [\"color\"=\"black\", \"label\"=\"Symbol('x')\", \"shape\"=\"ellipse\"];\n    \"Pow(Symbol(x), Integer(2))_(1, 1)\" [\"color\"=\"black\", \"label\"=\"Pow\", \"shape\"=\"ellipse\"];\n    \"Pow(Symbol(y), NegativeOne())_(2,)\" [\"color\"=\"black\", \"label\"=\"Pow\", \"shape\"=\"ellipse\"];\n    \"Mul(Symbol(x), Symbol(y))_(0, 1, 0)\" [\"color\"=\"black\", \"label\"=\"Mul\", \"shape\"=\"ellipse\"];\n    \"sin(Mul(Symbol(x), Symbol(y)))_(0, 1)\" [\"color\"=\"black\", \"label\"=\"sin\", \"shape\"=\"ellipse\"];\n    \"Mul(Half(), sin(Mul(Symbol(x), Symbol(y))))_(0,)\" [\"color\"=\"black\", \"label\"=\"Mul\", \"shape\"=\"ellipse\"];\n    \"Mul(NegativeOne(), Pow(Symbol(x), Integer(2)))_(1,)\" [\"color\"=\"black\", \"label\"=\"Mul\", \"shape\"=\"ellipse\"];\n    \"Add(Mul(Half(), sin(Mul(Symbol(x), Symbol(y)))), Mul(NegativeOne(), Pow(Symbol(x), Integer(2))), Pow(Symbol(y), NegativeOne()))_()\" [\"color\"=\"black\", \"label\"=\"Add\", \"shape\"=\"ellipse\"];\n\n    #########\n    # Edges #\n    #########\n\n    \"Pow(Symbol(y), NegativeOne())_(2,)\" -> \"Symbol(y)_(2, 0)\";\n    \"Pow(Symbol(x), Integer(2))_(1, 1)\" -> \"Symbol(x)_(1, 1, 0)\";\n    \"Pow(Symbol(x), Integer(2))_(1, 1)\" -> \"Integer(2)_(1, 1, 1)\";\n    \"Pow(Symbol(y), NegativeOne())_(2,)\" -> \"NegativeOne()_(2, 1)\";\n    \"Mul(Symbol(x), Symbol(y))_(0, 1, 0)\" -> \"Symbol(x)_(0, 1, 0, 0)\";\n    \"Mul(Symbol(x), Symbol(y))_(0, 1, 0)\" -> \"Symbol(y)_(0, 1, 0, 1)\";\n    \"Mul(Half(), sin(Mul(Symbol(x), Symbol(y))))_(0,)\" -> \"Half()_(0, 0)\";\n    \"Mul(NegativeOne(), Pow(Symbol(x), Integer(2)))_(1,)\" -> \"NegativeOne()_(1, 0)\";\n    \"sin(Mul(Symbol(x), Symbol(y)))_(0, 1)\" -> \"Mul(Symbol(x), Symbol(y))_(0, 1, 0)\";\n    \"Mul(NegativeOne(), Pow(Symbol(x), Integer(2)))_(1,)\" -> \"Pow(Symbol(x), Integer(2))_(1, 1)\";\n    \"Mul(Half(), sin(Mul(Symbol(x), Symbol(y))))_(0,)\" -> \"sin(Mul(Symbol(x), Symbol(y)))_(0, 1)\";\n    \"Add(Mul(Half(), sin(Mul(Symbol(x), Symbol(y)))), Mul(NegativeOne(), Pow(Symbol(x), Integer(2))), Pow(Symbol(y), NegativeOne()))_()\" -> \"Pow(Symbol(y), NegativeOne())_(2,)\";\n    \"Add(Mul(Half(), sin(Mul(Symbol(x), Symbol(y)))), Mul(NegativeOne(), Pow(Symbol(x), Integer(2))), Pow(Symbol(y), NegativeOne()))_()\" -> \"Mul(Half(), sin(Mul(Symbol(x), Symbol(y))))_(0,)\";\n    \"Add(Mul(Half(), sin(Mul(Symbol(x), Symbol(y)))), Mul(NegativeOne(), Pow(Symbol(x), Integer(2))), Pow(Symbol(y), NegativeOne()))_()\" -> \"Mul(NegativeOne(), Pow(Symbol(x), Integer(2)))_(1,)\";\n    }","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"This expression reveals some interesting things about SymPy expression trees. Let's go through them one by one.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Let's first look at the term x**2.  As we expected, we see Pow(x, 2). One level up, we see we have Mul(-1, Pow(x, 2)).  There is no subtraction class in SymPy.  x - y is represented as x + -y, or, more completely, x + -1*y, i.e., Add(x, Mul(-1, y)).","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.srepr(x - y)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> srepr(x - y)\n    \"Add(Symbol('x'), Mul(Integer(-1), Symbol('y')))\"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":".. dotprint(x - y, labelfunc=srepr)\n\n.. graphviz::\n\n    digraph{\n\n    # Graph style\n    \"rankdir\"=\"TD\"\n\n    #########\n    # Nodes #\n    #########\n\n    \"Symbol(x)_(1,)\" [\"color\"=\"black\", \"label\"=\"Symbol('x')\", \"shape\"=\"ellipse\"];\n    \"Symbol(y)_(0, 1)\" [\"color\"=\"black\", \"label\"=\"Symbol('y')\", \"shape\"=\"ellipse\"];\n    \"NegativeOne()_(0, 0)\" [\"color\"=\"black\", \"label\"=\"Integer(-1)\", \"shape\"=\"ellipse\"];\n    \"Mul(NegativeOne(), Symbol(y))_(0,)\" [\"color\"=\"black\", \"label\"=\"Mul\", \"shape\"=\"ellipse\"];\n    \"Add(Mul(NegativeOne(), Symbol(y)), Symbol(x))_()\" [\"color\"=\"black\", \"label\"=\"Add\", \"shape\"=\"ellipse\"];\n\n    #########\n    # Edges #\n    #########\n\n    \"Mul(NegativeOne(), Symbol(y))_(0,)\" -> \"Symbol(y)_(0, 1)\";\n    \"Mul(NegativeOne(), Symbol(y))_(0,)\" -> \"NegativeOne()_(0, 0)\";\n    \"Add(Mul(NegativeOne(), Symbol(y)), Symbol(x))_()\" -> \"Symbol(x)_(1,)\";\n    \"Add(Mul(NegativeOne(), Symbol(y)), Symbol(x))_()\" -> \"Mul(NegativeOne(), Symbol(y))_(0,)\";\n    }","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Next, look at 1/y.  We might expect to see something like Div(1, y), but similar to subtraction, there is no class in SymPy for division.  Rather, division is represented by a power of -1.  Hence, we have Pow(y, -1). What if we had divided something other than 1 by y, like x/y?  Let's see.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = x / y\nsympy.srepr(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = x/y\n    >>> srepr(expr)\n    \"Mul(Symbol('x'), Pow(Symbol('y'), Integer(-1)))\"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":".. dotprint(x/y, labelfunc=srepr)\n\n.. graphviz::\n\n    digraph{\n\n    # Graph style\n    \"rankdir\"=\"TD\"\n\n    #########\n    # Nodes #\n    #########\n\n    \"Symbol(x)_(0,)\" [\"color\"=\"black\", \"label\"=\"Symbol('x')\", \"shape\"=\"ellipse\"];\n    \"Symbol(y)_(1, 0)\" [\"color\"=\"black\", \"label\"=\"Symbol('y')\", \"shape\"=\"ellipse\"];\n    \"NegativeOne()_(1, 1)\" [\"color\"=\"black\", \"label\"=\"Integer(-1)\", \"shape\"=\"ellipse\"];\n    \"Pow(Symbol(y), NegativeOne())_(1,)\" [\"color\"=\"black\", \"label\"=\"Pow\", \"shape\"=\"ellipse\"];\n    \"Mul(Symbol(x), Pow(Symbol(y), NegativeOne()))_()\" [\"color\"=\"black\", \"label\"=\"Mul\", \"shape\"=\"ellipse\"];\n\n    #########\n    # Edges #\n    #########\n\n    \"Pow(Symbol(y), NegativeOne())_(1,)\" -> \"Symbol(y)_(1, 0)\";\n    \"Pow(Symbol(y), NegativeOne())_(1,)\" -> \"NegativeOne()_(1, 1)\";\n    \"Mul(Symbol(x), Pow(Symbol(y), NegativeOne()))_()\" -> \"Symbol(x)_(0,)\";\n    \"Mul(Symbol(x), Pow(Symbol(y), NegativeOne()))_()\" -> \"Pow(Symbol(y), NegativeOne())_(1,)\";\n    }","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"We see that x/y is represented as x*y**-1, i.e., Mul(x, Pow(y, -1)).","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Finally, let's look at the sin(x*y)/2 term.  Following the pattern of the previous example, we might expect to see Mul(sin(x*y), Pow(Integer(2), -1)).  But instead, we have Mul(Rational(1, 2), sin(x*y)).  Rational numbers are always combined into a single term in a multiplication, so that when we divide by 2, it is represented as multiplying by 1/2.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Finally, one last note.  You may have noticed that the order we entered our expression and the order that it came out from srepr or in the graph were different.  You may have also noticed this phenomenon earlier in the tutorial.  For example","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"1 + x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"     >>> 1 + x\n     x + 1","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"This because in SymPy, the arguments of the commutative operations Add and Mul are stored in an arbitrary (but consistent!) order, which is independent of the order inputted (if you're worried about noncommutative multiplication, don't be.  In SymPy, you can create noncommutative Symbols using Symbol('A', commutative=False), and the order of multiplication for noncommutative Symbols is kept the same as the input).  Furthermore, as we shall see in the next section, the printing order and the order in which things are stored internally need not be the same either.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"note: Quick Tip\nThe way an expression is represented internally and the way it is printed are often not the same.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"In general, an important thing to keep in mind when working with SymPy expression trees is this:  the internal representation of an expression and the way it is printed need not be the same.  The same is true for the input form.   If some expression manipulation algorithm is not working in the way you expected it to, chances are, the internal representation of the object is different from what you thought it was.","category":"page"},{"location":"Tutorial/manipulation/#Recursing-through-an-Expression-Tree","page":"Manipulation","title":"Recursing through an Expression Tree","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Now that you know how expression trees work in SymPy, let's look at how to dig our way through an expression tree.  Every object in SymPy has two very important attributes, func, and args.","category":"page"},{"location":"Tutorial/manipulation/#func","page":"Manipulation","title":"func","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"func is the head of the object. For example, (x*y).func is Mul. Usually it is the same as the class of the object (though there are exceptions to this rule).","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Two notes about func.  First, the class of an object need not be the same as the one used to create it.  For example","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nThe Introspection.func methods (and others) allows a more Julian calling style","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = sympy.Add(x,x)\nIntrospection.func(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = Add(x, x)\n    >>> expr.func\n    <class 'sympy.core.mul.Mul'>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"We created Add(x, x), so we might expect expr.func to be Add, but instead we got Mul.  Why is that?  Let's take a closer look at expr.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr\n    2*x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Add(x, x), i.e., x + x, was automatically converted into Mul(2, x), i.e., 2*x, which is a Mul.   SymPy classes make heavy use of the __new__ class constructor, which, unlike __init__, allows a different class to be returned from the constructor.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Second, some classes are special-cased, usually for efficiency reasons.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Introspection.func(Sym(2))\nIntrospection.func(Sym(0))\nIntrospection.func(Sym(-1))","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> Integer(2).func\n    <class 'sympy.core.numbers.Integer'>\n    >>> Integer(0).func\n    <class 'sympy.core.numbers.Zero'>\n    >>> Integer(-1).func\n    <class 'sympy.core.numbers.NegativeOne'>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"For the most part, these issues will not bother us.  The special classes Zero, One, NegativeOne, and so on are subclasses of Integer, so as long as you use isinstance, it will not be an issue.","category":"page"},{"location":"Tutorial/manipulation/#args","page":"Manipulation","title":"args","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"args are the top-level arguments of the object.  (x*y).args would be (x, y).  Let's look at some examples","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nAgain, Introspection allows a more Julian means to call this object method. Unlike func, args returns Sym values. In the example below, they are converted to underling Python values.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = 3 * y^2* x\nIntrospection.func(expr)\nIntrospection.args(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = 3*y**2*x\n    >>> expr.func\n    <class 'sympy.core.mul.Mul'>\n    >>> expr.args\n    (3, x, y**2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"From this, we can see that expr == Mul(3, y**2, x).  In fact, we can see that we can completely reconstruct expr from its func and its args.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nActually, what is created is the Python value, which if swrapped in Sym becoes the original value. Note the use of \\downarrow[tab] to pass the Python values to the output of func.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"u = Introspection.func(expr)(↓(Introspection.args(expr))...)\n↓(expr) == u","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr.func(*expr.args)\n    3*x*y**2\n    >>> expr == expr.func(*expr.args)\n    True","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Note that although we entered 3*y**2*x, the args are (3, x, y**2). In a Mul, the Rational coefficient will come first in the args, but other than that, the order of everything else follows no special pattern.  To be sure, though, there is an order.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = y^2 * 3*x\nIntrospection.args(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = y**2*3*x\n    >>> expr.args\n    (3, x, y**2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Mul's args are sorted, so that the same Mul will have the same args.  But the sorting is based on some criteria designed to make the sorting unique and efficient that has no mathematical significance.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"The srepr form of our expr is Mul(3, x, Pow(y, 2)).  What if we want to get at the args of Pow(y, 2).  Notice that the y**2 is in the third slot of expr.args, i.e., expr.args[2].","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nJulia is 1 based, not 0 based like Python, so the index is 3","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Introspection.args(expr)[3]","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr.args[2]\n    y**2","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"So to get the args of this, we call expr.args[2].args.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Introspection.args(Introspection.args(expr)[3])","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr.args[2].args\n    (y, 2)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Now what if we try to go deeper.  What are the args of y.  Or 2. Let's see.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Introspection.args(y)\nIntrospection.args(Sym(2))","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> y.args\n    ()\n    >>> Integer(2).args\n    ()","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"They both have empty args.  In SymPy, empty args signal that we have hit a leaf of the expression tree.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"So there are two possibilities for a SymPy expression. Either it has empty args, in which case it is a leaf node in any expression tree, or it has args, in which case, it is a branch node of any expression tree.  When it has args, it can be completely rebuilt from its func and its args. This is expressed in the key invariant.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"note: Key Invariant\nEvery well-formed SymPy expression must either have empty args or satisfy expr == expr.func(*expr.args).","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"(Recall that in Python if a is a tuple, then f(*a) means to call f with arguments from the elements of a, e.g., f(*(1, 2, 3)) is the same as f(1, 2, 3).)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"This key invariant allows us to write simple algorithms that walk expression trees, change them, and rebuild them into new expressions.","category":"page"},{"location":"Tutorial/manipulation/#Walking-the-Tree","page":"Manipulation","title":"Walking the Tree","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"With this knowledge, let's look at how we can recurse through an expression tree.  The nested nature of args is a perfect fit for recursive functions. The base case will be empty args.  Let's write a simple function that goes through an expression and prints all the args at each level.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"function pre(expr)\n   println(expr)\n   for arg in Introspection.args(expr)\n       pre(arg)\n   end\nend","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> def pre(expr):\n    ...     print(expr)\n    ...     for arg in expr.args:\n    ...         pre(arg)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"See how nice it is that () signals leaves in the expression tree.  We don't even have to write a base case for our recursion; it is handled automatically by the for loop.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Let's test our function.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = x*y + 1\npre(expr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = x*y + 1\n    >>> pre(expr)\n    x*y + 1\n    1\n    x*y\n    x\n    y","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Can you guess why we called our function pre?  We just wrote a pre-order traversal function for our expression tree.   See if you can write a post-order traversal function.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Such traversals are so common in SymPy that the generator functions preorder_traversal and postorder_traversal are provided to make such traversals easy.  We could have also written our algorithm as","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"collect(sympy.preorder_traversal(expr))","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> for arg in preorder_traversal(expr):\n    ...     print(arg)\n    x*y + 1\n    1\n    x*y\n    x\n    y","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/#Prevent-expression-evaluation","page":"Manipulation","title":"Prevent expression evaluation","text":"","category":"section"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"There are generally two ways to prevent the evaluation, either pass an evaluate=False parameter while constructing the expression, or create an evaluation stopper by wrapping the expression with UnevaluatedExpr.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"For example:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"x + x\nsympy.Add(x, x)\nsympy.Add(x, x, evaluate=false)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> from sympy import Add\n    >>> from sympy.abc import x, y, z\n    >>> x + x\n    2*x\n    >>> Add(x, x)\n    2*x\n    >>> Add(x, x, evaluate=False)\n    x + x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"If you don't remember the class corresponding to the expression you want to build (operator overloading usually assumes evaluate=True), just use sympify and pass a string:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympify(\"x + x\", evaluate = false)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> from sympy import sympify\n    >>> sympify(\"x + x\", evaluate=False)\n    x + x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Note that evaluate=False won't prevent future evaluation in later usages of the expression:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = sympy.Add(x, x, evaluate = false)\nexpr + x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr = Add(x, x, evaluate=False)\n    >>> expr\n    x + x\n    >>> expr + x\n    3*x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"That's why the class UnevaluatedExpr comes handy. UnevaluatedExpr is a method provided by SymPy which lets the user keep an expression unevaluated. By unevaluated it is meant that the value inside of it will not interact with the expressions outside of it to give simplified outputs. For example:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr = x + sympy.UnevaluatedExpr(x)\nx + expr","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> from sympy import UnevaluatedExpr\n    >>> expr = x + UnevaluatedExpr(x)\n    >>> expr\n    x + x\n    >>> x + expr\n    2*x + x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"The x remaining alone is the x wrapped by UnevaluatedExpr. To release it:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nthe doit object method finds many other uses.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":" (x + expr).doit()","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> (x + expr).doit()\n    3*x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Other examples:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"tip: Julia differences\nThe S module of Python, is not available as sympy.S. Rather, we export it through 𝑆","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.UnevaluatedExpr(𝑆.One * 5 /7) * sympy.UnevaluatedExpr(𝑆.One * 3 / 4)\nx * sympy.UnevaluatedExpr(1/x)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> from sympy import *\n    >>> from sympy.abc import x, y, z\n    >>> uexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\n    >>> uexpr\n    (5/7)*(3/4)\n    >>> x*UnevaluatedExpr(1/x)\n    x*1/x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"A point to be noted is that  UnevaluatedExpr cannot prevent the evaluation of an expression which is given as argument. For example:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"expr1 = sympy.UnevaluatedExpr(x + x)\nexpr2 = sympify(\"x + x\", evaluate=false)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> expr1 = UnevaluatedExpr(x + x)\n    >>> expr1\n    2*x\n    >>> expr2 = sympify('x + x', evaluate=False)\n    >>> expr2\n    x + x","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"Remember that expr2 will be evaluated if included into another expression. Combine both of the methods to prevent both inside and outside evaluations:","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"sympy.UnevaluatedExpr(sympify(\"x + x\", evaluate=false)) + y","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> UnevaluatedExpr(sympify(\"x + x\", evaluate=False)) + y\n    y + (x + x)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"UnevaluatedExpr is supported by SymPy printers and can be used to print the result in different output forms. For example","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"using Latexify\nuexpr = sympy.UnevaluatedExpr(𝑆.One * 5 /7) * sympy.UnevaluatedExpr(𝑆.One * 3 / 4)\nlatexify(uexpr)","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> from sympy import latex\n    >>> uexpr = UnevaluatedExpr(S.One*5/7)*UnevaluatedExpr(S.One*3/4)\n    >>> print(latex(uexpr))\n    \\frac{5}{7} \\cdot \\frac{3}{4}","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"In order to release the expression and get the evaluated LaTeX form, just use .doit():","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"latexify(uexpr.doit())","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"    >>> print(latex(uexpr.doit()))\n    \\frac{15}{28}","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"</details>","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"note: Footnotes\nWe have been using symbols instead of Symbol because itautomatically splits apart strings into multiple Symbols.","category":"page"},{"location":"Tutorial/manipulation/","page":"Manipulation","title":"Manipulation","text":"* symbols('x y z') returns a tuple of three Symbol s.  Symbol('x y z')     returns a single Symbol called x y z.     * Technically, it is an internal function called _sympify,  which differs from sympify \tin that it does not convert strings.  x +  '2' is not allowed.     * Classes like One and Zero are singletonized, meaning that only one object is ever created, \tno matter how many times the class is called.  This is done for space efficiency, \tas these classes are very  common.  For example, Zero might occur very often in a sparse matrix     represented densely.  As we have seen, NegativeOne occurs any time we     have -x or 1/x.  It is also done for speed efficiency because     singletonized objects can be compared by is.  The unique objects for     each singletonized class can be accessed from the S object.","category":"page"},{"location":"Tutorial/gotchas/#Gotchas","page":"Gotchas","title":"Gotchas","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To begin, we should make something about SymPy clear.  SymPy is nothing more than a Python library, like NumPy, Django, or even modules in the Python standard library sys or re.  What this means is that SymPy does not add anything to the Python language.  Limitations that are inherent in the Python language are also inherent in SymPy.  It also means that SymPy tries to use Python idioms whenever possible, making programming with SymPy easy for those already familiar with programming with Python.  As a simple example, SymPy uses Python syntax to build expressions.  Implicit multiplication (like 3x or 3 x) is not allowed in Python, and thus not allowed in SymPy. To multiply 3 and x, you must type 3*x with the *.","category":"page"},{"location":"Tutorial/gotchas/#Symbols","page":"Gotchas","title":"Symbols","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"One consequence of this fact is that SymPy can be used in any environment where Python is available.  We just import it, like we would any other library.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nSymPyCore is loaded as a backend by either using SymPy or using SymPyPythonCall.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> from sympy import *","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This imports all the functions and classes from SymPy into our interactive Python session.  Now, suppose we start to do a computation.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nOnly a select set of functions and classes are imported in julia, others can be accessed from the sympy module that is created when the package is loaded.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"x + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + 1\n    Traceback (most recent call last):\n    ...\n    NameError: name 'x' is not defined","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Oops! What happened here?  We tried to use the variable x, but it tells us that x is not defined.  In Python, variables have no meaning until they are defined.  SymPy is no different.  Unlike many symbolic manipulation systems you may have used, in SymPy, variables are not defined automatically. To define variables, we must use symbols.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThe symbols constructor, used in the Python version of this tutorial, is replaced here by @syms, though it can be used, as x=symbols(\"x\").","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"@syms x     # x = symbols(\"x\") is an alternative\nx + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = symbols('x')\n    >>> x + 1\n    x + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"symbols takes a string of variable names separated by spaces or commas, and creates Symbols out of them.  We can then assign these to variable names. Later, we will investigate some convenient ways we can work around this issue. For now, let us just define the most common variable names, x, y, and z, for use through the rest of this section","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThe @syms macro does not need assignment, it creates variables in local scope.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"@syms x, y, z","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x, y, z = symbols('x y z')","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"As a final note, we note that the name of a Symbol and the name of the variable it is assigned to need not have anything to do with one another.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThis kind of name mangling can be done using => with the @syms constructor.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"@syms a=>\"b\", b=>\"a\"\na # prints as \"b\"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> a, b = symbols('b a')\n    >>> a\n    b\n    >>> b\n    a","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Here we have done the very confusing thing of assigning a Symbol with the name a to the variable b, and a Symbol of the name b to the variable a.  Now the Python variable named a points to the SymPy Symbol named b, and vice versa.  How confusing.  We could have also done something like","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"@syms crazy => \"unrelated\"\ncrazy + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> crazy = symbols('unrelated')\n    >>> crazy + 1\n    unrelated + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This also shows that Symbols can have names longer than one character if we want.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Usually, the best practice is to assign Symbols to Python variables of the same name, although there are exceptions:  Symbol names can contain characters that are not allowed in Python variable names, or may just want to avoid typing long names by assigning Symbols with long names to single letter Python variables.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To avoid confusion, throughout this tutorial, Symbol names and Python variable names will always coincide.  Furthermore, the word \"Symbol\" will refer to a SymPy Symbol and the word \"variable\" will refer to a Python variable.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Finally, let us be sure we understand the difference between SymPy Symbols and Python variables.  Consider the following::","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"  x = symbols('x')\n  expr = x + 1\n  x = 2\n  print(expr)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"What do you think the output of this code will be?  If you thought 3, you're wrong.  Let's see what really happens","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"@syms x\nexpr = x + 1\nx = 2\nexpr","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = symbols('x')\n    >>> expr = x + 1\n    >>> x = 2\n    >>> print(expr)\n    x + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Changing x to 2 had no effect on expr.  This is because x = 2 changes the Python variable x to 2, but has no effect on the SymPy Symbol x, which was what we used in creating expr.  When we created expr, the Python variable x was a Symbol.  After we created, it, we changed the Python variable x to 2.  But expr remains the same.  This behavior is not unique to SymPy.  All Python programs work this way: if a variable is changed, expressions that were already created with that variable do not change automatically.  For example","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThis is similar in Julia","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"x = \"abc\"\nexpr = x * \"def\" # * not +\nexpr\nx = \"ABC\"\nexpr","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = 'abc'\n    >>> expr = x + 'def'\n    >>> expr\n    'abcdef'\n    >>> x = 'ABC'\n    >>> expr\n    'abcdef'","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"note: Quick Tip\nTo change the value of a Symbol in an expression, use subs >>> x = symbols('x')\n >>> expr = x + 1\n >>> expr.subs(x, 2)\n 3","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"In this example, if we want to know what expr is with the new value of x, we need to reevaluate the code that created expr, namely, expr = x + 1.  This can be complicated if several lines created expr.  One advantage of using a symbolic computation system like SymPy is that we can build a symbolic representation for expr, and then substitute x with values.  The correct way to do this in SymPy is to use subs, which will be discussed in more detail later.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nWe use the more Julian subs(expr, ...) in lieu of expr.subs(...), which is also possible, though does not allow the Julian specification of paired data using =>..","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"@syms x\nexpr = x + 1\nsubs(expr, x => 2)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x = symbols('x')\n    >>> expr = x + 1\n    >>> expr.subs(x, 2)\n    3","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"note: TODO\nAdd link to basic operations section","category":"page"},{"location":"Tutorial/gotchas/#Equals-signs","page":"Gotchas","title":"Equals signs","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Another very important consequence of the fact that SymPy does not extend Python syntax is that = does not represent equality in SymPy.  Rather it is Python variable assignment.  This is hard-coded into the Python language, and SymPy makes no attempts to change that.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"You may think, however, that ==, which is used for equality testing in Python, is used for SymPy as equality.  This is not quite correct either.  Let us see what happens when we use ==.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nIn math = is for specifying an equation, but in Julia (as with Python), = is for assignment. The == checks for equality (Julia also uses === and isequal for related, but different tests of equality). Equations in SymPy use either Eq as a function or ~ as an infix operator.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"x + 1 == 4","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + 1 == 4\n    False","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Instead of treating x + 1 == 4 symbolically, we just got False.  In SymPy, == represents exact structural equality testing.  This means that a == b means that we are asking if a = b.  We always get a bool as the result of ==. There is a separate object, called Eq, which can be used to create symbolic equalities.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nIn Julia, in addition to Eq as a function, the infix operator ~ also makes expressions.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"x + 1 ~ 4","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> Eq(x + 1, 4)\n    Eq(x + 1, 4)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"There is one additional caveat about == as well.  Suppose we want to know if (x + 1)^2 = x^2 + 2x + 1.  We might try something like this:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"(x+1)^2 == x^2 + 2x + 1","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> (x + 1)**2 == x**2 + 2*x + 1\n    False","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"We got False again. However, (x + 1)^2 does equal x^2 + 2x + 1. What is going on here?  Did we find a bug in SymPy, or is it just not powerful enough to recognize this basic algebraic fact?","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Recall from above that == represents exact structural equality testing. \"Exact\" here means that two expressions will compare equal with == only if they are exactly equal structurally.  Here, (x + 1)^2 and x^2 + 2x + 1 are not the same structurally. One is the power of an addition of two terms, and the other is the addition of three terms.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"It turns out that when using SymPy as a library, having == test for exact structural equality is far more useful than having it represent symbolic equality, or having it test for mathematical equality.  However, as a new user, you will probably care more about the latter two.  We have already seen an alternative to representing equalities symbolically, Eq.  To test if two things are equal, it is best to recall the basic fact that if a = b, then a - b = 0.  Thus, the best way to check if a = b is to take a - b and simplify it, and see if it goes to 0.  We will learn later that the function to do this is called simplify. This method is not infallible–-in fact, it can be theoretically proven that it is impossible to determine if two symbolic expressions are identically equal in general–-but for most common expressions, it works quite well.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"a = (x+1)^2\nb = x^2 + 2x + 1\nsimplify(a - b)\nc = x^2 - 2x +1\nsimplify(a - c)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> a = (x + 1)**2\n    >>> b = x**2 + 2*x + 1\n    >>> simplify(a - b)\n    0\n    >>> c = x**2 - 2*x + 1\n    >>> simplify(a - c)\n    4*x","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"There is also a method called equals that tests if two expressions are equal by evaluating them numerically at random points.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"a = cos(x)^2 - sin(x)^2\nb = cos(2*x)\na.equals(b)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> a = cos(x)**2 - sin(x)**2\n    >>> b = cos(2*x)\n    >>> a.equals(b)\n    True","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/#Two-Final-Notes:-and-/","page":"Gotchas","title":"Two Final Notes: ^ and /","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"You may have noticed that we have been using ** for exponentiation instead of the standard ^.  That's because SymPy follows Python's conventions.  In Python, ^ represents logical exclusive or.  SymPy follows this convention:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThe ^ is for exponents; use & or | instead","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Sym(true) & Sym(false)\nSym(true) | Sym(true)\nxor(x, y)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> True ^ False\n    True\n    >>> True ^ True\n    False\n    >>> Xor(x, y)\n    x ^ y","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Finally, a small technical discussion on how SymPy works is in order.  When you type something like x + 1, the SymPy Symbol x is added to the Python int 1.  Python's operator rules then allow SymPy to tell Python that SymPy objects know how to be added to Python ints, and so 1 is automatically converted to the SymPy Integer object.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This sort of operator magic happens automatically behind the scenes, and you rarely need to even know that it is happening.  However, there is one exception.  Whenever you combine a SymPy object and a SymPy object, or a SymPy object and a Python object, you get a SymPy object, but whenever you combine two Python objects, SymPy never comes into play, and so you get a Python object.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThis is also how promotion works within Julia in that promotion to symbolic types is sticky","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"typeof(Sym(1) + 1)\ntypeof(1 + 1)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> type(Integer(1) + 1)\n    <class 'sympy.core.numbers.Integer'>\n    >>> type(1 + 1)\n    <... 'int'>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This is usually not a big deal. Python ints work much the same as SymPy Integers, but there is one important exception:  division.  In SymPy, the division of two Integers gives a Rational:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nIn Julia Sym(1//3) will also produce a symbolic rational, but not Sym(1/3).","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"u = Sym(1) / Sym(3)\ntypeof(u)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> Integer(1)/Integer(3)\n    1/3\n    >>> type(Integer(1)/Integer(3))\n    <class 'sympy.core.numbers.Rational'>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"But in Python / represents either integer division or floating point division, depending on whether you are in Python 2 or Python 3, and depending on whether or not you have run from __future__ import division in Python 2 which is no longer supported from versions above SymPy 1.5.1:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nIn Julia / is division and for integers returns a floating point value.","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"1/2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> from __future__ import division\n    >>> 1/2\n    0.5","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"To avoid this, we can construct the rational object explicitly","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nWhile sympy.Rational(1, 2) produces a rational number, a more Julian way is to convert a rational into a symbolic value","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"Sym(1//2)","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> Rational(1, 2)\n    1/2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This problem also comes up whenever we have a larger symbolic expression with int/int in it.  For example:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nThis is also a problem in Julia","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"x + 1/2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + 1/2\n    x + 0.5","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"This happens because Python first evaluates 1/2 into 0.5, and then that is cast into a SymPy type when it is added to x.  Again, we can get around this by explicitly creating a Rational:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"tip: Julia differences\nUse a rational, in the same way:","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"x + 1//2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"    >>> x + Rational(1, 2)\n    x + 1/2","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"</details>","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"","category":"page"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"There are several tips on avoiding this situation in the :ref:gotchas document.","category":"page"},{"location":"Tutorial/gotchas/#Further-Reading","page":"Gotchas","title":"Further Reading","text":"","category":"section"},{"location":"Tutorial/gotchas/","page":"Gotchas","title":"Gotchas","text":"For more discussion on the topics covered in this section, see :ref:gotchas.","category":"page"},{"location":"Tutorial/next/#What’s-Next","page":"Next","title":"What’s Next","text":"","category":"section"},{"location":"Tutorial/next/","page":"Next","title":"Next","text":"Congratulations on finishing the SymPy tutorial!","category":"page"},{"location":"Tutorial/next/","page":"Next","title":"Next","text":"If you are a developer interested in using SymPy in your code, please visit the How-to Guides which discuss key developer tasks.","category":"page"},{"location":"Tutorial/next/","page":"Next","title":"Next","text":"Intermediate SymPy users and developers might want to visit the Explanations section for common pitfalls and advanced topics.","category":"page"},{"location":"Tutorial/next/","page":"Next","title":"Next","text":"The SymPy API Reference has a detailed description of the SymPy API.","category":"page"},{"location":"Tutorial/next/","page":"Next","title":"Next","text":"If you are interested in contributing to SymPy, visit the contribution guides.","category":"page"},{"location":"Tutorial/#Introductory-Tutorial","page":"Home","title":"Introductory Tutorial","text":"","category":"section"},{"location":"Tutorial/","page":"Home","title":"Home","text":"tip: Julia differences\nThis is a translation of the SymPy Tutorial using the SymPyCore package for Julia to show the similarities and differences when calling into the Python package from Julia. This version of the tutorial is not endorsed by any member of the SymPy project. If its presence is believed to be inconsistent with the licensing of the original tutorial, notification would be appreciated. As much as possible, the Python text is kept and clarified through comments flagged with \"Julia differences,\" though some minor formatting changes were made.Some notable differences using SymPy under Julia:Julia uses ^ not ** for exponentiation\nJulia is 1-based, not 0-based\nJulia uses \" for strings, not '\nThe macro @syms is primarily used to create symbolic variables and functions, not symbols.\nMany sympy calls of the form obj.method(args...) are wrapped in the Julian style method(obj, args...).\nwhen methods are not wrapped, use sympy.method or obj.method as needed.\nThe name method in Julia is used for specializations of generic functions. The package wraps numerous generic methods from Base Julia specialized on the first argument being symbolic. (E.g., for the sin function a definition like the following is provided: Base.sin(x::Sym) = sympy.sin(x).)\nmethod in sympy is used for an object method; A function like sympy.method is the underlying function from SymPy.)","category":"page"},{"location":"Tutorial/","page":"Home","title":"Home","text":"This tutorial aims to give an introduction to SymPy for someone who has not used the library before.  Many features of SymPy will be introduced in this tutorial, but they will not be exhaustive. In fact, virtually every functionality shown in this tutorial will have more options or capabilities than what will be shown.  The rest of the SymPy documentation serves as API documentation, which extensively lists every feature and option of each function.","category":"page"},{"location":"Tutorial/","page":"Home","title":"Home","text":"These are the goals of this tutorial:","category":"page"},{"location":"Tutorial/","page":"Home","title":"Home","text":"note: note bene\nThis is mainly here for you, the person who is editing and adding to this tutorial. Try to keep these principles in mind.","category":"page"},{"location":"Tutorial/","page":"Home","title":"Home","text":"To give a guide, suitable for someone who has never used SymPy (but who has used Python and knows the necessary mathematics).\nTo be written in a narrative format, which is both easy and fun to follow. It should read like a book.\nTo give insightful examples and exercises, to help the reader learn and to make it entertaining to work through.\nTo introduce concepts in a logical order.\nIn other words, don't try to get ahead of yourself.\nTo use good practices and idioms, and avoid antipatterns.  Functions or methodologies that tend to lead to antipatterns are avoided. Features that are only useful to advanced users are not shown.\nTo be consistent.  If there are multiple ways to do it, only the best way is shown.\nFor example, there are at least five different ways to create Symbols.  symbols is the only one that is general and doesn't lead to  antipatterns, so it is the only one used.\nTo avoid unnecessary duplication, it is assumed that previous sections of the tutorial have already been read.","category":"page"},{"location":"Tutorial/","page":"Home","title":"Home","text":"Feedback on this tutorial, or on SymPy in general is always welcome. Just write to our mailing list.","category":"page"},{"location":"Tutorial/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"note: Note\nFor a beginner-friendly guide focused on solving common types of equations, refer to Solving","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"@syms x, y, z","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":">>> from sympy import *\n>>> x, y, z = symbols('x y z')\n>>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/#A-Note-about-Equations","page":"Solvers","title":"A Note about Equations","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Recall from the gotchas section of this tutorial that symbolic equations in SymPy are not represented by = or ==, but by Eq.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nOr, using ~","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"x ~ y","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> Eq(x, y)\n    x = y","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"However, there is an even easier way.  In SymPy, any expression not in an Eq is automatically assumed to equal 0 by the solving functions.  Since a = b if and only if a - b = 0, this means that instead of using x == y, you can just use x - y.  For example","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solveset(x^2 ~ 1, x)\nsolveset(x^2 - 1 ~ 0, x)\nsolveset(x^2 - 1, x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(Eq(x**2, 1), x)\n    {-1, 1}\n    >>> solveset(Eq(x**2 - 1, 0), x)\n    {-1, 1}\n    >>> solveset(x**2 - 1, x)\n    {-1, 1}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"This is particularly useful if the equation you wish to solve is already equal to 0. Instead of typing solveset(Eq(expr, 0), x), you can just use solveset(expr, x).","category":"page"},{"location":"Tutorial/solvers/#Solving-Equations-Algebraically","page":"Solvers","title":"Solving Equations Algebraically","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The main function for solving algebraic equations is solveset. The syntax for solveset is solveset(equation, variable=None, domain=S.Complexes) Where equations may be in the form of Eq instances or expressions that are assumed to be equal to zero.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Please note that there is another function called solve which can also be used to solve equations. The syntax is solve(equations, variables) However, it is recommended to use solveset instead.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When solving a single equation, the output of solveset is a FiniteSet or an Interval or ImageSet of the solutions.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nFinite sets are turned into Set containers in Julia.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nThe exported 𝑆 objects mirror S from Python. Using sympy.S fails, as the underlying object has a __call__ method, so sympy.S is a callable function, not an object. The construction ↓(sympy).S works, but is cumbersome and \\itS[tab] seems easy enough to enter.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solveset(x^2 - x, x)\nsolveset(x - x, x, domain= 𝑆.Reals)\nsolveset(sin(x) - 1, x, domain= 𝑆.Reals)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(x**2 - x, x)\n    {0, 1}\n    >>> solveset(x - x, x, domain=S.Reals)\n    ℝ\n    >>> solveset(sin(x) - 1, x, domain=S.Reals)\n    ⎧        π │      ⎫\n    ⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬\n    ⎩        2 │      ⎭","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"If there are no solutions, an EmptySet is returned and if it is not able to find solutions then a ConditionSet is returned.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solveset(exp(x), x)\nsolveset(cos(x) - x, x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(exp(x), x)     # No solution exists\n    ∅\n    >>> solveset(cos(x) - x, x)  # Not able to find solution\n    {x │ x ∊ ℂ ∧ (-x + cos(x) = 0)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"In the solveset module, the linear system of equations is solved using linsolve. In future we would be able to use linsolve directly from solveset. Following is an example of the syntax of linsolve.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"List of Equations Form:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"linsolve([x + y + z - 1, x + y + 2*z - 3 ], (x, y, z))","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> linsolve([x + y + z - 1, x + y + 2*z - 3 ], (x, y, z))\n    {(-y - 1, y, 2)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Augmented Matrix Form:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nWe paas in a symbolic matrix to linsolve","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"linsolve(Sym[ 1 1 1 1; 1 1 2 3], (x, y, z))","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> linsolve(Matrix(([1, 1, 1, 1], [1, 1, 2, 3])), (x, y, z))\n    {(-y - 1, y, 2)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"A*x = b Form","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"M = Sym[ 1 1 1 1; 1 1 2 3]\nsystem = A, b = M[:, 1:end-1], M[:, end]\nlinsolve(system, x, y, z)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> M = Matrix(((1, 1, 1, 1), (1, 1, 2, 3)))\n    >>> system = A, b = M[:, :-1], M[:, -1]\n    >>> linsolve(system, x, y, z)\n    {(-y - 1, y, 2)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"note: Note\nThe order of solution corresponds the order of given symbols.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"In the solveset module, the non linear system of equations is solved using nonlinsolve. Following are examples of nonlinsolve.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When only real solution is present:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nWe pass in equations using a tuple, not a vector","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"@syms a::real, b::real, c::real, d::real\nnonlinsolve( (a^2 + a, a - b), (a, b))\nnonlinsolve((x*y - 1, x - 2), x, y)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> a, b, c, d = symbols('a, b, c, d', real=True)\n    >>> nonlinsolve([a**2 + a, a - b], [a, b])\n    {(-1, -1), (0, 0)}\n    >>> nonlinsolve([x*y - 1, x - 2], x, y)\n    {(2, 1/2)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When only complex solution is present:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nAgain, we use tuples, not vectors","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"nonlinsolve((x^2 + 1, y^2 + 1), (x, y))","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> nonlinsolve([x**2 + 1, y**2 + 1], [x, y])\n    {(-ⅈ, -ⅈ), (-ⅈ, ⅈ), (ⅈ, -ⅈ), (ⅈ, ⅈ)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When both real and complex solution are present:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"system = (x^2 - 2*y^2 -2, x*y - 2)\nvars = (x, y)\nnonlinsolve(system, vars)\nsystem = (exp(x) - sin(y), 1/y - 3)\nnonlinsolve(system, vars)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> from sympy import sqrt\n    >>> system = [x**2 - 2*y**2 -2, x*y - 2]\n    >>> vars = [x, y]\n    >>> nonlinsolve(system, vars)\n    {(-2, -1), (2, 1), (-√2⋅ⅈ, √2⋅ⅈ), (√2⋅ⅈ, -√2⋅ⅈ)}\n\n    >>> system = [exp(x) - sin(y), 1/y - 3]\n    >>> nonlinsolve(system, vars)\n    {({2⋅n⋅ⅈ⋅π + log(sin(1/3)) │ n ∊ ℤ}, 1/3)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"When the system is positive-dimensional system (has infinitely many solutions):","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"nonlinsolve((x*y, x*y - x), (x, y))\nsystem = (a^2 + a*c, a - b)\nnonlinsolve(system, (a, b))","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> nonlinsolve([x*y, x*y - x], [x, y])\n    {(0, y)}\n\n    >>> system = [a**2 + a*c, a - b]\n    >>> nonlinsolve(system, [a, b])\n    {(0, 0), (-c, -c)}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Notes:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The order of solution corresponds the order of given symbols.\nCurrently nonlinsolve doesn't return solution in form of LambertW (if there","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"is solution present in the form of LambertW).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solve can be used for such cases:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":" >>> solve([x**2 - y**2/exp(x)], [x, y], dict=True)\n⎡⎧         ____⎫  ⎧        ____⎫⎤\n⎢⎨        ╱  x ⎬  ⎨       ╱  x ⎬⎥\n⎣⎩y: -x⋅╲╱  ℯ  ⎭, ⎩y: x⋅╲╱  ℯ  ⎭⎦\n>>> solve(x**2 - y**2/exp(x), x, dict=True)\n⎡⎧      ⎛-y ⎞⎫  ⎧      ⎛y⎞⎫⎤\n⎢⎨x: 2⋅W⎜───⎟⎬, ⎨x: 2⋅W⎜─⎟⎬⎥\n⎣⎩      ⎝ 2 ⎠⎭  ⎩      ⎝2⎠⎭⎦","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Currently nonlinsolve is not properly capable of solving the system of equations","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"having trigonometric functions.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solve can be used for such cases (but does not give all solution):","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":">>> solve([sin(x + y), cos(x - y)], [x, y])\n⎡⎛-3⋅π   3⋅π⎞  ⎛-π   π⎞  ⎛π  3⋅π⎞  ⎛3⋅π  π⎞⎤\n⎢⎜─────, ───⎟, ⎜───, ─⎟, ⎜─, ───⎟, ⎜───, ─⎟⎥\n⎣⎝  4     4 ⎠  ⎝ 4   4⎠  ⎝4   4 ⎠  ⎝ 4   4⎠⎦","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solveset reports each solution only once.  To get the solutions of a polynomial including multiplicity use roots.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nThe roots function needs qualification","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solveset(x^3 - 6*x^2 + 9*x, x)\nsympy.roots(x^3 - 6*x^2 + 9*x, x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> solveset(x**3 - 6*x**2 + 9*x, x)\n    {0, 3}\n    >>> roots(x**3 - 6*x**2 + 9*x, x)\n    {0: 1, 3: 2}","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The output {0: 1, 3: 2} of roots means that 0 is a root of multiplicity 1 and 3 is a root of multiplicity 2.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Note:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Currently solveset is not capable of solving the following types of equations:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Equations solvable by LambertW (Transcendental equation solver).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"solve can be used for such cases:","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":">>> solve(x*exp(x) - 1, x )\n[W(1)]","category":"page"},{"location":"Tutorial/solvers/#Solving-Differential-Equations","page":"Solvers","title":"Solving Differential Equations","text":"","category":"section"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To solve differential equations, use dsolve.  First, create an undefined function by passing cls=Function to the symbols function.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nWe can use @syms to define symbolic functions","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"@syms f() g()","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> f, g = symbols('f g', cls=Function)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"f and g are now undefined functions.  We can call f(x), and it will represent an unknown function.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"f(x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> f(x)\n    f(x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"Derivatives of f(x) are unevaluated.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"diff(f(x), x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> f(x).diff(x)\n    d\n    ──(f(x))\n    dx","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"(see the `Derivatives section for more on derivatives).","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To represent the differential equation f''(x) - 2f'(x) + f(x) = \\sin(x), we would thus use","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nWe could use similar notation, as within Python, e.g., f(x).diff(x), but we show the use of Differential which hides some repetition","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"∂ = Differential(x)\ndiffeq = ∂(∂(f(x))) - 2 * ∂(f(x)) + f(x) ~ sin(x)","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> diffeq = Eq(f(x).diff(x, x) - 2*f(x).diff(x) + f(x), sin(x))\n    >>> diffeq\n                          2\n             d           d\n    f(x) - 2⋅──(f(x)) + ───(f(x)) = sin(x)\n             dx           2\n                        dx","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"To solve the ODE, pass it and the function to solve for to dsolve.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"dsolve(diffeq, f(x))","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> dsolve(diffeq, f(x))\n                        x   cos(x)\n    f(x) = (C₁ + C₂⋅x)⋅ℯ  + ──────\n                              2","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"dsolve returns an instance of Eq.  This is because, in general, solutions to differential equations cannot be solved explicitly for the function.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"dsolve(∂(f) * (1 - sin(f(x))), f(x))","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"    >>> dsolve(f(x).diff(x)*(1 - sin(f(x))) - 1, f(x))\n    x - f(x) - cos(f(x)) = C₁","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"</details>","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"The arbitrary constants in the solutions from dsolve are symbols of the form C1, C2, C3, and so on.","category":"page"},{"location":"Tutorial/solvers/","page":"Solvers","title":"Solvers","text":"tip: Julia differences\nThe ics argument of dsolve allows a dictionary to be passed to specify initiial conditions.","category":"page"},{"location":"Tutorial/simplification/#Simplification","page":"Simplification","title":"Simplification","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To make this document easier to read, we are going to enable pretty printing.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nPretty printing is the default output.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"@syms x, y, z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> from sympy import *\n    >>> x, y, z = symbols('x y z')\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#simplify","page":"Simplification","title":"simplify","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Now let's jump in and do some interesting mathematics.  One of the most useful features of a symbolic manipulation system is the ability to simplify mathematical expressions.  SymPy has dozens of functions to perform various kinds of simplification.  There is also one general function called simplify() that attempts to apply all of these functions in an intelligent way to arrive at the simplest form of an expression.  Here are some examples","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe SpecialFunctions package is loaded, so the method for gamma is available.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"using SpecialFunctions\n\nsimplify(sin(x)^2 + cos(x)^2)\nsimplify( (x^3 + x^2 - x - 1) / (x^2 + 2x + 1) )\nsimplify( gamma(x) / gamma(x-2) )","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> simplify(sin(x)**2 + cos(x)**2)\n    1\n    >>> simplify((x**3 + x**2 - x - 1)/(x**2 + 2*x + 1))\n    x - 1\n    >>> simplify(gamma(x)/gamma(x - 2))\n    (x - 2)⋅(x - 1)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Here, gamma(x) is Gamma(x), the gamma function. We see that simplify() is capable of handling a large class of expressions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"But simplify() has a pitfall.  It just applies all the major simplification operations in SymPy, and uses heuristics to determine the simplest result. But \"simplest\" is not a well-defined term.  For example, say we wanted to \"simplify\" x^2 + 2x + 1 into (x + 1)^2:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"simplify(x^2 + 2*x + 1)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> simplify(x**2 + 2*x + 1)\n     2\n    x  + 2⋅x + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We did not get what we want.  There is a function to perform this simplification, called factor(), which will be discussed below.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Another pitfall to simplify() is that it can be unnecessarily slow, since it tries many kinds of simplifications before picking the best one.  If you already know exactly what kind of simplification you are after, it is better to apply the specific simplification function(s) that apply those simplifications.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Applying specific simplification functions instead of simplify() also has the advantage that specific functions have certain guarantees about the form of their output.  These will be discussed with each function below.  For example, factor(), when called on a polynomial with rational coefficients, is guaranteed to factor the polynomial into irreducible factors. simplify() has no guarantees.  It is entirely heuristical, and, as we saw above, it may even miss a possible type of simplification that SymPy is capable of doing.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"simplify() is best when used interactively, when you just want to whittle down an expression to a simpler form.  You may then choose to apply specific functions once you see what simplify() returns, to get a more precise result.  It is also useful when you have no idea what form an expression will take, and you need a catchall function to simplify it.","category":"page"},{"location":"Tutorial/simplification/#Polynomial/Rational-Function-Simplification","page":"Simplification","title":"Polynomial/Rational Function Simplification","text":"","category":"section"},{"location":"Tutorial/simplification/#expand","page":"Simplification","title":"expand","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand() is one of the most common simplification functions in SymPy. Although it has a lot of scopes, for now, we will consider its function in expanding polynomial expressions. For example:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand( (x+1)^2 )\nexpand( (x+2) * (x-3) )","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand((x + 1)**2)\n     2\n    x  + 2⋅x + 1\n    >>> expand((x + 2)*(x - 3))\n     2\n    x  - x - 6","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Given a polynomial, expand() will put it into a canonical form of a sum of monomials.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand() may not sound like a simplification function.  After all, by its very name, it makes expressions bigger, not smaller.  Usually this is the case, but often an expression will become smaller upon calling expand() on it due to cancellation.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand((x + 1)*(x - 2) - (x - 1)*x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand((x + 1)*(x - 2) - (x - 1)*x)\n    -2","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#factor","page":"Simplification","title":"factor","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"factor() takes a polynomial and factors it into irreducible factors over the rational numbers.  For example:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"factor(x^3 - x^2 + x - 1)\nfactor(x^2*z + 4*x*y*z + 4*y^2*z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factor(x**3 - x**2 + x - 1)\n            ⎛ 2    ⎞\n    (x - 1)⋅⎝x  + 1⎠\n    >>> factor(x**2*z + 4*x*y*z + 4*y**2*z)\n               2\n    z⋅(x + 2⋅y)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"For polynomials, factor() is the opposite of expand().  factor() uses a complete multivariate factorization algorithm over the rational numbers, which means that each of the factors returned by factor() is guaranteed to be irreducible.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"If you are interested in the factors themselves, factor_list returns a more structured output.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe factor_list function must be qualified","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"c, fs = sympy.factor_list(x^2*z + 4*x*y*z + 4*y^2*z);\nc  # constant\nfs # factors (fac, mult)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factor_list(x**2*z + 4*x*y*z + 4*y**2*z)\n    (1, [(z, 1), (x + 2⋅y, 2)])","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that the input to factor and expand need not be polynomials in the strict sense.  They will intelligently factor or expand any kind of expression (though note that the factors may not be irreducible if the input is no longer a polynomial over the rationals).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand((cos(x) + sin(x))^2)\nexpand((cos(x) + sin(x))^2)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand((cos(x) + sin(x))**2)\n       2                           2\n    sin (x) + 2⋅sin(x)⋅cos(x) + cos (x)\n    >>>  expand((cos(x) + sin(x))**2)\n                     2\n    (sin(x) + cos(x))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#collect","page":"Simplification","title":"collect","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"collect() collects common powers of a term in an expression.  For example","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe collect method when the first argument is symbolic, dispatches to sympy.collect, which has the semantics below. A call like collect(Sym, ...) will not behave as expected.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expr = x*y + x - 3 + 2*x^2 - z*x^2 + x^3\ncollected_expr = collect(expr, x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3\n    >>> expr\n     3    2        2\n    x  - x ⋅z + 2⋅x  + x⋅y + x - 3\n    >>> collected_expr = collect(expr, x)\n    >>> collected_expr\n     3    2\n    x  + x ⋅(2 - z) + x⋅(y + 1) - 3","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"collect() is particularly useful in conjunction with the .coeff() method.  expr.coeff(x, n) gives the coefficient of x**n in expr:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"collected_expr.coeff(x, 2)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> collected_expr.coeff(x, 2)\n    2 - z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nDiscuss coeff method in more detail in some other section (maybe basic expression manipulation tools)","category":"page"},{"location":"Tutorial/simplification/#cancel","page":"Simplification","title":"cancel","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"cancel() will take any rational function and put it into the standard canonical form, fracpq, where p and q are expanded polynomials with no common factors, and the leading coefficients of p and q do not have denominators (i.e., are integers).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"cancel((x^2 + 2*x + 1)/(x^2 + x))\nexpr = 1/x + (3*x/2 - 2)/(x - 4)\ncancel(expr)\nexpr = (x*y^2 - 2*x*y*z + x*z^2 + y^2 - 2*y*z + z^2)/(x^2 - 1)\ncancel(expr)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> cancel((x**2 + 2*x + 1)/(x**2 + x))\n    x + 1\n    ─────\n      x\n\n    >>> expr = 1/x + (3*x/2 - 2)/(x - 4)\n    >>> expr\n    3⋅x\n    ─── - 2\n     2        1\n    ─────── + ─\n     x - 4    x\n    >>> cancel(expr)\n       2\n    3⋅x  - 2⋅x - 8\n    ──────────────\n         2\n      2⋅x  - 8⋅x\n\n    >>> expr = (x*y**2 - 2*x*y*z + x*z**2 + y**2 - 2*y*z + z**2)/(x**2 - 1)\n    >>> expr\n       2                2    2            2\n    x⋅y  - 2⋅x⋅y⋅z + x⋅z  + y  - 2⋅y⋅z + z\n    ───────────────────────────────────────\n                      2\n                     x  - 1\n    >>> cancel(expr)\n     2            2\n    y  - 2⋅y⋅z + z\n    ───────────────\n         x - 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that since factor() will completely factorize both the numerator and the denominator of an expression, it can also be used to do the same thing:","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"factor(expr)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factor(expr)\n           2\n    (y - z)\n    ────────\n     x - 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"However, if you are only interested in making sure that the expression is in canceled form, cancel() is more efficient than factor().","category":"page"},{"location":"Tutorial/simplification/#apart","page":"Simplification","title":"apart","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"apart() performs a partial fraction decomposition on a rational function.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expr = (4*x^3 + 21*x^2 + 10*x + 12)/(x^4 + 5*x^3 + 5*x^2 + 4*x)\napart(expr)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expr = (4*x**3 + 21*x**2 + 10*x + 12)/(x**4 + 5*x**3 + 5*x**2 + 4*x)\n    >>> expr\n       3       2\n    4⋅x  + 21⋅x  + 10⋅x + 12\n    ────────────────────────\n      4      3      2\n     x  + 5⋅x  + 5⋅x  + 4⋅x\n    >>> apart(expr)\n     2⋅x - 1       1     3\n    ────────── - ───── + ─\n     2           x + 4   x\n    x  + x + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Trigonometric-Simplification","page":"Simplification","title":"Trigonometric Simplification","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nSymPy follows Python's naming conventions for inverse trigonometric functions, which is to append an a to the front of the function's name.  For example, the inverse cosine, or arc cosine, is called acos().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe SymPy convention is the same as within Julia","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"acos(x)\ncos(acos(x))\nasin(Sym(1))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> acos(x)\n    acos(x)\n    >>> cos(acos(x))\n    x\n    >>> asin(1)\n    π\n    ─\n    2","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nCan we actually do anything with inverse trig functions, simplification wise?","category":"page"},{"location":"Tutorial/simplification/#trigsimp","page":"Simplification","title":"trigsimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To simplify expressions using trigonometric identities, use trigsimp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe trigsimp function needs qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.trigsimp(sin(x)^2 + cos(x)^2)\nsympy.trigsimp(sin(x)^4 - 2*cos(x)^2*sin(x)^2 + cos(x)^4)\nsympy.trigsimp(sin(x)*tan(x)/sec(x))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> trigsimp(sin(x)**2 + cos(x)**2)\n    1\n    >>> trigsimp(sin(x)**4 - 2*cos(x)**2*sin(x)**2 + cos(x)**4)\n    cos(4⋅x)   1\n    ──────── + ─\n       2       2\n    >>> trigsimp(sin(x)*tan(x)/sec(x))\n       2\n    sin (x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"trigsimp() also works with hyperbolic trig functions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.trigsimp(cosh(x)^2 + sinh(x)^2)\nsympy.trigsimp(sinh(x)/tanh(x))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> trigsimp(cosh(x)**2 + sinh(x)**2)\n    cosh(2⋅x)\n    >>> trigsimp(sinh(x)/tanh(x))\n    cosh(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Much like simplify(), trigsimp() applies various trigonometric identities to the input expression, and then uses a heuristic to return the \"best\" one.","category":"page"},{"location":"Tutorial/simplification/#expand_trig","page":"Simplification","title":"expand_trig","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To expand trigonometric functions, that is, apply the sum or double angle identities, use expand_trig().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe expand_trig function must be qualified","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_trig(sin(x + y))\nsympy.expand_trig(tan(2*x))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_trig(sin(x + y))\n    sin(x)⋅cos(y) + sin(y)⋅cos(x)\n    >>> expand_trig(tan(2*x))\n      2⋅tan(x)\n    ───────────\n           2\n    1 - tan (x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Because expand_trig() tends to make trigonometric expressions larger, and trigsimp() tends to make them smaller, these identities can be applied in reverse using trigsimp()","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.trigsimp(sin(x)*cos(y) + sin(y)*cos(x))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> trigsimp(sin(x)*cos(y) + sin(y)*cos(x))\n    sin(x + y)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nIt would be much better to teach individual trig rewriting functions here, but they don't exist yet.  See https://github.com/sympy/sympy/issues/3456.","category":"page"},{"location":"Tutorial/simplification/#Powers","page":"Simplification","title":"Powers","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Before we introduce the power simplification functions, a mathematical discussion on the identities held by powers is in order.  There are three kinds of identities satisfied by exponents","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"x^ax^b = x^a + b\nx^ay^a = (xy)^a\n(x^a)^b = x^ab","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity 1 is always true.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity 2 is not always true.  For example, if x = y = -1 and a = frac12, then x^ay^a = sqrt-1sqrt-1 = icdot i = -1, whereas (xy)^a = sqrt-1cdot-1 = sqrt1 = 1.  However, identity 2 is true at least if x and y are nonnegative and a is real (it may also be true under other conditions as well).  A common consequence of the failure of identity 2 is that sqrtxsqrty neq sqrtxy.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity 3 is not always true.  For example, if x = -1, a = 2, and b = frac12, then (x^a)^b = left((-1)^2right)^12 = sqrt1 = 1 and x^ab = (-1)^2cdot12 = (-1)^1 = -1.  However, identity 3 is true when b is an integer (again, it may also hold in other cases as well).  Two common consequences of the failure of identity 3 are that sqrtx^2neq x and that sqrtfrac1x neq frac1sqrtx.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To summarize","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Identity Sufficient conditions to hold Counterexample when conditions are not met Important consequences\n1. x^ax^b = x^a + b Always true None None\n2. x^ay^a = (xy)^a x y geq 0 and a in mathbbR (-1)^12(-1)^12 neq (-1cdot-1)^12 sqrtxsqrty neq sqrtxy in general\n3. (x^a)^b = x^ab b in mathbbZ left((-1)^2right)^12 neq (-1)^2cdot12 sqrtx^2neq x and sqrtfrac1xneqfrac1sqrtx in general","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This is important to remember, because by default, SymPy will not perform simplifications if they are not true in general.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"In order to make SymPy perform simplifications involving identities that are only true under certain assumptions, we need to put assumptions on our Symbols.  We will undertake a full discussion of the assumptions system later, but for now, all we need to know are the following.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"By default, SymPy Symbols are assumed to be complex (elements of mathbbC).  That is, a simplification will not be applied to an expression with a given Symbol unless it holds for all complex numbers.\nSymbols can be given different assumptions by passing the assumption to symbols().  For the rest of this section, we will be assuming that x and y are positive, and that a and b are real.  We will leave z, t, and c as arbitrary complex Symbols to demonstrate what happens in that case.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nWe use @syms below, though symbols has an advantage when defining more than one variable with a certain assumption","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"@syms x::positive, y::positive\n@syms a::real, b::rea;\n@syms z, t, c","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> x, y = symbols('x y', positive=True)\n    >>> a, b = symbols('a b', real=True)\n    >>> z, t, c = symbols('z t c')","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: TODO\nRewrite this using the new assumptions","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nIn SymPy, sqrt(x) is just a shortcut to x**Rational(1, 2).  They are exactly the same object.","category":"page"},{"location":"Tutorial/simplification/#powsimp","page":"Simplification","title":"powsimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"powsimp() applies identities 1 and 2 from above, from left to right.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe powsimp function must be qualified","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powsimp(x^a*x^b)\nsympy.powsimp(x^a*y^a)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> powsimp(x**a*x**b)\n     a + b\n    x\n   >>> powsimp(x**a*y**a)\n        a\n   (x⋅y)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Notice that powsimp() refuses to do the simplification if it is not valid.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powsimp(t^c*z^c)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powsimp(t**c*z**c)\n     c  c\n    t ⋅z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"If you know that you want to apply this simplification, but you don't want to mess with assumptions, you can pass the force=True flag.  This will force the simplification to take place, regardless of assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powsimp(t^c*z^c, force=true)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powsimp(t**c*z**c, force=True)\n         c\n    (t⋅z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that in some instances, in particular, when the exponents are integers or rational numbers, and identity 2 holds, it will be applied automatically.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"(z*t)^2\nsqrt(x*y)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> (z*t)**2\n     2  2\n    t ⋅z\n   >>> sqrt(x*y)\n    √x⋅√y","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This means that it will be impossible to undo this identity with powsimp(), because even if powsimp() were to put the bases together, they would be automatically split apart again.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powsimp(z^2*t^2)\nsympy.powsimp(sqrt(x)*sqrt(y))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> powsimp(z**2*t**2)\n     2  2\n    t ⋅z\n   >>> powsimp(sqrt(x)*sqrt(y))\n    √x⋅√y","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#expand*power*exp-/-expand*power*base","page":"Simplification","title":"expandpowerexp / expandpowerbase","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expand_power_exp() and expand_power_base() apply identities 1 and 2 from right to left, respectively.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThe too need qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_power_exp(x^(a + b))\nsympy.expand_power_base((x*y)^a)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_power_exp(x**(a + b))\n     a  b\n    x ⋅x\n\n    >>> expand_power_base((x*y)**a)\n     a  a\n    x ⋅y","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As with powsimp(), identity 2 is not applied if it is not valid.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_power_base((z*t)^c)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_power_base((z*t)**c)\n         c\n    (t⋅z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"And as with powsimp(), you can force the expansion to happen without fiddling with assumptions by using force=True.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_power_base((z*t)^c, force=true)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> expand_power_base((z*t)**c, force=True)\n     c  c\n    t ⋅z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As with identity 2, identity 1 is applied automatically if the power is a number, and hence cannot be undone with expand_power_exp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"x^2*x^3\nsympy.expand_power_exp(x^5)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"   >>> x**2*x**3\n     5\n    x\n   >>> expand_power_exp(x**5)\n     5\n    x","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#powdenest","page":"Simplification","title":"powdenest","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"powdenest() applies identity 3, from left to right.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThis function needs qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powdenest((x^a)^b)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powdenest((x**a)**b)\n     a⋅b\n    x","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As before, the identity is not applied if it is not true under the given assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powdenest((z^a)^b)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powdenest((z**a)**b)\n        b\n    ⎛ a⎞\n    ⎝z ⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"And as before, this can be manually overridden with force=True.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.powdenest((z^a)^b, force=true)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> powdenest((z**a)**b, force=True)\n     a⋅b\n    z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Exponentials-and-logarithms","page":"Simplification","title":"Exponentials and logarithms","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"note: Note\nIn SymPy, as in Python and most programming languages, log is the natural logarithm, also known as ln.  SymPy automatically provides an alias ln = log in case you forget this. >>> ln(x)\n log(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Logarithms have similar issues as powers.  There are two main identities","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"log(xy) = log(x) + log(y)\nlog(x^n) = nlog(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Neither identity is true for arbitrary complex x and y, due to the branch cut in the complex plane for the complex logarithm.  However, sufficient conditions for the identities to hold are if x and y are positive and n is real.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"@syms x::positive, y::positive, n::real","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> x, y = symbols('x y', positive=True)\n    >>> n = symbols('n', real=True)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As before, z and t will be Symbols with no additional assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Note that the identity logleft(fracxyright) = log(x) - log(y) is a special case of identities 1 and 2 by logleft(fracxyright)= logleft(xcdotfrac1yright) = log(x) + logleft(y^-1right) = log(x) - log(y), and thus it also holds if x and y are positive, but may not hold in general.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We also see that logleft( e^x right) = x comes from logleft( e^x right) = xlog(e) = x, and thus holds when x is real (and it can be verified that it does not hold in general for arbitrary complex x, for example, logleft(e^x + 2pi iright) = logleft(e^xright) = x neq x + 2pi i).","category":"page"},{"location":"Tutorial/simplification/#expand_log","page":"Simplification","title":"expand_log","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To apply identities 1 and 2 from left to right, use expand_log().  As always, the identities will not be applied unless they are valid.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThis function needs qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_log(log(x*y))\nsympy.expand_log(log(x/y))\nsympy.expand_log(log(x^2))\nsympy.expand_log(log(x^n))\nsympy.expand_log(log(z*t))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_log(log(x*y))\n    log(x) + log(y)\n    >>> expand_log(log(x/y))\n    log(x) - log(y)\n    >>> expand_log(log(x**2))\n    2⋅log(x)\n    >>> expand_log(log(x**n))\n    n⋅log(x)\n    >>> expand_log(log(z*t))\n    log(t⋅z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"As with powsimp() and powdenest(), expand_log() has a force option that can be used to ignore assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_log(log(z^2))\nsympy.expand_log(log(z^2), force=true)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_log(log(z**2))\n       ⎛ 2⎞\n    log⎝z ⎠\n    >>> expand_log(log(z**2), force=True)\n    2⋅log(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#logcombine","page":"Simplification","title":"logcombine","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To apply identities 1 and 2 from right to left, use logcombine().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThis function needs qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.logcombine(log(x) + log(y))\nsympy.logcombine(n*log(x))\nsympy.logcombine(n*log(z))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> logcombine(log(x) + log(y))\n    log(x⋅y)\n    >>> logcombine(n*log(x))\n       ⎛ n⎞\n    log⎝x ⎠\n    >>> logcombine(n*log(z))\n    n⋅log(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"logcombine() also has a force option that can be used to ignore assumptions.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.logcombine(n*log(z), force=true)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> logcombine(n*log(z), force=True)\n       ⎛ n⎞\n    log⎝z ⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Special-Functions","page":"Simplification","title":"Special Functions","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"SymPy implements dozens of special functions, ranging from functions in combinatorics to mathematical physics.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"An extensive list of the special functions included with SymPy and their documentation is at the Functions Module page.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"For the purposes of this tutorial, let's introduce a few special functions in SymPy.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Let's define x, y, and z as regular, complex Symbols, removing any assumptions we put on them in the previous section.  We will also define k, m, and n.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nFunctions in SpecialFunctions with SymPy counterparts have methods defined for them which, generally, are dispatched on through the first argument being symbolic. Other special function in SymPy must be qualifed in usage, as in sympy.hyper. For these, there is no requirement that the first argument be symbolic.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"@syms x y z k m n","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> x, y, z = symbols('x y z')\n    >>> k, m, n = symbols('k m n')","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The factorial function is factorial.  factorial(n) represents n!= 1\\cdot2\\cdots(n - 1)\\cdot n. n! represents the number of permutations of n distinct items.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"factorial(n)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> factorial(n)\n    n!","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient function is binomial.  binomial(n, k) represents binomnk, the number of ways to choose k items from a set of n distinct items.  It is also often written as nCk, and is pronounced \"n choose k\".","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"binomial(n, k)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> binomial(n, k)\n    ⎛n⎞\n    ⎜ ⎟\n    ⎝k⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The factorial function is closely related to the gamma function, gamma.  gamma(z) represents Gamma(z) = int_0^infty t^z - 1e^-tdt, which for positive integer z is the same as (z - 1).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nAs mentioned, gamma is exported by  SpecialFunctions and a method for symbolic arguments is provided when that package is loaded","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"gamma(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> gamma(z)\n    Γ(z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The generalized hypergeometric function is hyper. hyper(a_1  a_p b_1  b_q z) represents{}pFq\\left(\\begin{matrix} a1, \\cdots, ap \\ b1, \\cdots, bq \\end{matrix} \\middle| z \\right)  The most common case is{}2F1`, which is often referred to as theordinary hypergeometric function https://en.wikipedia.org/wiki/Hypergeometric_function.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.hyper([1, 2], [3], z)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> hyper([1, 2], [3], z)\n     ┌─  ⎛1, 2 │  ⎞\n     ├─  ⎜     │ z⎟\n    2╵ 1 ⎝ 3   │  ⎠","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#rewrite","page":"Simplification","title":"rewrite","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"A common way to deal with special functions is to rewrite them in terms of one another.  This works for any function in SymPy, not just special functions. To rewrite an expression in terms of a function, use expr.rewrite(function).  For example,","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tan(x).rewrite(cos)\nfactorial(x).rewrite(gamma)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> tan(x).rewrite(cos)\n       ⎛    π⎞\n    cos⎜x - ─⎟\n       ⎝    2⎠\n    ──────────\n      cos(x)\n    >>> factorial(x).rewrite(gamma)\n    Γ(x + 1)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"For some tips on applying more targeted rewriting, see the :ref:tutorial-manipulation section.","category":"page"},{"location":"Tutorial/simplification/#expand_func","page":"Simplification","title":"expand_func","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To expand special functions in terms of some identities, use expand_func().  For example","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThis function needs qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.expand_func(gamma(x + 3))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expand_func(gamma(x + 3))\n    x⋅(x + 1)⋅(x + 2)⋅Γ(x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#hyperexpand","page":"Simplification","title":"hyperexpand","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To rewrite hyper in terms of more standard functions, use hyperexpand().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.hyperexpand(sympy.hyper([1, 1], [2], z))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> hyperexpand(hyper([1, 1], [2], z))\n    -log(1 - z)\n    ────────────\n         z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"hyperexpand() also works on the more general Meijer G-function (see its documentation for more information).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"expr = sympy.meijerg([[1],[1]], [[1],[]], -z)\nsympy.hyperexpand(expr)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> expr = meijerg([[1],[1]], [[1],[]], -z)\n    >>> expr\n    ╭─╮1, 1 ⎛1  1 │   ⎞\n    │╶┐     ⎜     │ -z⎟\n    ╰─╯2, 1 ⎝1    │   ⎠\n    >>> hyperexpand(expr)\n     1\n     ─\n     z\n    ℯ","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#combsimp","page":"Simplification","title":"combsimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To simplify combinatorial expressions, use combsimp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"@syms n::integer, k::integer\nsympy.combsimp(factorial(n)/factorial(n - 3))\nsympy.combsimp(binomial(n+1, k+1)/binomial(n, k))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> n, k = symbols('n k', integer = True)\n    >>> combsimp(factorial(n)/factorial(n - 3))\n    n⋅(n - 2)⋅(n - 1)\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n    n + 1\n    ─────\n    k + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#gammasimp","page":"Simplification","title":"gammasimp","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"To simplify expressions with gamma functions or combinatorial functions with non-integer argument, use gammasimp().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nThis function needs qualification","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"sympy.gammasimp(gamma(x)*gamma(1 - x))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> gammasimp(gamma(x)*gamma(1 - x))\n       π\n    ────────\n    sin(π⋅x)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/#Example:-Continued-Fractions","page":"Simplification","title":"Example: Continued Fractions","text":"","category":"section"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Let's use SymPy to explore continued fractions.  A continued fraction is an expression of the form","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"a_0 + cfrac1a_1 + cfrac1a_2 + cfrac1 ddots + cfrac1a_n\n   ","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"where a_0 ldots a_n are integers, and a_1 ldots a_n are positive. A continued fraction can also be infinite, but infinite objects are more difficult to represent in computers, so we will only examine the finite case here.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"A continued fraction of the above form is often represented as a list a_0 a_1 ldots a_n.  Let's write a simple function that converts such a list to its continued fraction form.  The easiest way to construct a continued fraction from a list is to work backwards.  Note that despite the apparent symmetry of the definition, the first element, a_0, must usually be handled differently from the rest.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"function list_to_frac(l)\n  ex = Sym(0)\n  for i in reverse(l[2:end])\n    ex += i\n    ex = 1/ex\n  end\n  first(l) + ex\nend\nlist_to_frac([x, y, z])","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> def list_to_frac(l):\n    ...     expr = Integer(0)\n    ...     for i in reversed(l[1:]):\n    ...         expr += i\n    ...         expr = 1/expr\n    ...     return l[0] + expr\n    >>> list_to_frac([x, y, z])\n          1\n    x + ─────\n            1\n        y + ─\n            z","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"We use Integer(0) in list_to_frac so that the result will always be a SymPy object, even if we only pass in Python ints.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"list_to_frac([1, 2, 3, 4])","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> list_to_frac([1, 2, 3, 4])\n    43\n    ──\n    30","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Every finite continued fraction is a rational number, but we are interested in symbolics here, so let's create a symbolic continued fraction.  The symbols() function that we have been using has a shortcut to create numbered symbols.  symbols('a0:5') will create the symbols a0, a1, ..., a4.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"@syms a[0:4]\nfrac = list_to_frac(a)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> syms = symbols('a0:5')\n    >>> syms\n    (a₀, a₁, a₂, a₃, a₄)\n    >>> a0, a1, a2, a3, a4 = syms\n    >>> frac = list_to_frac(syms)\n    >>> frac\n                 1\n    a₀ + ─────────────────\n                   1\n         a₁ + ────────────\n                      1\n              a₂ + ───────\n                        1\n                   a₃ + ──\n                        a₄","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"This form is useful for understanding continued fractions, but lets put it into standard rational function form using cancel().","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"frac = cancel(frac)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> frac = cancel(frac)\n    >>> frac\n    a₀⋅a₁⋅a₂⋅a₃⋅a₄ + a₀⋅a₁⋅a₂ + a₀⋅a₁⋅a₄ + a₀⋅a₃⋅a₄ + a₀ + a₂⋅a₃⋅a₄ + a₂ + a₄\n    ─────────────────────────────────────────────────────────────────────────\n                     a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Now suppose we were given frac in the above canceled form. In fact, we might be given the fraction in any form, but we can always put it into the above canonical form with cancel().  Suppose that we knew that it could be rewritten as a continued fraction.  How could we do this with SymPy?  A continued fraction is recursively c + \\frac{1}{f}, where c is an integer and f is a (smaller) continued fraction.  If we could write the expression in this form, we could pull out each c recursively and add it to a list.  We could then get a continued fraction with our list_to_frac() function.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"The key observation here is that we can convert an expression to the form c + \\frac{1}{f} by doing a partial fraction decomposition with respect to c. This is because f does not contain c.  This means we need to use the apart() function.  We use apart() to pull the term out, then subtract it from the expression, and take the reciprocal to get the f part.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"l = Any[]\na0 = first(a)\nfrac = apart(frac, a0)\npush!(l, a0)\nfrac = 1 / (frac - a0)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> l = []\n    >>> frac = apart(frac, a0)\n    >>> frac\n                    a₂⋅a₃⋅a₄ + a₂ + a₄\n    a₀ + ───────────────────────────────────────\n         a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n    >>> l.append(a0)\n    >>> frac = 1/(frac - a0)\n    >>> frac\n    a₁⋅a₂⋅a₃⋅a₄ + a₁⋅a₂ + a₁⋅a₄ + a₃⋅a₄ + 1\n    ───────────────────────────────────────\n               a₂⋅a₃⋅a₄ + a₂ + a₄","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Now we repeat this process","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"a1,a2,a3,a4 = a[2:end]\nfrac = apart(frac, a1)\npush!(l, a1)\nfrac = 1/(frac - a1)\n\nfrac = apart(frac, a2)\npush!(l, a2)\nfrac = 1/(frac - a2)\n\nfrac = apart(frac, a3)\npush!(l, a3)\nfrac = 1/(frac - a3)\n\nfrac = apart(frac, a4)\npush!(l, a4)\nfrac = 1/(frac - a4)\n\nlist_to_frac(l)","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> frac = apart(frac, a1)\n    >>> frac\n             a₃⋅a₄ + 1\n    a₁ + ──────────────────\n         a₂⋅a₃⋅a₄ + a₂ + a₄\n    >>> l.append(a1)\n    >>> frac = 1/(frac - a1)\n    >>> frac = apart(frac, a2)\n    >>> frac\n             a₄\n    a₂ + ─────────\n         a₃⋅a₄ + 1\n    >>> l.append(a2)\n    >>> frac = 1/(frac - a2)\n    >>> frac = apart(frac, a3)\n    >>> frac\n         1\n    a₃ + ──\n         a₄\n    >>> l.append(a3)\n    >>> frac = 1/(frac - a3)\n    >>> frac = apart(frac, a4)\n    >>> frac\n    a₄\n    >>> l.append(a4)\n    >>> list_to_frac(l)\n                 1\n    a₀ + ─────────────────\n                   1\n         a₁ + ────────────\n                      1\n              a₂ + ───────\n                        1\n                   a₃ + ──\n                        a₄","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Of course, this exercise seems pointless, because we already know that our frac is list_to_frac([a0, a1, a2, a3, a4]).  So try the following exercise.  Take a list of symbols and randomize them, and create the canceled continued fraction, and see if you can reproduce the original list.  For example","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"tip: Julia differences\nSampling with replacement is provided in the StatsBase package. Here we define a non-performant function to shuffle a vector of values.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"shuffle(x) = [(i=rand(1:length(x)); a=x[i]; deleteat!(x,i); a) for _ ∈ 1:length(x)]\n@syms a[0:4]\nl = shuffle(a)\norig_frac = frac = cancel(list_to_frac(l))","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"    >>> import random\n    >>> l = list(symbols('a0:5'))\n    >>> random.shuffle(l)\n    >>> orig_frac = frac = cancel(list_to_frac(l))\n    >>> del l","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"</details>","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"In SymPy, on the above example, try to reproduce l from frac.  I have deleted l at the end to remove the temptation for peeking (you can check your answer at the end by calling cancel(list_to_frac(l)) on the list that you generate at the end, and comparing it to orig_frac.","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"See if you can think of a way to figure out what symbol to pass to apart() at each stage (hint: think of what happens to a_0 in the formula a_0 + frac1a_1 + cdots when it is canceled).","category":"page"},{"location":"Tutorial/simplification/","page":"Simplification","title":"Simplification","text":"Answer: a_0 is the only symbol that does not appear in the denominator","category":"page"},{"location":"Tutorial/basic_operations/#Basic-Operations","page":"Basic operations","title":"Basic Operations","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Here we discuss some of the most basic operations needed for expression manipulation in SymPy.  Some more advanced operations will be discussed later in the advanced expression manipulation section.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"@syms x, y, z","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> from sympy import *\n    >>> x, y, z = symbols(\"x y z\")","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/#Substitution","page":"Basic operations","title":"Substitution","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"One of the most common things you might want to do with a mathematical expression is substitution.  Substitution replaces all instances of something in an expression with something else.  It is done using the subs method. For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe can call subs using the Julian notation of subs(expr, ...) rather than the object methoc syntax more common in Python, expr.subs(...). Further, we can use \"pairs\" notation when calling subs in this manner.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = cos(x) + 1\nsubs(expr, x=>y)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = cos(x) + 1\n    >>> expr.subs(x, y)\n    cos(y) + 1","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Substitution is usually done for one of two reasons:","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Evaluating an expression at a point. For example, if our expression is cos(x) + 1 and we want to evaluate it at the point x = 0, so that we get cos(0) + 1, which is 2.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe can also use the object-method syntax.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr.subs(x,0)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr.subs(x, 0)\n   2","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Replacing a subexpression with another subexpression.  There are two reasons we might want to do this.  The first is if we are trying to build an expression that has some symmetry, such as x^{x^{x^x}}.  To build this, we might start with x**y, and replace y with x**y.  We would then get x**(x**y).  If we replaced y in this new expression with x**x, we would get x**(x**(x**x)), the desired expression.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = x^y\nexpr = subs(expr, y => x^y)\nsubs(expr, y => x^x)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr = x**y\n   >>> expr\n   x**y\n   >>> expr = expr.subs(y, x**y)\n   >>> expr\n   x**(x**y)\n   >>> expr = expr.subs(y, x**x)\n   >>> expr\n   x**(x**(x**x))","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The second is if we want to perform a very controlled simplification, or    perhaps a simplification that SymPy is otherwise unable to do.  For    example, say we have \\sin(2x) + \\cos(2x), and we want to replace    \\sin(2x) with 2\\sin(x)\\cos(x).  As we will learn later, the function    expand_trig does this.  However, this function will also expand    \\cos(2x), which we may not want.  While there are ways to perform such    precise simplification, and we will learn some of them in the    advanced expression manipulation section, an    easy way is to just replace \\sin(2x) with 2\\sin(x)\\cos(x).","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nAs expand_trig is not exposed, it is called as a function from the sympy module, using the dot notation to access underlying values in the module.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = sin(2x) + cos(2x)\nsympy.expand_trig(expr)\nsubs(expr, sin(2x) => 2*sin(x)* cos(x))","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr = sin(2*x) + cos(2*x)\n   >>> expand_trig(expr)\n   2*sin(x)*cos(x) + 2*cos(x)**2 - 1\n   >>> expr.subs(sin(2*x), 2*sin(x)*cos(x))\n   2*sin(x)*cos(x) + cos(2*x)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"There are two important things to note about subs.  First, it returns a new expression.  SymPy objects are immutable.  That means that subs does not modify it in-place.  For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = cos(x)\nsubs(expr, x=>0)\nexpr\nx","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"   >>> expr = cos(x)\n   >>> expr.subs(x, 0)\n   1\n   >>> expr\n   cos(x)\n   >>> x\n   x","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: Quick Tip\nSymPy expressions are immutable.  No function will change them in-place.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nAs with Pytbon, SymPy expressions are immutable.  No function will change them in-place.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Here, we see that performing expr.subs(x, 0) leaves expr unchanged. In fact, since SymPy expressions are immutable, no function will change them in-place.  All functions will return new expressions.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To perform multiple substitutions at once, pass a list of (old, new) pairs to subs.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = x^3 + 4x*y - z\nsubs(expr, x=>2, y=>4, z=>0)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = x**3 + 4*x*y - z\n    >>> expr.subs([(x, 2), (y, 4), (z, 0)])\n    40","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"It is often useful to combine this with a list comprehension to do a large set of similar replacements all at once.  For example, say we had x^4 - 4x^3 + 4x^2 - 2x + 3 and we wanted to replace all instances of x that have an even power with y, to get y^4 - 4x^3 + 4y^2 - 2x + 3.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe use pairs notation, though tuples could also be used","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = x^4 - 4x^3 + 4x^2 - 2x + 3\nreplacements = [x^i => y^i for i in 0:4 if iseven(i)]\nsubs(expr, replacements...)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = x**4 - 4*x**3 + 4*x**2 - 2*x + 3\n    >>> replacements = [(x**i, y**i) for i in range(5) if i % 2 == 0]\n    >>> expr.subs(replacements)\n    -4*x**3 - 2*x + y**4 + 4*y**2 + 3","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/#Converting-Strings-to-SymPy-Expressions","page":"Basic operations","title":"Converting Strings to SymPy Expressions","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The sympify function (that's sympify, not to be confused with simplify) can be used to convert strings into SymPy expressions.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe can't use 3x (literal multiplication) as it isn't parsed correctly. We do not need to use a rational (e.g. 1//2), as that is parsed as desired.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"str_expr = \"x^3 + 3*x - 1/2\"\nexpr = sympify(str_expr)\nsubs(expr, x=>2)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> str_expr = \"x**2 + 3*x - 1/2\"\n    >>> expr = sympify(str_expr)\n    >>> expr\n    x**2 + 3*x - 1/2\n    >>> expr.subs(x, 2)\n    19/2","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"warning: Warning\nsympify uses eval.  Don't use it on unsanitized input.","category":"page"},{"location":"Tutorial/basic_operations/#evalf","page":"Basic operations","title":"evalf","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To evaluate a numerical expression into a floating point number, use evalf.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe need to wrap 8 in Sym otherwise, sqrt will dispatch to the base function in Julia. Also, we could use N(expr) to get a Julia value, as evalf returns a symbolic value.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = sqrt(Sym(8))\nexpr.evalf()","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = sqrt(8)\n    >>> expr.evalf()\n    2.82842712474619","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"SymPy can evaluate floating point expressions to arbitrary precision.  By default, 15 digits of precision are used, but you can pass any number as the argument to evalf.  Let's compute the first 100 digits of \\pi.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe use PI of Sym(pi) to express the symbolic value of pi.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"PI.evalf(100)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> pi.evalf(100)\n    3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To numerically evaluate an expression with a Symbol at a point, we might use subs followed by evalf, but it is more efficient and numerically stable to pass the substitution to evalf using the subs flag, which takes a dictionary of Symbol: point pairs.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nA Julia Dict can be used when the underlying sympy method expects a Python dict.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"expr = cos(2x)\nexpr.evalf(subs=Dict(x=>2.4))","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> expr = cos(2*x)\n    >>> expr.evalf(subs={x: 2.4})\n    0.0874989834394464","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"Sometimes there are roundoff errors smaller than the desired precision that remain after an expression is evaluated. Such numbers can be removed at the user's discretion by setting the chop flag to True.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWe don't use the reserved name one, as it is a base function name in Julia","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"o = cos(Sym(1))^2 + sin(Sym(1))^2\n(o-1).evalf()\n(o - 1).evalf(chop=true)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> one = cos(1)**2 + sin(1)**2\n    >>> (one - 1).evalf()\n    -0.e-124\n    >>> (one - 1).evalf(chop=True)\n    0","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/#lambdify","page":"Basic operations","title":"lambdify","text":"","category":"section"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"subs and evalf are good if you want to do simple evaluation, but if you intend to evaluate an expression at many points, there are more efficient ways.  For example, if you wanted to evaluate an expression at a thousand points, using SymPy would be far slower than it needs to be, especially if you only care about machine precision.  Instead, you should use libraries like NumPy and SciPy.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"The easiest way to convert a SymPy expression to an expression that can be numerically evaluated is to use the lambdify function.  lambdify acts like a lambda function, except it converts the SymPy names to the names of the given numerical library, usually NumPy.  For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nThe lambdify function does not use sympy's lambdify and has room for improvement, as compared to that in the Symbolics suite.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"a = 0:9\nexpr = sin(x)\nfn = lambdify(expr)\nfn.(a)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> import numpy # doctest:+SKIP\n    >>> a = numpy.arange(10) # doctest:+SKIP\n    >>> expr = sin(x)\n    >>> f = lambdify(x, expr, \"numpy\") # doctest:+SKIP\n    >>> f(a) # doctest:+SKIP\n    [ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427\n     -0.2794155   0.6569866   0.98935825  0.41211849]","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"warning: Warning\nlambdify uses eval.  Don't use it on unsanitized input.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"You can use other libraries than NumPy. For example, to use the standard library math module, use \"math\".","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nThe library option is not available though some function equivalences may be needed","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"fn(0.1)","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> f = lambdify(x, expr, \"math\")\n    >>> f(0.1)\n    0.0998334166468","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"To use lambdify with numerical libraries that it does not know about, pass a dictionary of sympy_name:numerical_function pairs.  For example","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"tip: Julia differences\nWhile passing in a map of function values is supported, creating an arbitray function is not. In Symbolics one can @register a function, this could be added.","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"nothing","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"    >>> def mysin(x):\n    ...     \"\"\"\n    ...     My sine. Note that this is only accurate for small x.\n    ...     \"\"\"\n    ...     return x\n    >>> f = lambdify(x, expr, {\"sin\":mysin})\n    >>> f(0.1)\n    0.1","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"</details>","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"","category":"page"},{"location":"Tutorial/basic_operations/","page":"Basic operations","title":"Basic operations","text":"note: TODO\nWrite an advanced numerics section","category":"page"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SymPyCore]","category":"page"},{"location":"reference/#SymPyCore.sympy_plotting","page":"Reference/API","title":"SymPyCore.sympy_plotting","text":"Plotting of symbolic objects.\n\nThe Plots package provide a uniform interface to many of Julia's plotting packages. SymPy plugs into Plots' \"recipes.\"\n\nThe basic goal is that when Plots provides an interface for function objects, this package extends the interface to symbolic expressions.\n\nIn particular:\n\nplot(ex::Sym, a, b; kwargs...) will plot a function evaluating ex over [a,b]\n\nExample. Here we use the default backend for Plots to make a plot:\n\nusing Plots\n@syms x\nplot(x^2 - 2x, 0, 4)\n\nplot(ex1, ex2, a, b; kwargs...) will plot the two expressions in a parametric plot over the interval [a,b].\n\nExample:\n\n@syms x\nplot(sin(2x), cos(3x), 0, 4pi) ## also\n\nFor a few backends (those that support :path3d) a third symbolic expression may be added to have a 3d parametric plot rendered:\n\nplot(sin(x), cos(x), x, 0, 4pi) # helix in 3d\n\nplot(xs, ys, expression) will make a contour plot (for many backends).\n\n@syms x y\nplot(range(0,stop=5, length=50), range(0,stop=5, length=50), x*y)\n\nTo plot the surface  z=ex(x,y) over a region we have Plots.surface. For example,\n\n@syms x y\nsurface(-5:5, -5:5, 25 - x^2 - y^2)\n\nTo plot two or more functions at once, the style plot([ex1, ex2], a, b) does not work. Rather, use   plot(ex1, a, b); plot!(ex2), as in:\n\n@syms x\nplot(sin(x), 0, 2pi)\nplot!(cos(x))\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SymPyCore.Differential","page":"Reference/API","title":"SymPyCore.Differential","text":"Differential(x)\n\nUse to find (partial) derivatives.\n\nExample\n\n@syms x y u()\nDx = Differential(x)\nDx(u(x,y))  # resolves to diff(u(x,y),x)\nDx(u)       # will evaluate diff(u(x), x)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPyCore.Doc","page":"Reference/API","title":"SymPyCore.Doc","text":"SymPy.Doc(f::Symbol, [module=sympy])\n\nReturn docstring of f found within the specified module.\n\nExamples\n\nSymPy.Doc(:sin)\nSymPy.Doc(:det, sympy.matrices)\n## add module to query\nSymPy.pyimport_conda(\"sympy.crypto.crypto\", \"sympy\")\nSymPy.Doc(:padded_key, sympy.crypto)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPyCore.Introspection","page":"Reference/API","title":"SymPyCore.Introspection","text":" Introspection\n\nStruct holding functins used to inspect an object\n\nIntrospection.func: Return pointer to Python function.\nIntrospection.operation: Return Julia generic function for given underlying function\nIntrospection.funcname: Returns name of function\nIntrospection.args: Returns arguments for expression or empty tuple\nIntrospection.arguments: Return arguments\nIntrospection.istree: Check if object is an expression (with operation and arguments) or not\nIntrospection.class: Returns __class__ value\nIntrospection.classname: Returns __class__ value as a string\nIntrospection.similarterm: Create a similar term\n\nInvariant:\n\nAs args returns symbolic objects, this becomes: every well-formed SymPy expression ex must either have length(args(ex)) == 0 or func(ex)(↓(args(ex))...) = ex.\n\nUsing the methods designed for SymbolicUtils usage, this becomes every expression one of !istree(ex)  or operation(ex)(args(ex)...) == ex should hold.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPyCore.Sym","page":"Reference/API","title":"SymPyCore.Sym","text":"Sym{T}\n\nMain wrapper for symbolic Python objects.\n\nThis is useful for dispatching methods for generic functions. Sym is also used to make symbolic values, in particular numeric values can be made into symbolic values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPyCore.SymFunction","page":"Reference/API","title":"SymPyCore.SymFunction","text":"SymFunction\n\nA type and constructor to create symbolic functions. Such objects can be used for specifying differential equations. The macro @syms is also available for constructing SymFunctions (@syms f())\n\nExamples:\n\njulia> using SymPyPythonCall\n\njulia> @syms t, v(); # recommended way to create a symbolic function\n\njulia> u = SymFunction(\"u\") # alternate\nu\n\njulia> diff(v(t), t) |> show\nDerivative(v(t), t)\n\nExtended help\n\nFor symbolic functions not wrapped in the SymFunction type, the sympy.Function constructor can be used, as can the symbols function to construct symbolic functions (F=sympy.Function(\"F\", real=true); F = sympy.symbols(\"F\", cls=sympy.Function, real=true)).\n\njulia> @syms u(), v()::real, t\n(u, v, t)\n\njulia> sqrt(u(t)^2), sqrt(v(t)^2) # real values have different simplification rules\n(sqrt(u(t)^2), Abs(v(t)))\n\n\nSuch functions are undefined functions in SymPy, and can be used symbolically, such as with taking derivatives:\n\njulia> @syms x y u()\n(x, y, u)\n\njulia> diff(u(x), x) |> show\nDerivative(u(x), x)\n\njulia> diff(u(x, y), x) |> show\nDerivative(u(x, y), x)\n\nHere is one way to find the second derivative of an inverse function to f, utilizing the SymFunction class and the convenience Differential function:\n\njulia> @syms f() f⁻¹() x;\n\njulia> D = Differential(x) # ∂(f) is diff(f(x),x)\nDifferential(x)\n\njulia> D² = D∘D\nDifferential(x) ∘ Differential(x)\n\njulia> u1 = only(solve(D((f⁻¹∘f)(x))  ~ 1, D(f⁻¹)(f(x)))); show(u1)\n1/Derivative(f(x), x)\n\njulia> u2 = only(solve(D²((f⁻¹∘f)(x)) ~ 0, D²(f⁻¹)(f(x)))); show(u2)\n-Derivative(f(x), (x, 2))*Derivative(f⁻¹(f(x)), f(x))/Derivative(f(x), x)^2\n\njulia> u2(D(f⁻¹)(f(x)) => u1) |> show # f''/[f']^3\n-Derivative(f(x), (x, 2))/Derivative(f(x), x)^3\n\n\n\n\n\n","category":"type"},{"location":"reference/#SymPyCore.SymbolicCallable","page":"Reference/API","title":"SymPyCore.SymbolicCallable","text":"SymbolicCallable\n\nWrapper for python objects with a __call__ method. This is used by sympy.λ to call the underlying λ function without the user needing to manually convert Julia objects into Python objects and back.\n\nnote: Note\nThere are some times where this doesn't work well, and using sympy.o.λ along with ↓ and ↑ will work.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:~-Tuple{Number, SymPyCore.SymbolicObject}","page":"Reference/API","title":"Base.:~","text":"lhs ~ rhs\n\nSpecify an equation.\n\nAlternative syntax to Eq(lhs, rhs) or lhs ⩵ rhs (\\Equal[tab]). Notation borrowed from Symbolics.jl.\n\nSee rhs or lhs to extract the two sides.\n\nInequalities may be defined using other functions imported from CommonEq.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.match-Tuple{SymPyCore.Sym, SymPyCore.Sym, Vararg{Any}}","page":"Reference/API","title":"Base.match","text":"match(pattern, expression, ...)\n\nMatch a pattern against an expression; returns a dictionary of matches.\n\nIf a match is unsuccesful, returns an empty dictionary. (SymPy returns \"nothing\")\n\nThe order of the arguments follows Julia's match function, not sympy.match, which can be used directly, otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.replace-Tuple{SymPyCore.Sym, SymPyCore.Sym, Function}","page":"Reference/API","title":"Base.replace","text":"replace(expression, pattern, value, ...)\nreplace(expression, pattern => value; kwargs...)\n\nIn the expression replace a mathcing pattern with the value. Returns the modified expression.\n\nExtended help\n\nFrom: SymPy Docs\n\nTraverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to false. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is true, then the match will only succeed if non-zero values are received for each Wild that appears in the match pattern.\n\nDifferences from SymPy:\n\n\"types\" are specified via calling func on the head of an expression: func(sin(x)) -> sin, or directly through sympy.sin\nfunctions are only supported by calling into the glue package.\n\nExamples (from the SymPy docs)\n\njulia> using SymPyPythonCall\n\n\njulia> @syms x, y, z\n(x, y, z)\n\njulia> f = log(sin(x)) + tan(sin(x^2)); show(f)\nlog(sin(x)) + tan(sin(x^2))\n\n\n\"type\" -> \"type\"\n\nTypes are specified through func:\n\njulia> func = Introspection.func\n#399 (generic function with 1 method)\n\njulia> replace(f, func(sin(x)), func(cos(x))) |> show # type -> type\nlog(cos(x)) + tan(cos(x^2))\n\n\nThe value sympy.sin does not work, as it is wrapped. Using ↓(sympy).sin will work:\n\njulia> replace(f, ↓(sympy).sin, ↓(sympy).cos)\nlog(cos(x)) + tan(cos(x^2))\n\n\"pattern\" -> \"expression\"\n\nUsing \"Wild\" variables allows a pattern to be replaced by an expression:\n\njulia> a, b = Wild(\"a\"), Wild(\"b\")\n(a_, b_)\n\njulia> replace(f, sin(a), tan(2a)) |> show\nlog(tan(2*x)) + tan(tan(2*x^2))\n\njulia> replace(f, sin(a), tan(a/2)) |> show\nlog(tan(x/2)) + tan(tan(x^2/2))\n\njulia> f.replace(sin(a), a) |> show\nlog(x) + tan(x^2)\n\njulia> (x*y).replace(a*x, a)\ny\n\n\nIn the SymPy docs we have:\n\nMatching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols.\"\n\njulia> replace(2x + y, a*x+b, b-a)  # y - 2\ny - 2\n\njulia> replace(2x + y, a*x+b, b-a, exact=false) |> show\ny + 2/x\n\n\"type\" -> \"function\"\n\nTo replace with a more complicated function, requires some assistance from Python, as an anonymous function must be defined witin Python, not Julia. This is how it might be done:\n\njulia> import PyCall\n\njulia> ## Anonymous function a -> sin(2a)\n       PyCall.py\"\"\"\n       from sympy import sin, Mul\n       def anonfn(*args):\n           return sin(2*Mul(*args))\n       \"\"\")\n\n\njulia> replace(f, sympy.sin, PyCall.py\"anonfn\")\n                   ⎛   ⎛   2⎞⎞\nlog(sin(2⋅x)) + tan⎝sin⎝2⋅x ⎠⎠\n\n\"pattern\" -> \"func\"\n\nThe function is redefined, as a fixed argument is passed:\n\njulia> PyCall.py\"\"\"\n       from sympy import sin\n       def anonfn(a):\n           return sin(2*a)\n       \"\"\"\n\njulia> replace(f, sin(a), PyCall.py\"anonfn\")\n                   ⎛   ⎛   2⎞⎞\nlog(sin(2⋅x)) + tan⎝sin⎝2⋅x ⎠⎠\n\n\"func\" -> \"func\"\n\n\njulia> PyCall.py\"\"\"\n       def fn1(expr):\n           return expr.is_Number\n\n       def fn2(expr):\n           return expr**2\n       \"\"\"\n\njulia> replace(2*sin(x^3), PyCall.py\"fn1\", PyCall.py\"fn2\")\n     ⎛ 9⎞\n4⋅sin⎝x ⎠\n\njulia> PyCall.py\"\"\"\n       def fn1(x):\n           return x.is_Mul\n\n       def fn2(x):\n           return 2*x\n       \"\"\"\n\njulia> replace(x*(x*y + 1), PyCall.py\"fn1\", PyCall.py\"fn2\")\n2⋅x⋅(2⋅x⋅y + 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CommonSolve.solve-Tuple{}","page":"Reference/API","title":"CommonSolve.solve","text":"solve\n\nUse solve to solve algebraic equations.\n\nExtended help\n\nExamples:\n\njulia> using SymPyPythonCall\n\n\njulia> @syms x y a b c d\n(x, y, a, b, c, d)\n\njulia> solve(x^2 + 2x + 1, x) # [-1]\n1-element Vector{Sym{PythonCall.Py}}:\n -1\n\njulia> solve(x^2 + 2a*x + a^2, x) # [-a]\n1-element Vector{Sym{PythonCall.Py}}:\n -a\n\njulia> u = solve([a*x + b*y-3, c*x + b*y - 1], [x,y]); show(u[x])\n2/(a - c)\n\nnote: Note\nA very nice example using solve is a blog entry on Napolean's theorem by Xing Shi Cai.\n\nnote: Systems\nUse a tuple, not a vector, of equations when there is more than one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.:↑-Tuple{SymPyCore.Sym}","page":"Reference/API","title":"SymPyCore.:↑","text":"↑(::SymbolicObject)\n\nMethod to lift a python object into a symbolic counterpart.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.:↓-Tuple{SymPyCore.SymbolicObject}","page":"Reference/API","title":"SymPyCore.:↓","text":"↓(::SymbolicObject)    ↓ₖ([kwargs...])\n\nThe \\downarrrow[tab] and \\downarrow[tab]\\_k[tab] operators push a symbolic object (or a container of symbolic objects) into a Python counterpart for passing to an underlying Python function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.Heaviside-Tuple{}","page":"Reference/API","title":"SymPyCore.Heaviside","text":"Heaviside\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.Permutation","page":"Reference/API","title":"SymPyCore.Permutation","text":"Permutation\nPermutationGroup\n\nGive access to the sympy.combinatorics.permutations module\n\nExample\n\njulia> using SymPyPythonCall\n\njulia> p = Permutation([1,2,3,0])\n(0 1 2 3)\n\njulia> p^2\n(0 2)(1 3)\n\njulia> p^2 * p^2\n()\n\nRubik's cube example from SymPy documentation\n\njulia> F = Permutation([(2, 19, 21, 8),(3, 17, 20, 10),(4, 6, 7, 5)])\n(2 19 21 8)(3 17 20 10)(4 6 7 5)\n\njulia> R = Permutation([(1, 5, 21, 14),(3, 7, 23, 12),(8, 10, 11, 9)])\n(1 5 21 14)(3 7 23 12)(8 10 11 9)\n\njulia> D = Permutation([(6, 18, 14, 10),(7, 19, 15, 11),(20, 22, 23, 21)])\n(6 18 14 10)(7 19 15 11)(20 22 23 21)\n\njulia> G = PermutationGroup(F,R,D);\n\njulia> G.order()\n3674160\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPyCore.PermutationGroup","page":"Reference/API","title":"SymPyCore.PermutationGroup","text":"Permutation\nPermutationGroup\n\nGive access to the sympy.combinatorics.permutations module\n\nExample\n\njulia> using SymPyPythonCall\n\njulia> p = Permutation([1,2,3,0])\n(0 1 2 3)\n\njulia> p^2\n(0 2)(1 3)\n\njulia> p^2 * p^2\n()\n\nRubik's cube example from SymPy documentation\n\njulia> F = Permutation([(2, 19, 21, 8),(3, 17, 20, 10),(4, 6, 7, 5)])\n(2 19 21 8)(3 17 20 10)(4 6 7 5)\n\njulia> R = Permutation([(1, 5, 21, 14),(3, 7, 23, 12),(8, 10, 11, 9)])\n(1 5 21 14)(3 7 23 12)(8 10 11 9)\n\njulia> D = Permutation([(6, 18, 14, 10),(7, 19, 15, 11),(20, 22, 23, 21)])\n(6 18 14 10)(7 19 15 11)(20 22 23 21)\n\njulia> G = PermutationGroup(F,R,D);\n\njulia> G.order()\n3674160\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPyCore.Wild-Tuple{Symbol}","page":"Reference/API","title":"SymPyCore.Wild","text":"Wild(x)\n\nCreate a \"wild card\" for pattern matching\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.apart-Tuple{}","page":"Reference/API","title":"SymPyCore.apart","text":"apart\n\nPartial fraction decomposition. See together. SymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.ask-Tuple{}","page":"Reference/API","title":"SymPyCore.ask","text":"ask\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.cancel-Tuple{}","page":"Reference/API","title":"SymPyCore.cancel","text":"cancel\n\nTake any rational expression and put it into the standard canonical form, pq. SymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.degree-Tuple{}","page":"Reference/API","title":"SymPyCore.degree","text":"degree\n\nReturn degree of expression in a given variable. Not exported.\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.doit-Tuple{T} where T<:SymPyCore.SymbolicObject","page":"Reference/API","title":"SymPyCore.doit","text":"doit\n\nEvaluates objects that are not evaluated by default. Alias for object method.\n\nExtended help\n\nExamples:\n\njulia> using SymPyPythonCall\n\njulia> @syms x f()\n(x, f)\n\njulia> D = Differential(x)\nDifferential(x)\n\njulia> df = D(f(x)); show(df)\nDerivative(f(x), x)\n\njulia> dfx = subs(df, (f(x), x^2));  show(dfx)\nDerivative(x^2, x)\n\njulia> doit(dfx)\n2⋅x\n\nSet deep=true to apply doit recursively to force evaluation of nested expressions:\n\njulia> @syms g()\n(g,)\n\njulia> dgfx = g(dfx);  show(dgfx)\ng(Derivative(x^2, x))\n\njulia> doit(dgfx) |> show\ng(Derivative(x^2, x))\n\njulia> doit(dgfx, deep=true)\ng(2⋅x)\n\nThere is also a curried form of doit:\n\njulia> dfx |> doit\n2⋅x\n\njulia> dgfx |> doit(deep=true)\ng(2⋅x)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.dsolve-Tuple{}","page":"Reference/API","title":"SymPyCore.dsolve","text":"dsolve(eqn, var, args..,; ics=nothing, kwargs...)\n\nCalls sympy.dsolve.\n\nics: The initial conditions are specified with a dictionary or nothing\n\nExtended help\n\nExample:\n\njulia> using SymPyPythonCall\n\njulia> @syms α, x, f(), g()\n(α, x, f, g)\n\njulia> ∂ = Differential(x)\nDifferential(x)\n\njulia> eqn = ∂(f(x)) ~ α * x; show(eqn)\nEq(Derivative(f(x), x), x*α)\n\njulia> dsolve(eqn) |> show\nEq(f(x), C1 + x^2*α/2)\n\njulia> dsolve(eqn(α=>2); ics=Dict(f(0)=>1))\n        2\nf(x) = x  + 1\n\njulia> eqn = ∂(∂(f(x))) ~ -f(x);\n\njulia> dsolve(eqn)\nf(x) = C₁⋅sin(x) + C₂⋅cos(x)\n\njulia> dsolve(eqn; ics = Dict(f(0)=>1, ∂(f)(0) => -1))\nf(x) = -sin(x) + cos(x)\n\njulia> eqn = ∂(∂(f(x))) - f(x) - exp(x);\n\njulia> dsolve(eqn, ics=Dict(f(0) => 1, f(1) => Sym(1//2))) |> show\nEq(f(x), (x/2 + (-exp(2) - 2 + E)/(-2 + 2*exp(2)))*exp(x) + (-E + 3*exp(2))*exp(-x)/(-2 + 2*exp(2)))\n\nnote: Systems\nUse a tuple, not a vector, of equations when there is more than one.\n\njulia> @syms x() y() t g\n(x, y, t, g)\n\njulia> ∂ = Differential(t)\nDifferential(t)\n\njulia> eqns = (∂(x(t)) ~ y(t), ∂(y(t)) ~ x(t));\n\njulia> dsolve(eqns)\n2-element Vector{Sym{PythonCall.Py}}:\n Eq(x(t), -C1*exp(-t) + C2*exp(t))\n  Eq(y(t), C1*exp(-t) + C2*exp(t))\n\njulia> dsolve(eqns, ics = Dict(x(0) => 1, y(0) => 2))\n2-element Vector{Sym{PythonCall.Py}}:\n Eq(x(t), 3*exp(t)/2 - exp(-t)/2)\n Eq(y(t), 3*exp(t)/2 + exp(-t)/2)\n\njulia> eqns = (∂(∂(x(t))) ~ 0, ∂(∂(y(t))) ~ -g)\n(Eq(Derivative(x(t), (t, 2)), 0), Eq(Derivative(y(t), (t, 2)), -g))\n\njulia> dsolve(eqns)  # can't solve for initial conditions though! (NotAlgebraic)\n2-element Vector{Sym{PythonCall.Py}}:\n           x(t) = C₁ + C₂⋅t\n Eq(y(t), C3 + C4*t - g*t^2/2)\n\njulia> @syms t x() y()\n(t, x, y)\n\njulia> eq = (∂(x)(t) ~ x(t)*y(t)*sin(t), ∂(y)(t) ~ y(t)^2 * sin(t));\n\njulia> dsolve(eq)\nSet{Sym{PythonCall.Py}} with 2 elements:\n  Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t)))\n  Eq(y(t), -1/(C1 - cos(t)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.expand-Tuple{}","page":"Reference/API","title":"SymPyCore.expand","text":"expand\n\nExpand a symbolic expression. See factor.\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.factor-Tuple{}","page":"Reference/API","title":"SymPyCore.factor","text":"factor\n\nFactor an expression. See expand. SymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.free_symbols-Union{Tuple{S}, Tuple{T}} where {T, S<:SymPyCore.SymbolicObject{T}}","page":"Reference/API","title":"SymPyCore.free_symbols","text":"free_symbols(ex)\nfree_symbols(ex::Vector{Sym})\n\nReturn vector of free symbols of expression or vector of expressions. The results are orderded by sortperm(string.(fs)).\n\nExample:\n\njulia> using SymPyPythonCall\n\njulia> @syms x y z a\n(x, y, z, a)\n\njulia> free_symbols(2*x + a*y) # [a, x, y]\n3-element Vector{Sym{PythonCall.Py}}:\n a\n x\n y\n\n\njulia> free_symbols([x^2, x^2 - 2x*y + y^2])\n2-element Vector{Sym{PythonCall.Py}}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.funcname","page":"Reference/API","title":"SymPyCore.funcname","text":"Introspection.funcname(x)\n\nReturn name or \"\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPyCore.integrate-Tuple{}","page":"Reference/API","title":"SymPyCore.integrate","text":"integrate\n\nIntegrate an expression. Can return definite or indefinite integral.\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.lambdify","page":"Reference/API","title":"SymPyCore.lambdify","text":"lambdify(ex, vars=free_symbols();\n         fns=Dict(), values=Dict, use_julia_code=false,\n         invoke_latest=true)\n\nTake a symbolic expression and return a Julia function or expression to build a function.\n\nex::Sym a symbolic expression with 0, 1, or more free symbols\nvars a container of symbols to use for the function arguments. The default is free_symbols which has a specific ordering. Specifying vars allows this default ordering of arguments to be customized. If vars is empty, such as when the symbolic expression has no free symbols, a variable arg constant function is returned.\nfns::Dict, vals::Dict: Dictionaries that allow customization of the function that walks the expression ex and creates the corresponding AST for a Julia expression. See SymPy.fn_map and SymPy.val_map for the default mappings of sympy functions and values into Julia's AST.\nuse_julia_code::Bool: use SymPy's conversion to an expression, the default is false\ninvoke_latest=true: if true will call eval and Base.invokelatest to return a function that should not have any world age issue. If false will return a Julia expression that can be evaled to produce a function.\n\nExample:\n\njulia> using SymPyPythonCall\n\njulia> @syms x y z\n(x, y, z)\n\njulia> ex = x^2 * sin(x)\n 2\nx ⋅sin(x)\n\njulia> fn = lambdify(ex);\n\njulia> fn(pi)\n0.0\n\njulia> ex = x + 2y + 3z\nx + 2⋅y + 3⋅z\n\njulia> fn = lambdify(ex);\n\njulia> fn(1,2,3) # order is by free_symbols\n14\n\njulia> ex(x=>1, y=>2, z=>3)\n14\n\njulia> fn = lambdify(ex, (y,x,z));\n\njulia> fn(1,2,3)\n13\n\nnote: Note\nThe default produces slower functions due to the calls to eval and Base.invokelatest.  In the following g2 (which, as seen, requires additional work to compute) is as fast as calling f (on non symbolic types), whereas g1 is an order of magnitude slower in this example.\n\njulia> @syms x\n(x,)\n\njulia> f(x) = exp(cot(x))\nf (generic function with 1 method)\n\njulia> g1 = lambdify(f(x));\n\njulia> ex = lambdify(f(x), invoke_latest=false);\n\njulia> @eval g2(x) = ($ex)(x)\ng2 (generic function with 1 method)\n\nAn alternative, say, is to use GeneralizedGenerated's mk_function, as follows:\n\njulia> using GeneralizedGenerated\n\njulia> body = convert(Expr, f(x))\n:(exp(cot(x)))\n\njulia> g3 = mk_function((:x,), (), body)\nfunction = (x;) -> begin\n    (Main).exp((Main).cot(x))\nend\n\nThis function will be about 2-3 times slower than f.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPyCore.lhs","page":"Reference/API","title":"SymPyCore.lhs","text":"rhs(eqn)\nlhs(eqn)\n\nReturns right (or left) side of an equation object. Wrappers around eqn.rhs() and eqn.lhs().\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPyCore.linsolve-Tuple{}","page":"Reference/API","title":"SymPyCore.linsolve","text":"linsolve\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.nonlinsolve-Tuple{}","page":"Reference/API","title":"SymPyCore.nonlinsolve","text":"nonlinsolve\n\nSymPy documentation\n\nnote: Systems\nUse a tuple, not a vector, of equations when there is more than one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.nroots-Tuple{}","page":"Reference/API","title":"SymPyCore.nroots","text":"nroots\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.nsolve-Tuple{}","page":"Reference/API","title":"SymPyCore.nsolve","text":"nsolve\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.real_roots-Tuple{}","page":"Reference/API","title":"SymPyCore.real_roots","text":"real_roots\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.refine-Tuple{}","page":"Reference/API","title":"SymPyCore.refine","text":"refine\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.rhs","page":"Reference/API","title":"SymPyCore.rhs","text":"rhs(eqn)\nlhs(eqn)\n\nReturns right (or left) side of an equation object. Wrappers around eqn.rhs() and eqn.lhs().\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymPyCore.roots-Tuple{}","page":"Reference/API","title":"SymPyCore.roots","text":"roots\n\nFind roots of a polynomial. Not exported, so needs to be qualified, as in sympy.roots.\n\nExample\n\njulia> sympy.roots(x^2 - 2x - 3)\nDict{} with 2 entries:\n  3  => 1\n  -1 => 1\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.series-Tuple{}","page":"Reference/API","title":"SymPyCore.series","text":"series\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.simplify-Tuple{Any, Vararg{Any}}","page":"Reference/API","title":"SymPyCore.simplify","text":"simplify\n\nSymPy has dozens of functions to perform various kinds of simplification. There is also one general function called simplify that attempts to apply all of these functions in an intelligent way to arrive at the simplest form of an expression. (See Simplification for details on simplify and other related functionality). Other simplification functions are available through the sympy object.\n\nFor non-symbolic expressions, simplify returns its first argument.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.simplify-Tuple{}","page":"Reference/API","title":"SymPyCore.simplify","text":"simplify\n\nSimplify symbolic expressions.\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.solveset-Tuple{}","page":"Reference/API","title":"SymPyCore.solveset","text":"solveset\n\nLike solve but returns a set object. Finite sets are returned as Set objects in Julia. Infinite sets must be queried.\n\nExample\n\njulia> @syms x\n(x,)\n\njulia> u = solveset(sin(x) ~ 1//2, x)\n⎧        5⋅π │      ⎫   ⎧        π │      ⎫\n⎨2⋅n⋅π + ───  │ n ∊ ℤ⎬ ∪ ⎨2⋅n⋅π + ─ │ n ∊ ℤ⎬\n⎩         6  │      ⎭   ⎩        6 │      ⎭\n\njulia> intersect(u, sympy.Interval(0, 2PI))\nSet{Sym} with 2 elements:\n  pi/6\n  5*pi/6\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.subs-Union{Tuple{T}, Tuple{T, Tuple{Any, Any}}} where T<:SymPyCore.SymbolicObject","page":"Reference/API","title":"SymPyCore.subs","text":"subs is used to subsitute a value in an expression with another value. Examples:\n\njulia> using SymPyPythonCall\n\n\n\njulia> @syms x,y\n(x, y)\n\njulia> ex = (x-y)*(x+2y)\n(x - y)⋅(x + 2⋅y)\n\njulia> subs(ex, (y, y^2)) |> show\n(x - y^2)*(x + 2*y^2)\n\njulia> subs(ex, (x,1), (y,2))\n-5\n\njulia> subs(ex, (x,y^3), (y,2))\n72\n\njulia> subs(ex, y, 3)\n(x - 3)⋅(x + 6)\n\nThere is a curried form of subs to use with the chaining |> operator\n\njulia> ex |> subs(x,ℯ)\n(ℯ - y)⋅(2⋅y + ℯ)\n\nThe use of pairs gives a convenient alternative:\n\njulia> subs(ex, x=>1, y=>2)\n-5\n\njulia> ex |> subs(x=>1, y=>2)\n-5\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.summation-Tuple{}","page":"Reference/API","title":"SymPyCore.summation","text":"summation\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.symbols-Tuple{}","page":"Reference/API","title":"SymPyCore.symbols","text":"symbols(arg; kwargs...)\n\nConstruct symbolic values using sympy.symbols.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.together-Tuple{}","page":"Reference/API","title":"SymPyCore.together","text":"together\n\nCombine rational expressions. See apart.\n\nSymPy documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SymPyCore.walk_expression-Tuple{Any}","page":"Reference/API","title":"SymPyCore.walk_expression","text":"walk_expression(ex; values=Dict(), fns=Dict())\n\nConvert a symbolic SymPy expression into a Julia expression. This is needed to use functions in external packages in lambdified functions.\n\nExtended help\n\nExample\n\nusing SymPy\n@syms x y\nex = sympy.hyper((2,2),(3,3),x) * y\n\nCalling lambdify(ex) will fail to make a valid function, as hyper is implemented in HypergeometricFunctions.pFq. So, we have:\n\nusing HypergeometricFunctions\nd = Dict(\"hyper\" => :pFq)\nbody = SymPy.walk_expression(ex, fns=d)\nsyms = Symbol.(free_symbols(ex))\nfn = eval(Expr(:function, Expr(:call, gensym(), syms...), body));\nfn(1,1) # 1.6015187080185656\n\n\n\n\n\n","category":"method"},{"location":"Tutorial/preliminaries/#Preliminaries","page":"Preliminaries","title":"Preliminaries","text":"","category":"section"},{"location":"Tutorial/preliminaries/","page":"Preliminaries","title":"Preliminaries","text":"tip: Julia differences\nThis is a translation of the Python tutorial for SymPy, described below, to use the Julie intefaces to SymPy provided in SymPyCore.","category":"page"},{"location":"Tutorial/preliminaries/","page":"Preliminaries","title":"Preliminaries","text":"This tutorial assumes that the reader already knows the basics of the Python programming language.  If you do not, the official Python tutorial is excellent.","category":"page"},{"location":"Tutorial/preliminaries/","page":"Preliminaries","title":"Preliminaries","text":"This tutorial assumes a decent mathematical background.  Most examples require knowledge lower than a calculus level, and some require knowledge at a calculus level.  Some of the advanced features require more than this. If you come across a section that uses some mathematical function you are not familiar with, you can probably skip over it, or replace it with a similar one that you are more familiar with.  Or look up the function on Wikipedia and learn something new.  Some important mathematical concepts that are not common knowledge will be introduced as necessary.","category":"page"},{"location":"Tutorial/preliminaries/#Installation","page":"Preliminaries","title":"Installation","text":"","category":"section"},{"location":"Tutorial/preliminaries/","page":"Preliminaries","title":"Preliminaries","text":"You will need to install SymPy first.  See the installation guide.","category":"page"},{"location":"Tutorial/preliminaries/#Exercises","page":"Preliminaries","title":"Exercises","text":"","category":"section"},{"location":"Tutorial/preliminaries/","page":"Preliminaries","title":"Preliminaries","text":"This tutorial was the basis for a tutorial given at the 2013 SciPy conference in Austin, TX.  The website for that tutorial is here. It has links to videos, materials, and IPython notebook exercises.  The IPython notebook exercises in particular are recommended to anyone going through this tutorial.","category":"page"},{"location":"Tutorial/printing/#Printing","page":"printing","title":"Printing","text":"","category":"section"},{"location":"Tutorial/printing/","page":"printing","title":"printing","text":"tip: Julia differences\nThe default show method in Julia uses text-based sstr for printing. The show method for LaTeX is different, utilizing the latex command described herein. There isn't much at all provided within SymPyCore","category":"page"},{"location":"Tutorial/printing/","page":"printing","title":"printing","text":"[Sympy printing](https://docs.sympy.org/latest/tutorials/intro-tutorial/printing.html_","category":"page"},{"location":"Tutorial/matrices/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> from sympy import *\n    >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To make a matrix in SymPy, use the Matrix object.  A matrix is constructed by providing a list of row vectors that make up the matrix.  For example, to construct the matrix","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"leftbeginarraycc1  -13  40  2endarrayright","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"use","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nWe have two ways to store matrices – as a matrix of symbolic objects or as a symbolic wrapper around the underlying Python Matrix objects. The former gives access to Julia's common idioms, the latter access to SymPy's methods for matrices. ↓(M) takes a matrix of symbolic values and returns a SymPy matrix object, ↑(𝑀) does the reverse. The getindex notation for a matrix of symbolic values is overridden to call the SymPy method.  Matrices of symbolic objects can be created by adding Sym as a type hint; or more commonly occur by promotion when one or more entries is symbolic.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Sym[1 -1; 3 4; 0 2]\n[Sym(1) -1; 3 4; 0 2]","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> Matrix([[1, -1], [3, 4], [0, 2]])\n    ⎡1  -1⎤\n    ⎢     ⎥\n    ⎢3  4 ⎥\n    ⎢     ⎥\n    ⎣0  2 ⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To make it easy to make column vectors, a list of elements is considered to be a column vector.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThis is different in Julia, as column syntax does not use commas.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Sym[1 2 3]","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> Matrix([1, 2, 3])\n    ⎡1⎤\n    ⎢ ⎥\n    ⎢2⎥\n    ⎢ ⎥\n    ⎣3⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Matrices are manipulated just like any other object in SymPy or Python.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThe resulting matrix is just a matrix with symbolic elements, so is manipulated like any other matrix","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M1 = Sym[1 2 3; 3 2 1]\nM2 = Sym[0, 1, 1]  # can't use N\nM1 * M2","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3], [3, 2, 1]])\n    >>> N = Matrix([0, 1, 1])\n    >>> M*N\n    ⎡5⎤\n    ⎢ ⎥\n    ⎣3⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"One important thing to note about SymPy matrices is that, unlike every other object in SymPy, they are mutable.  This means that they can be modified in place, as we will see below.  The downside to this is that Matrix cannot be used in places that require immutability, such as inside other SymPy expressions or as keys to dictionaries.  If you need an immutable version of Matrix, use ImmutableMatrix.","category":"page"},{"location":"Tutorial/matrices/#Basic-Operations","page":"Matrices","title":"Basic Operations","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Here are some basic operations on Matrix.","category":"page"},{"location":"Tutorial/matrices/#Shape","page":"Matrices","title":"Shape","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To get the shape of a matrix, use :func:~.shape() function.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nWe can use Julia generics or object mathods of sympy","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[1 2 3; -2 0 4]\nsize(M)\nM.shape","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> from sympy import shape\n    >>> M = Matrix([[1, 2, 3], [-2, 0, 4]])\n    >>> M\n    ⎡1   2  3⎤\n    ⎢        ⎥\n    ⎣-2  0  4⎦\n    >>> shape(M)\n    (2, 3)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Accessing-Rows-and-Columns","page":"Matrices","title":"Accessing Rows and Columns","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To get an individual row or column of a matrix, use row or col.  For example, M.row(0) will get the first row. M.col(-1) will get the last column.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nWe use standard Julia notation for array access","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M[1, :]\nM[:, end]","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M.row(0)\n    [1  2  3]\n    >>> M.col(-1)\n    ⎡3⎤\n    ⎢ ⎥\n    ⎣4⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Deleting-and-Inserting-Rows-and-Columns","page":"Matrices","title":"Deleting and Inserting Rows and Columns","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To delete a row or column, use row_del or col_del.  These operations will modify the Matrix in place.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThese mutation operations will work if the matrix is converted via  ↓ to an underlying Python matrix, but that is not illustrated here.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"nothing","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M.col_del(0)\n    >>> M\n    ⎡2  3⎤\n    ⎢    ⎥\n    ⎣0  4⎦\n    >>> M.row_del(1)\n    >>> M\n    [2  3]","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: TODO\nThis is a mess. See issue 6992.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To insert rows or columns, use row_insert or col_insert.  These operations do not operate in place.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nOne can use Julia idioms, but that is not illustrated","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"nothing","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M\n    [2  3]\n    >>> M = M.row_insert(1, Matrix([[0, 4]]))\n    >>> M\n    ⎡2  3⎤\n    ⎢    ⎥\n    ⎣0  4⎦\n    >>> M = M.col_insert(0, Matrix([1, -2]))\n    >>> M\n    ⎡1   2  3⎤\n    ⎢        ⎥\n    ⎣-2  0  4⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Unless explicitly stated, the methods mentioned below do not operate in place. In general, a method that does not operate in place will return a new Matrix and a method that does operate in place will return None.","category":"page"},{"location":"Tutorial/matrices/#Basic-Methods","page":"Matrices","title":"Basic Methods","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"As noted above, simple operations like addition, multiplication and power are done just by using +, *, and **.  To find the inverse of a matrix, just raise it to the -1 power.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M1, M2 = Sym[1 3; -2 3], Sym[0 3; 0 7]\nM1 + M2\nM1 * M2\n3*M1\nM1^2\ninv(M2)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 3], [-2, 3]])\n    >>> N = Matrix([[0, 3], [0, 7]])\n    >>> M + N\n    ⎡1   6 ⎤\n    ⎢      ⎥\n    ⎣-2  10⎦\n    >>> M*N\n    ⎡0  24⎤\n    ⎢     ⎥\n    ⎣0  15⎦\n    >>> 3*M\n    ⎡3   9⎤\n    ⎢     ⎥\n    ⎣-6  9⎦\n    >>> M**2\n    ⎡-5  12⎤\n    ⎢      ⎥\n    ⎣-8  3 ⎦\n    >>> M**-1\n    ⎡1/3  -1/3⎤\n    ⎢         ⎥\n    ⎣2/9  1/9 ⎦\n    >>> N**-1\n    Traceback (most recent call last):\n    ...\n    NonInvertibleMatrixError: Matrix det == 0; not invertible.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To take the transpose of a Matrix, use T.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nUse ' for the adjoint, transpose for transpose","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[1 2 3; 4 5 6]\ntranspose(M)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> M\n    ⎡1  2  3⎤\n    ⎢       ⎥\n    ⎣4  5  6⎦\n    >>> M.T\n    ⎡1  4⎤\n    ⎢    ⎥\n    ⎢2  5⎥\n    ⎢    ⎥\n    ⎣3  6⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Matrix-Constructors","page":"Matrices","title":"Matrix Constructors","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Several constructors exist for creating common matrices.  To create an identity matrix, use eye.  eye(n) will create an ntimes n identity matrix.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThis cnostructor is not exported, so needs to be qualified","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"sympy.eye(3)\nsympy.eye(4)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> eye(3)\n    ⎡1  0  0⎤\n    ⎢       ⎥\n    ⎢0  1  0⎥\n    ⎢       ⎥\n    ⎣0  0  1⎦\n    >>> eye(4)\n    ⎡1  0  0  0⎤\n    ⎢          ⎥\n    ⎢0  1  0  0⎥\n    ⎢          ⎥\n    ⎢0  0  1  0⎥\n    ⎢          ⎥\n    ⎣0  0  0  1⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To create a matrix of all zeros, use zeros.  zeros(n, m) creates an ntimes m matrix of 0 s.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThis is more idiomatically done with a type:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"zeros(Sym, 2, 3)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> zeros(2, 3)\n    ⎡0  0  0⎤\n    ⎢       ⎥\n    ⎣0  0  0⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Similarly, ones creates a matrix of ones.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"ones(Sym, 3, 4)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> ones(3, 2)\n    ⎡1  1⎤\n    ⎢    ⎥\n    ⎢1  1⎥\n    ⎢    ⎥\n    ⎣1  1⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To create diagonal matrices, use diag.  The arguments to diag can be either numbers or matrices.  A number is interpreted as a 1times 1 matrix. The matrices are stacked diagonally.  The remaining elements are filled with 0 s.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nWe qualify the use of diag, it is not exported","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"sympy.diag(1,2,3)\nsympy.diag(-1, ones(Sym, 2, 2), Sym[5,7,5])","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> diag(1, 2, 3)\n    ⎡1  0  0⎤\n    ⎢       ⎥\n    ⎢0  2  0⎥\n    ⎢       ⎥\n    ⎣0  0  3⎦\n    >>> diag(-1, ones(2, 2), Matrix([5, 7, 5]))\n    ⎡-1  0  0  0⎤\n    ⎢           ⎥\n    ⎢0   1  1  0⎥\n    ⎢           ⎥\n    ⎢0   1  1  0⎥\n    ⎢           ⎥\n    ⎢0   0  0  5⎥\n    ⎢           ⎥\n    ⎢0   0  0  7⎥\n    ⎢           ⎥\n    ⎣0   0  0  5⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Advanced-Methods","page":"Matrices","title":"Advanced Methods","text":"","category":"section"},{"location":"Tutorial/matrices/#Determinant","page":"Matrices","title":"Determinant","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To compute the determinant of a matrix, use det.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThis can be called using det (if the LinearAlgebra package is loaded) or as a method","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[1 0 1; 2 -1 3; 4 3 2]\nM.det()\nusing LinearAlgebra\ndet(M)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 0, 1], [2, -1, 3], [4, 3, 2]])\n    >>> M\n    ⎡1  0   1⎤\n    ⎢        ⎥\n    ⎢2  -1  3⎥\n    ⎢        ⎥\n    ⎣4  3   2⎦\n    >>> M.det()\n    -1","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#RREF","page":"Matrices","title":"RREF","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To put a matrix into reduced row echelon form, use rref.  rref returns a tuple of two elements. The first is the reduced row echelon form, and the second is a tuple of indices of the pivot columns.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[1 0 1 3; 2 3 4 7; -1 -3 -3 -4]\nM.rref()","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 0, 1, 3], [2, 3, 4, 7], [-1, -3, -3, -4]])\n    >>> M\n    ⎡1   0   1   3 ⎤\n    ⎢              ⎥\n    ⎢2   3   4   7 ⎥\n    ⎢              ⎥\n    ⎣-1  -3  -3  -4⎦\n    >>> M.rref()\n    ⎛⎡1  0   1    3 ⎤        ⎞\n    ⎜⎢              ⎥        ⎟\n    ⎜⎢0  1  2/3  1/3⎥, (0, 1)⎟\n    ⎜⎢              ⎥        ⎟\n    ⎝⎣0  0   0    0 ⎦        ⎠","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Note\nThe first element of the tuple returned by rref is of type Matrix. The second is of type tuple.","category":"page"},{"location":"Tutorial/matrices/#Nullspace","page":"Matrices","title":"Nullspace","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the nullspace of a matrix, use nullspace. nullspace returns a list of column vectors that span the nullspace of the matrix.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[1 2 3 0 0; 4 10 0 0 1]\nM.nullspace()","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 2, 3, 0, 0], [4, 10, 0, 0, 1]])\n    >>> M\n    ⎡1  2   3  0  0⎤\n    ⎢              ⎥\n    ⎣4  10  0  0  1⎦\n    >>> M.nullspace()\n    ⎡⎡-15⎤  ⎡0⎤  ⎡ 1  ⎤⎤\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎢⎢ 6 ⎥  ⎢0⎥  ⎢-1/2⎥⎥\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎢⎢ 1 ⎥, ⎢0⎥, ⎢ 0  ⎥⎥\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎢⎢ 0 ⎥  ⎢1⎥  ⎢ 0  ⎥⎥\n    ⎢⎢   ⎥  ⎢ ⎥  ⎢    ⎥⎥\n    ⎣⎣ 0 ⎦  ⎣0⎦  ⎣ 1  ⎦⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Columnspace","page":"Matrices","title":"Columnspace","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the columnspace of a matrix, use columnspace. columnspace returns a list of column vectors that span the columnspace of the matrix.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[1 1 2; 2 1 3; 3 1 4]\nM.columnspace()","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[1, 1, 2], [2 ,1 , 3], [3 , 1, 4]])\n    >>> M\n    ⎡1  1  2⎤\n    ⎢       ⎥\n    ⎢2  1  3⎥\n    ⎢       ⎥\n    ⎣3  1  4⎦\n    >>> M.columnspace()\n    ⎡⎡1⎤  ⎡1⎤⎤\n    ⎢⎢ ⎥  ⎢ ⎥⎥\n    ⎢⎢2⎥, ⎢1⎥⎥\n    ⎢⎢ ⎥  ⎢ ⎥⎥\n    ⎣⎣3⎦  ⎣1⎦⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/#Eigenvalues,-Eigenvectors,-and-Diagonalization","page":"Matrices","title":"Eigenvalues, Eigenvectors, and Diagonalization","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the eigenvalues of a matrix, use eigenvals.  eigenvals returns a dictionary of eigenvalue: algebraic_multiplicity pairs (similar to the output of roots).","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nThe LinearAlgebra generic functions have methods eigvals and eigvecs for this taks","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"M = Sym[3 -2 4 -2; 5 3 -3 -2; 5 -2 2 -2; 5 -2 -3 3]\neigvals(M)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M = Matrix([[3, -2,  4, -2], [5,  3, -3, -2], [5, -2,  2, -2], [5, -2, -3,  3]])\n    >>> M\n    ⎡3  -2  4   -2⎤\n    ⎢             ⎥\n    ⎢5  3   -3  -2⎥\n    ⎢             ⎥\n    ⎢5  -2  2   -2⎥\n    ⎢             ⎥\n    ⎣5  -2  -3  3 ⎦\n    >>> M.eigenvals()\n    {-2: 1, 3: 1, 5: 2}","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"This means that M has eigenvalues -2, 3, and 5, and that the eigenvalues -2 and 3 have algebraic multiplicity 1 and that the eigenvalue 5 has algebraic multiplicity 2.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To find the eigenvectors of a matrix, use eigenvects.  eigenvects returns a list of tuples of the form (eigenvalue, algebraic_multiplicity, [eigenvectors]).","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"eigvecs(M)\nM.eigenvects()","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> M.eigenvects()\n    ⎡⎛       ⎡⎡0⎤⎤⎞  ⎛      ⎡⎡1⎤⎤⎞  ⎛      ⎡⎡1⎤  ⎡0 ⎤⎤⎞⎤\n    ⎢⎜       ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥  ⎢  ⎥⎥⎟⎥\n    ⎢⎜       ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥  ⎢-1⎥⎥⎟⎥\n    ⎢⎜-2, 1, ⎢⎢ ⎥⎥⎟, ⎜3, 1, ⎢⎢ ⎥⎥⎟, ⎜5, 2, ⎢⎢ ⎥, ⎢  ⎥⎥⎟⎥\n    ⎢⎜       ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥⎥⎟  ⎜      ⎢⎢1⎥  ⎢0 ⎥⎥⎟⎥\n    ⎢⎜       ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥⎥⎟  ⎜      ⎢⎢ ⎥  ⎢  ⎥⎥⎟⎥\n    ⎣⎝       ⎣⎣1⎦⎦⎠  ⎝      ⎣⎣1⎦⎦⎠  ⎝      ⎣⎣0⎦  ⎣1 ⎦⎦⎠⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"This shows us that, for example, the eigenvalue 5 also has geometric multiplicity 2, because it has two eigenvectors.  Because the algebraic and geometric multiplicities are the same for all the eigenvalues, M is diagonalizable.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"To diagonalize a matrix, use diagonalize. diagonalize returns a tuple (P, D), where D is diagonal and M = PDP^{-1}.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"P, D = M.diagonalize()\nP * D * inv(P)\nP * D * inv(P) == M","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> P, D = M.diagonalize()\n    >>> P\n    ⎡0  1  1  0 ⎤\n    ⎢           ⎥\n    ⎢1  1  1  -1⎥\n    ⎢           ⎥\n    ⎢1  1  1  0 ⎥\n    ⎢           ⎥\n    ⎣1  1  0  1 ⎦\n    >>> D\n    ⎡-2  0  0  0⎤\n    ⎢           ⎥\n    ⎢0   3  0  0⎥\n    ⎢           ⎥\n    ⎢0   0  5  0⎥\n    ⎢           ⎥\n    ⎣0   0  0  5⎦\n    >>> P*D*P**-1\n    ⎡3  -2  4   -2⎤\n    ⎢             ⎥\n    ⎢5  3   -3  -2⎥\n    ⎢             ⎥\n    ⎢5  -2  2   -2⎥\n    ⎢             ⎥\n    ⎣5  -2  -3  3 ⎦\n    >>> P*D*P**-1 == M\n    True","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Quick Tip\nlambda is a reserved keyword in Python, so to create a Symbol called lambda, while using the same names for SymPy Symbols and Python variables, use lamda (without the b).  It will still pretty print as lambda.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Note that since eigenvects also includes the eigenvalues, you should use it instead of eigenvals if you also want the eigenvectors. However, as computing the eigenvectors may often be costly, eigenvals should be preferred if you only wish to find the eigenvalues.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"If all you want is the characteristic polynomial, use charpoly.  This is more efficient than eigenvals, because sometimes symbolic roots can be expensive to calculate.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"@syms lambda => \"λ\"\np = M.charpoly(lambda)\nfactor(p.as_expr())","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> lamda = symbols('lamda')\n    >>> p = M.charpoly(lamda)\n    >>> factor(p.as_expr())\n           2\n    (λ - 5) ⋅(λ - 3)⋅(λ + 2)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: TODO\nAdd an example for jordan_form, once it is fully implemented.","category":"page"},{"location":"Tutorial/matrices/#Possible-Issues","page":"Matrices","title":"Possible Issues","text":"","category":"section"},{"location":"Tutorial/matrices/#Zero-Testing","page":"Matrices","title":"Zero Testing","text":"","category":"section"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"If your matrix operations are failing or returning wrong answers, the common reasons would likely be from zero testing. If there is an expression not properly zero-tested, it can possibly bring issues in finding pivots for gaussian elimination, or deciding whether the matrix is inversible, or any high level functions which relies on the prior procedures.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Currently, the SymPy's default method of zero testing _iszero is only guaranteed to be accurate in some limited domain of numerics and symbols, and any complicated expressions beyond its decidability are treated as None, which behaves similarly to logical False.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"The list of methods using zero testing procedures are as follows:","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"echelon_form , is_echelon , rank , rref , nullspace , eigenvects , inverse_ADJ , inverse_GE , inverse_LU , LUdecomposition , LUdecomposition_Simple , LUsolve","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"They have property iszerofunc opened up for user to specify zero testing method, which can accept any function with single input and boolean output, while being defaulted with _iszero.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Here is an example of solving an issue caused by undertested zero. While the output for this particular matrix has since been improved, the technique below is still of interest. [#zerotestexampleidea-fn]_ [#zerotestexamplediscovery-fn]_ [#zerotestexampleimproved-fn]_","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"@syms q::positive\nM = [-2cosh(q/3) exp(-q) 1; exp(q) -2cosh(q/3) 1; 1 1 -2cosh(q/3)]\nM.nullspace()","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> from sympy import *\n    >>> q = Symbol(\"q\", positive = True)\n    >>> m = Matrix([\n    ... [-2*cosh(q/3),      exp(-q),            1],\n    ... [      exp(q), -2*cosh(q/3),            1],\n    ... [           1,            1, -2*cosh(q/3)]])\n    >>> m.nullspace() # doctest: +SKIP\n    []","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"You can trace down which expression is being underevaluated, by injecting a custom zero test with warnings enabled.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"my_iszero(x) = x.is_zero\nmy_iszero.(M)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> import warnings\n    >>>\n    >>> def my_iszero(x):\n    ...     try:\n    ...         result = x.is_zero\n    ...     except AttributeError:\n    ...         result = None\n    ...\n    ...     # Warnings if evaluated into None\n    ...     if result is None:\n    ...         warnings.warn(\"Zero testing of {} evaluated into None\".format(x))\n    ...     return result\n    ...\n    >>> m.nullspace(iszerofunc=my_iszero) # doctest: +SKIP\n    __main__:9: UserWarning: Zero testing of 4*cosh(q/3)**2 - 1 evaluated into None\n    __main__:9: UserWarning: Zero testing of (-exp(q) - 2*cosh(q/3))*(-2*cosh(q/3) - exp(-q)) - (4*cosh(q/3)**2 - 1)**2 evaluated into None\n    __main__:9: UserWarning: Zero testing of 2*exp(q)*cosh(q/3) - 16*cosh(q/3)**4 + 12*cosh(q/3)**2 + 2*exp(-q)*cosh(q/3) evaluated into None\n    __main__:9: UserWarning: Zero testing of -(4*cosh(q/3)**2 - 1)*exp(-q) - 2*cosh(q/3) - exp(-q) evaluated into None\n    []","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"In this case, (-exp(q) - 2*cosh(q/3))*(-2*cosh(q/3) - exp(-q)) - (4*cosh(q/3)**2 - 1)**2 should yield zero, but the zero testing had failed to catch. possibly meaning that a stronger zero test should be introduced. For this specific example, rewriting to exponentials and applying simplify would make zero test stronger for hyperbolics, while being harmless to other polynomials or transcendental functions.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"tip: Julia differences\nWe use broadcasting over the matrix","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"my_iszero(x) = x.rewrite(exp).simplify().is_zero\nmy_iszero.(M)","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"    >>> def my_iszero(x):\n    ...     try:\n    ...         result = x.rewrite(exp).simplify().is_zero\n    ...     except AttributeError:\n    ...         result = None\n    ...\n    ...     # Warnings if evaluated into None\n    ...     if result is None:\n    ...         warnings.warn(\"Zero testing of {} evaluated into None\".format(x))\n    ...     return result\n    ...\n    >>> m.nullspace(iszerofunc=my_iszero) # doctest: +SKIP\n    __main__:9: UserWarning: Zero testing of -2*cosh(q/3) - exp(-q) evaluated into None\n    ⎡⎡  ⎛   q         ⎛q⎞⎞  -q         2⎛q⎞    ⎤⎤\n    ⎢⎢- ⎜- ℯ  - 2⋅cosh⎜─⎟⎟⋅ℯ   + 4⋅cosh ⎜─⎟ - 1⎥⎥\n    ⎢⎢  ⎝             ⎝3⎠⎠              ⎝3⎠    ⎥⎥\n    ⎢⎢─────────────────────────────────────────⎥⎥\n    ⎢⎢          ⎛      2⎛q⎞    ⎞     ⎛q⎞       ⎥⎥\n    ⎢⎢        2⋅⎜4⋅cosh ⎜─⎟ - 1⎟⋅cosh⎜─⎟       ⎥⎥\n    ⎢⎢          ⎝       ⎝3⎠    ⎠     ⎝3⎠       ⎥⎥\n    ⎢⎢                                         ⎥⎥\n    ⎢⎢           ⎛   q         ⎛q⎞⎞            ⎥⎥\n    ⎢⎢          -⎜- ℯ  - 2⋅cosh⎜─⎟⎟            ⎥⎥\n    ⎢⎢           ⎝             ⎝3⎠⎠            ⎥⎥\n    ⎢⎢          ────────────────────           ⎥⎥\n    ⎢⎢                   2⎛q⎞                  ⎥⎥\n    ⎢⎢             4⋅cosh ⎜─⎟ - 1              ⎥⎥\n    ⎢⎢                    ⎝3⎠                  ⎥⎥\n    ⎢⎢                                         ⎥⎥\n    ⎣⎣                    1                    ⎦⎦","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"</details>","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"You can clearly see nullspace returning proper result, after injecting an alternative zero test.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Note that this approach is only valid for some limited cases of matrices containing only numerics, hyperbolics, and exponentials. For other matrices, you should use different method opted for their domains.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"Possible suggestions would be either taking advantage of rewriting and simplifying, with tradeoff of speed [#zerotestsimplifysolution-fn]_ , or using random numeric testing, with tradeoff of accuracy [#zerotestnumerictestsolution-fn]_ .","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"If you wonder why there is no generic algorithm for zero testing that can work with any symbolic entities, it's because of the constant problem stating that zero testing is undecidable [#constantproblemwikilink-fn]_ , and not only the SymPy, but also other computer algebra systems [#mathematicazero-fn]_ [#matlabzero-fn]_ would face the same fundamental issue.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"However, discovery of any zero test failings can provide some good examples to improve SymPy, so if you have encountered one, you can report the issue to SymPy issue tracker [#sympyissues-fn]_ to get detailed help from the community.","category":"page"},{"location":"Tutorial/matrices/","page":"Matrices","title":"Matrices","text":"note: Footnotes\n[#zerotestexampleidea-fn] Inspired by https://gitter.im/sympy/sympy?at=5b7c3e8ee5b40332abdb206c\n[#zerotestexamplediscovery-fn] Discovered from https://github.com/sympy/sympy/issues/15141\n[#zerotestexampleimproved-fn] Improved by https://github.com/sympy/sympy/pull/19548\n[#zerotestsimplifysolution-fn] Suggested from https://github.com/sympy/sympy/issues/10120\n[#zerotestnumerictestsolution-fn] Suggested from https://github.com/sympy/sympy/issues/10279\n[#constantproblemwikilink-fn] https://en.wikipedia.org/wiki/Constant_problem\n[#mathematicazero-fn] How mathematica tests zero https://reference.wolfram.com/language/ref/PossibleZeroQ.html\n[#matlabzero-fn] How matlab tests zero https://web.archive.org/web/20200307091449/https://www.mathworks.com/help/symbolic/mupad_ref/iszero.html\n[#sympyissues-fn] https://github.com/sympy/sympy/issues","category":"page"},{"location":"introduction/#A-SymPyCore-introduction","page":"Introduction","title":"A SymPyCore introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This document provides an introduction to using SymPy within Julia via SymPyCore It has examples from the Introductory Tutorial of SymPy that is translated into Julia commands in this documentation.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using SymPyPythonCall","category":"page"},{"location":"introduction/#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In this document, we use SymPy to refer to either the SymPyPyCall or SymPyPythonCall packages that interface Julia with SymPy from Python using SymPyCore. The only difference being the glue package for interop between Julia and Python. (It is planned that SymPyPyCall will be renamed SymPy when a breaking change is released for SymPy.)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SymPy provides a Julian interface to SymPy, a Python library for symbolic math, as alternative to working with Python objects directly using one of the glue packages. Some implementation details are:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Symbolic values in Python are wrapped in a subtype, typically Sym{T}, of SymbolicObject{T} or a container holding such values. The conversion from a Python object to a symbolic object in Julia is implemented in the ↑ method. Similarly, the  ↓ method takes a symbolic object and finds a Python counterpart for passing to underlying methods of SymPy.\nFor many generic methods in Base, LinearAlgebra, or SpecialFunctions – when there is a SymPy counterpart – a method is made which dispatches on its first argument being symbolic. The basic pattern is akin to Base.sin(x::Sym) = sympy.sin(x) where sympy.sin(x) is essentially ↑(_sympy_.sin(↓(x))) – here _sympy_ is the object holding the reference to the Python module, and _sympy_.sin the reference to its sin function. The sympy object handles the up and down conversions.\nFor many primary functions of SymPy, such as simplify, factor, expand, etc., new methods are made for use within Julia. Less foundational functions of SymPy, such as trigsimp or expand_log are referenced as sympy.trigsimp or sympy.expand_log. The sympy object is not a Julia module, but this use is reminiscent of qualifying a function from a module.\nSymPy, being a Python library, has many methods for its objects. For example, a symbolic object, obj has a diff method accessed by obj.diff(...). A object also has a subs method for substitution, accessed through obj.subs(...). The same \"dot\" style is used for Python and Julia.\nFor commonly used object methods, a Julian interface is defined. For diff a diff(obj::Sym, ...) method is defined. For subs a subs(obj::Sym, ...) interface is defined, and exported. As subs has paired-off values, specifying the substitution, the Julian interface allows pairs notation (a => b) to be used.","category":"page"},{"location":"introduction/#The-package","page":"Introduction","title":"The package","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Either the SymPyPyCall or SymPyPythonCall packages needs to be loaded, e.g., using SymPyPyCall. The two can't be used in the same session.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When either is installed, the SymPyCore package is installed; the underlying glue package (either PyCall, PythonCall) should be installed; and that glue package should install the sympy library of Python.","category":"page"},{"location":"introduction/#Symbols","page":"Introduction","title":"Symbols","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"At the core of SymPy is the introduction of symbolic variables that differ quite a bit from Julia's variables. Symbolic variables do not immediately evaluate to a value, rather the \"symbolicness\" propagates when interacted with. To keep things manageable, SymPy does some simplifications along the way.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Symbolic expressions are primarily of the Sym type and can be constructed in the standard way:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"x = Sym(\"x\")","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This creates a symbolic object x, which can be manipulated through further function calls.","category":"page"},{"location":"introduction/#The-@syms-macro","page":"Introduction","title":"The @syms macro","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"There is the @syms macro that makes creating multiple variables a bit less typing, as it creates variables in the local scope – no assignment is necessary. Compare these similar ways to create symbolic variables:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms a b c\na,b,c = Sym(\"a,b,c\")","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here are two ways to make related variables:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms xs[1:5]\nys = [Sym(\"y$i\") for i in 1:5]","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The former much more succinct, but the latter pattern of use when the number of terms is a variable.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The @syms macro is recommended, and will be modeled in the following, as it makes the specification of assumptions, collections of indexed variables,  and symbolic functions more natural.","category":"page"},{"location":"introduction/#Assumptions","page":"Introduction","title":"Assumptions","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In Python's SymPy documentation the symbols constructor is suggested as idiomatic for producing symbolic objects. This function can similarly be used within Julia. With symbols (and with @syms) it is possible to pass assumptions onto the variables. A list of possible assumptions is here. Some examples are:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"u = symbols(\"u\")\nx = symbols(\"x\", real=true)\ny1, y2 = symbols(\"y1, y2\", positive=true)\nalpha = symbols(\"alpha\", integer=true, positive=true)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As seen, the symbols function can be used to make one or more variables with zero, one or more assumptions.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We jump ahead for a second to illustrate, but here we see that solve will respect these assumptions, by failing to find solutions to these equations:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(x^2 + 1)   # ±i are not real","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(y1 + 1)    # -1 is not positive","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The @syms macro allows annotations, akin to type annotations, to specify assumptions on new variables:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms u1::positive u2::positive\nsolve(u1 + u2)  # empty, though solving u1 - u2 is not.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Additionally you can rename arguments using pair notation:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms a1=>\"α₁\" a2=>\"α₂\"","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In this example, the Julia variables a1 and a2 are defined to store SymPy symbols with the \"pretty\" names α₁ and α₂ respectively.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As can be seen, there are several ways to create symbolic values, but the recommended way is to use @syms. One caveat is that one can't use Sym to create a variable from a function name in Base.","category":"page"},{"location":"introduction/#Special-constants","page":"Introduction","title":"Special constants","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Julia has its math constants, like pi and e, SymPy as well. A few of these have Julia counterparts provided by SymPyCore. For example, these two constants are defined (where oo is for infinity):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PI,  oo","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Numeric values themselves can be symbolic. This example shows the difference. The first asin call dispatches to Julia's asin function, the second to SymPy's:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[asin(1), asin(Sym(1))]","category":"page"},{"location":"introduction/#Substitution","page":"Introduction","title":"Substitution","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SymPy provides a means to substitute values in for the symbolic expressions. The specification requires an expression, a variable in the expression to substitute in for, and a new value. For example, this is one way to make a polynomial in a new variable:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x y\nex = x^2 + 2x + 1\nex.subs(x, y)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Substitution can also be numeric:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"ex.subs(x, 0)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The output has no free variables, but is still symbolic.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Expressions with more than one variable can have multiple substitutions, where each is expressed as a tuple:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x,y,z\nex = x + y + z\nex.subs([(x,1), (y, pi)])","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"note: Note\nThe SymPy documentation for many functions can be read from the terminal using Base.Docs.getdoc(ex), as in Base.Docs.getdoc(sin(x)).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The SymPyCore package also offers a more Julian interface, through the method subs. This replaces the specification of pairs by a tuple with the => infix operator for Pair construction:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"subs(ex, x=>1, y=>pi)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For subs, the simple substitution ex.object(x,a) or subs(ex, x=>s) is similar to simple function evaluation, so Julia's call notation for symbolic expressions is reserved for substitution, where to specify the pairing off of x and a, the =>  pairs notation is used.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This calling style will be equivalent to the last:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"ex(x=>1, y=>pi)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A straight call is also possble, where the order of the variables is determined by free_symbols. This is useful for expressions of a single variable, but being more explicit through the use of paired values is recommended.","category":"page"},{"location":"introduction/#Conversion-from-symbolic-to-numeric","page":"Introduction","title":"Conversion from symbolic to numeric","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SymPy provides two identical means to convert a symbolic math expression to a number. One is evalf, the other N. Within Julia we decouple this, using N to also convert to a Julian value and evalf to leave the conversion as a symbolic object.  The N function converts symbolic integers, rationals, irrationals, and complex values, while attempting to find an appropriate Julia type for the value.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To see the difference, we use both on PI:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"N(PI)  # converts to underlying pi irrational","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Whereas, evalf will produce a symbolic numeric value:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"(PI).evalf()","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The evalf call allows for a precision argument to be passed through the second argument. This is how 30 digits of pi can be extracted:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PI.evalf(30)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This is a SymPy, symbolic number, not a Julia object. Composing with N","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"N(PI.evalf(30))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"will produce a Julia number,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Explicit conversion via convert(T, ex) can also be done in some cases, but may need to be combined with a call to evalf in some compound cases.","category":"page"},{"location":"introduction/#Algebraic-expressions","page":"Introduction","title":"Algebraic expressions","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SymPyCore overloads many of Julia's functions to work with symbolic objects, such as seen above with asin. The usual mathematical operations such as +, *, -, / etc. work through Julia's promotion mechanism, where numbers are promoted to symbolic objects, others dispatch internally to related SymPy functions.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In most all  cases, thinking about this distinction between numbers and symbolic numbers is unnecessary, as numeric values passed to SymPyCore functions are typically promoted to symbolic expressions. This conversion will take math constants to their corresponding SymPyCore counterpart, rational expressions to rational expressions, and floating point values to floating point values. However there are edge cases. An expression like 1//2 * pi * x will differ from the seemingly identical  1//2 * (pi * x). The former will produce a floating point value from 1//2 * pi before being promoted to a symbolic instance. Using the symbolic value PI makes this expression work either way.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Most of Julia's mathematical functions are overloaded to work with symbolic expressions. Julia's generic definitions are used, as possible. This also introduces some edge cases. For example, x^(-2) will balk due to the negative, integer exponent, but either x^(-2//1) or x^Sym(-2) will work as expected, as the former call first dispatches to a generic defintion, but the latter two expressions do not.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"`SymPyPythonCore makes it very easy to work with polynomial and rational expressions. First we create some variables:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x y z","category":"page"},{"location":"introduction/#The-expand,-factor,-collect,-and-simplify-functions","page":"Introduction","title":"The expand, factor, collect, and simplify functions","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A typical polynomial expression in a single variable can be written in two common ways, expanded or factored form. Using factor and expand can move between the two.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For example,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p = x^2 + 3x + 2\nfactor(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Or","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"expand(prod((x-i) for i in 1:5))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The factor function factors over the rational numbers, so something like this with obvious factors is not finished:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"factor(x^2 - 2)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When expressions involve one or more variables, it can be convenient to be able to manipulate them. For example, if we define q by:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"q = x*y + x*y^2 + x^2*y + x","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Then we can collect the terms by the variable x:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"collect(q, x)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"or the variable y:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"collect(q, y)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"These are identical expressions, though viewed differently.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A more broad-brush approach is to let SymPyPythonCore simplify the values. In this case, the common value of x is factored out:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"simplify(q)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The simplify function attempts to apply the dozens of functions related to simplification that are part of SymPy. It is also possible to apply these functions one at a time, for example sympy.trigsimp does trigonometric simplifications.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The SymPy tutorial illustrates that expand can also result in simplifications through this example:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"expand((x + 1)*(x - 2) - (x - 1)*x)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"These methods are not restricted to polynomial expressions and will work with other expressions. For example, factor identifies the following as a factorable object in terms of the variable exp(x):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"factor(exp(2x) + 3exp(x) + 2)","category":"page"},{"location":"introduction/#Rational-expressions:-apart,-together,-cancel","page":"Introduction","title":"Rational expressions: apart, together, cancel","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When working with rational expressions, SymPy does not do much simplification unless asked. For example this expression is not simplified:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"r = 1/x + 1/x^2","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To put the terms of r over a common denominator, the together function is available:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"together(r)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The apart function does the reverse, creating a partial fraction decomposition from a ratio of polynomials:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"apart( (4x^3 + 21x^2 + 10x + 12) /  (x^4 + 5x^3 + 5x^2 + 4x))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Some times SymPy will cancel factors, as here:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"top = (x-1)*(x-2)*(x-3)\nbottom = (x-1)*(x-4)\ntop/bottom","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"(This might make math faculty a bit upset, but it is in line with student thinking.)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"However, with expanded terms, the common factor of (x-1) is not cancelled:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"r = expand(top) / expand(bottom)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The cancel function instructs SymPy to perform cancellations. It takes rational functions and puts them in a canonical pq form with no common (rational) factors and leading terms which are integers:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"cancel(r)","category":"page"},{"location":"introduction/#Powers","page":"Introduction","title":"Powers","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The SymPy tutorial offers a thorough explanation on powers and which get simplified and under what conditions. Basically","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"x^a x^b = x^a+b\nis always true. However\nx^a y^a=(xy)^a\nis only true with assumptions, such as xy geq 0 and a is real, but not in general. For example, x=y=-1 and a=12 has x^a cdot y^a = i cdot i =  -1, where as (xy)^a = 1.\n(x^a)^b = x^ab\nis only true with assumptions. For example x=-1 a=2, and b=12 gives (x^a)^b = 1^12 = 1, whereas x^ab = -1^1 = -1.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We see that with assumptions, the following expression does simplify to 0:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x::nonnegatve y::nonnegative  a::real\nsimplify(x^a * y^a - (x*y)^a)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"However, without assumptions this is not the case","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x,y,a\nsimplify(x^a * y^a - (x*y)^a)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The simplify function calls powsimp to simplify powers, as above. The powsimp function has the keyword argument force=true to force simplification even if assumptions are not specified:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sympy.powsimp(x^a * y^a - (x*y)^a, force=true)","category":"page"},{"location":"introduction/#Trigonometric-simplification","page":"Introduction","title":"Trigonometric simplification","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For trigonometric expressions, simplify will use trigsimp to simplify:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms theta::real\np = cos(theta)^2 + sin(theta)^2","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Calling either simplify or trigsimp will apply the Pythagorean identity:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"simplify(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"While often forgotten,  the trigsimp function is, of course,  aware of the double angle formulas:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"simplify(sin(2theta) - 2sin(theta)*cos(theta))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The expand_trig function will expand such expressions:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sympy.expand_trig(sin(2theta))","category":"page"},{"location":"introduction/#Coefficients","page":"Introduction","title":"Coefficients","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Returning to polynomials, there are a few functions to find various pieces of the polynomials. First we make a general quadratic polynomial:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms a,b,c,x\np = a*x^2 + b*x + c","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"If given a polynomial, like p, there are different means to extract the coefficients:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SymPy provides a coeffs method for Poly objects, but p must first be converted to one.\nSymPy provides the coeff method for expressions, which allows extration of a coeffiecient for a given monomial","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The ex.coeff(monom) call will return the corresponding coefficient of the monomial:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p.coeff(x^2) # a\np.coeff(x)   # b","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The constant can be found through substitution:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p(x=>0)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Though one could use some trick like this to find all the coefficients, that is cumbersome, at best.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"vcat([p.coeff(x^i) for i in N(degree(p,gen=x)):-1:1], [p(x=>0)])","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Polynomials are a special class in SymPy and must be constructed. The poly constructor can be used. As there is more than one free variable in p, we specify the variable x below:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"q = sympy.poly(p, x)\nq.coeffs()","category":"page"},{"location":"introduction/#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots","page":"Introduction","title":"Polynomial roots: solve, real_roots, polyroots, nroots","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SymPy provides functions to find the roots of a polynomial. In general, a polynomial with real coefficients of degree n will have n roots when multiplicities and complex roots are accounted for. The number of real roots is consequently between 0 and n.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For a univariate polynomial expression (a single variable), the real roots, when available, are returned by real_roots. For example,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"real_roots(x^2 - 2)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Unlike factor – which only factors over rational factors – real_roots finds the two irrational roots here. It is well known (the Abel-Ruffini theorem) that for degree 5 polynomials, or higher, it is not always possible to express the roots in terms of radicals. However, when the roots are rational SymPy can have success:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p = (x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1)\nreal_roots(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In this example, the degree of p is 8, but only the 6 real roots returned, the double root of 3 is accounted for. The two complex roots of x^2 + x+ 1 are not considered by this function. The complete set of distinct roots can be found with solve:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This finds the complex roots, but does not account for the double root. The roots function of SymPy does.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The output of calling roots will be a dictionary whose keys are the roots and values the multiplicity.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"roots(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When exact answers are not provided, the roots call is contentless:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"p = x^5 - x + 1\nsympy.roots(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Calling solve seems to produce very little as well:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"rts = solve(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"But in fact, rts contains lots of information. We can extract numeric values quite easily with N:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"N.(rts)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"These are numeric approximations to irrational values. For numeric approximations to polynomial roots, the nroots function is also provided. The answers are still symbolic:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"nroots(p)","category":"page"},{"location":"introduction/#The-solve-function","page":"Introduction","title":"The solve function","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The solve function is more general purpose than just finding roots of univariate polynomials. The function tries to solve for when an expression is 0, or a set of expressions are all 0.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For example, it can be used to solve when cos(x) = sin(x):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(cos(x) - sin(x))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Though there are infinitely many correct solutions, these are within a certain range.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The solveset function appears in version 1.0 of SymPy and is an intended replacement for solve. Here we see it describes all solutions:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"u = solveset(cos(x) - sin(x))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The output of solveset is a set, rather than a vector or dictionary.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"v = solveset(x^2 - 4)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Solving within Sympy has limits. For example, there is no symbolic solution here:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"try  solve(cos(x) - x)  catch err \"error\" end # wrap command for doctest of error","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"(And hence the error message generated.)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For such an equation, a numeric method would be needed, similar to the Roots package. For example:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"nsolve(cos(x) - x, 1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Though it can't solve everything, the solve function can also solve equations of a more general type. For example, here it is used to derive the quadratic equation:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms a::real, b::real, c::real\np = a*x^2 + b*x + c\nxs = solve(p, x);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The extra argument x is passed to solve so that solve knows which variable to solve for.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The solveset function is similar:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solveset(p, x); # Set with two elements","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"If the x value is not given, solveset will error and  solve will try to find a solution over all the free variables:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(p)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The output of solveset in Python is always a set, which may be finite or not. Finite sets are converted to Sets in Julia. Infinite sets have no natural counterpart and are not realized. Rather, they can be queried, as with \"needle in haystack\". For example:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"u = solveset(sin(x) ≧ 0)  # [\\geqq] or with u  = solveset(Ge(sin(x), 0))\nPI/2 in u\n3PI/2 in u","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Infinite sets can have unions and intersections taken:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"v = solveset(cos(x) ≧ 0)\n[3PI/4 in A for A ∈ (u, v, intersect(u, v), union(u, v))]","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Infinite sets can be filtered by intersecting them with an interval. For example,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"u = solveset(sin(x) ~ 1//2, x)\nintersect(u, sympy.Interval(0, 2PI))  # a finite set after intersection","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"There are more sympy methods for working with sets, beyond those mirroring Julia generics.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Systems of equations can be solved as well. We specify them within a tuple of expressions, (ex1, ex2, ..., exn) where a found solution is one where all the expressions are 0. For example, to solve this linear system: 2x + 3y = 6 3x - 4y=12, we have:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x::real, y::real\nexs = (2x+3y-6, 3x-4y-12)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"d = solve(exs); # Dict(x=>60/17, y=>-6/17)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can \"check our work\" by plugging into each equation. We take advantage of how the subs function allows us to pass in a dictionary:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"map(ex -> ex.subs(d), exs)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The more Julian way to solve a linear  equation, like this   would be as follows:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A = Sym[2 3; 3  -4]; b = Sym[6, 12]\nA \\ b","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"(Rather than use a generic  lu solver through Julia (which  proved slow for larger  systems),  the \\ operator utilizes  solve to perform this  computation.)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In the previous example, the system had two equations and two unknowns. When that is not the case, one can specify the variables to solve for as a vector. In this example, we find a quadratic polynomial that approximates cos(x) near 0:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"a,b,c,h = symbols(\"a,b,c,h\", real=true)\n\np = a*x^2 + b*x + c\n\nfn = cos;\nexs = [fn(0*h)-p(x=>0), fn(h)-p(x => h), fn(2h)-p(x => 2h)]\nd = solve(exs, (a,b,c));\nd[a], d[b], d[c]","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Again, a dictionary is returned, though we display its named elements individually. The polynomial itself can be found by substituting back in for a, b, and c:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"quad_approx = p.subs(d)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Taking the \"limit\" as h goes to 0 produces the answer 1 - x^22, as  will be shown.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Finally for solve, we show one way to re-express the polynomial a_2x^2 + a_1x + a_0 as b_2(x-c)^2 + b_1(x-c) + b_0 using solve (and not, say, an expansion theorem.)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"n = 3\n@syms x, c\n@syms as[1:3]\n@syms bs[1:3]\np = sum(as[i]*x^(i-1) for i ∈ 1:n)\nq = sum(bs[i]*(x-c)^(i-1) for i ∈ 1:n)\nd = solve(p-q, bs)","category":"page"},{"location":"introduction/#Solving-using-logical-operators","page":"Introduction","title":"Solving using logical operators","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The solve function does not need to just solve ex = 0. There are other means to specify an equation. Ideally, it would be nice to say ex1 == ex2, but the interpretation of == is not for this. Rather, SymPyPythonCore introduces Eq for equality. So this expression","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(Eq(x, 1))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"gives 1, as expected from solving x == 1.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"note: Equals\nMathematics uses = for equations. Julia uses = for assignment and == for generic equality, and === to test for identical values. There is no general infix equation operation in Julia, though ~ is used by the Symbolics package its ecosystem. SymPy uses Eq for expressing an equation. For SymPyCore, both Eq and ~ may be used to indicate an equation between unknowns.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In addition to Eq, there are Lt, Le, Ge, Gt. The Unicode operators (e.g., \\leq  and not  \\leq)  are not aliased to these, but there are alternatives \\ll[tab], \\leqq[tab], \\Equal[tab], \\geqq[tab], \\gg[tab] and \\neg[tab] to negate.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"So, the above could have been written with the following nearly identical expression, though it is entered with \\Equal[tab]:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"solve(x ⩵ 1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here is an alternative way of asking a previous question on a pair of linear equations:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@syms x::real, y::real\nexs = (2x+3y ⩵ 6, 3x-4y ⩵ 12)    ## Using \\Equal[tab]\nd = solve(exs);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here  is  one other way  to  express  the same","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Eq.( (2x+3y,3x-4y), (6,12)) |>  solve == d","category":"page"},{"location":"overview/#Basic-overview","page":"Overview","title":"Basic overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"An interface between Julia and the SymPy library of Python requires a connection between the two languages. The PythonCall package provides a means to  call into an underlying sympy library in Python. (As well as PyCall.) For example","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using SymPyPythonCall\nPythonCall = SymPyPythonCall.PythonCall","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia> import PythonCall","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"const _sympy_ = PythonCall.pynew()\nPythonCall.pycopy!(_sympy_, PythonCall.pyimport(\"sympy\"));","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The _sympy_ object holds references to the underlying sympy library. As an example, the following creates a symbolic variable, x, and calls the sin function on it:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = _sympy_.symbols(\"x\")\n_sympy_.sin(x)\nx.is_commutative\nx.conjugate()\ntypeof(x)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The PythonCall package provides some basic operations for Py objects, such as basic math operations:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x + x\nx * x\nx ^ x","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"SymPyPythonCall, which uses SymPyCore, wraps the Py objects in its Sym class to provide a means to dispatch familiar Julia generics:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using SymPyPythonCall","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"x = symbols(\"x\") # or @syms x\nsimplify(2sin(x)*cos(x))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By wrapping the Python object in a Julia struct, there are many advantages, such as:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The type can be used for dispatch, allowing Julia generic functions to have methods specialized for symbolic objects.\nThe getproperty method can be specialized. This allows object methods, like x.conjugate to have arguments translated from Sym objects to Python objects when being called.\nThe show method can be used to adjust printing of objects","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The package also provides methods for some sympy methods, such as simplify above. To make this work, there needs to be a means to take Sym objects to their Py counterparts and a means to take Py objects to a symbolic type. As these conversions may be type dependent two operators (↓ and  ↑) are used internally to allow the definition along these lines:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"simplify(x::Sym, args...; kwargs...) = ↑(sympy.simplify(↓(x), ↓(args)...; ↓(kwargs)...))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Though there is some overhead introduced, it does not seem to be significant compared to computational cost of most symbolic computations.)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The expand_log function is not wrapped as such, but can still be called from the sympy object exported by SymPyPythonCall:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@syms x::real\nsimplify(log(2x))\nsympy.expand_log(log(2x))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Methods of sympy are also called using the conversion operators above.","category":"page"},{"location":"overview/#Using-other-SymPy-modules","page":"Overview","title":"Using other SymPy modules","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We follow part of the SymPy docs to see how to access one of the numerous external modules of sympy beyond those exposed immediately by SymPy. In this case, the stats module.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"import PythonCall: pyimport\n_stats_ = pyimport(\"sympy.stats\");","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The stats module holds several probability functions, similar to the Distributions package of Julia. This set of commands creates a normally distributed random variable, X, with symbolic parameters:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"𝑋,mu = _sympy_.symbols(\"X,mu\")\nsigma = _sympy_.symbols(\"sigma\")\nX = _stats_.Normal(𝑋,mu,sigma)\n_stats_.E(X)\n_stats_.E(X^2)\n_stats_.variance(X)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The one thing to note is the method calls return Py objects, as there is no intercepting of the method calls done the way there is for the sympy module.  Wrapping _stats_ in Sym uses the getproperty specialization:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"stats = Sym(_stats_);\n@syms 𝑋, μ, σ::positive\nX = stats.Normal(𝑋, μ, σ)\nstats.variance(X)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next statements like P(X  mu) can be answered by specifying the inequality using Gt in the following:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"stats.P(Gt(X, μ))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The unicode ≧ operator (\\geqq[tab]) is an infix alternative to Gt.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A typical calculation for the normal distribution is the area one or more standard deviations larger than the mean:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia> stats.P(X ≧ μ + 1 * σ)\nsqrt(2)*(-sqrt(2)*pi*exp(1/2)*erf(sqrt(2)/2)/2 + sqrt(2)*pi*exp(1/2)/2)*exp(-1/2)/(2*pi)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The familiar  answer could be found by calling N or evalf.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One more distribution is illusrated, the uniform distribution over a symbolic interval ab:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@syms 𝑈 a::real b::real\nU = stats.Uniform(𝑈, a, b)\nstats.E(U)\nstats.variance(U) |> factor","category":"page"},{"location":"overview/#Different-output-types","page":"Overview","title":"Different output types","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"SymPyPythonCall provides a few conversions into containers of symbolic objects, like for lists, tuples, finite sets, and matrices . Not all outputs are so simple to incorporate and are simply wrapped in the Sym type.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Conversion to a workable Julia structure can require some massaging. This example shows how to get at the pieces of the Piecewise type.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The output of many integration problems is a piecewise function:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@syms n::integer x::real\nu = integrate(x^n, x)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The u object is of type Sym, but there are no methods for working with it. The .args call will break this into its argument, which again will by symbolic. The SymPyPythonCall.Introspection.args function will perform the same thing.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"as = SymPyPythonCall.Introspection.args(u)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The as object is a tuple of Sym objects. Consider the first one:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"c1 = first(as)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The value of c1 prints as a tuple, but is of type Sym and sympy type CondExprPair. Though the underlying python type is iterable or indexable, the wrapped type is not. It can  be made iterable in a manner of ways: by calling ↓(c1); by finding the underlying Python object through the attribute .o, as in c1.o; or by calling the Py method of PythonCall, as in PythonCall.Py(c1). More generically, PythonCall provides a PyIterable wrapper. As there is no defined lastindex, the latter is a bit more cumbersome to use. This pattern below, expands the conditions into a dictionary:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"[Sym(↓(a[1])) => Sym(↓(a[1])) for a ∈ as]","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The Python objects are iterated over, so 0-based indexing is used above. These pieces are then converted to Sym objects for familiarity.","category":"page"},{"location":"Tutorial/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"using SymPyPythonCall","category":"page"},{"location":"Tutorial/intro/#What-is-Symbolic-Computation?","page":"Introduction","title":"What is Symbolic Computation?","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Symbolic computation deals with the computation of mathematical objects symbolically.  This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Let's take an example. Say we wanted to use the built-in Python functions to compute square roots. We might do something like this","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nJulis has sqrt in base","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"sqrt(9)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> import math\n   >>> math.sqrt(9)\n   3.0","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"9 is a perfect square, so we got the exact answer, 3. But suppose we computed the square root of a number that isn't a perfect square","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"sqrt(8)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> math.sqrt(8)\n   2.82842712475","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Here we got an approximate result. 2.82842712475 is not the exact square root of 8 (indeed, the actual square root of 8 cannot be represented by a finite decimal, since it is an irrational number).  If all we cared about was the decimal form of the square root of 8, we would be done.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"But suppose we want to go further. Recall that \\sqrt{8} = \\sqrt{4\\cdot 2} = 2\\sqrt{2}.  We would have a hard time deducing this from the above result. This is where symbolic computation comes in.  With a symbolic computation system like SymPy, square roots of numbers that are not perfect squares are left unevaluated by default","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nWe see two ways to do this, call the sqrt function from sympy or use the overloaded sqrt function for symbolic objects. The latter is more idiomatic.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"sympy.sqrt(3), sqrt(Sym(3))","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> import sympy\n   >>> sympy.sqrt(3)\n   sqrt(3)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Furthermore–-and this is where we start to see the real power of symbolic computation–-symbolic results can be symbolically simplified.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"sqrt(Sym(8))","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> sympy.sqrt(8)\n   2*sqrt(2)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/#A-More-Interesting-Example","page":"Introduction","title":"A More Interesting Example","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"The above example starts to show how we can manipulate irrational numbers exactly using SymPy.  But it is much more powerful than that.  Symbolic computation systems (which by the way, are also often called computer algebra systems, or just CASs) such as SymPy are capable of computing symbolic expressions with variables.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"As we will see later, in SymPy, variables are defined using symbols. Unlike many symbolic manipulation systems, variables in SymPy must be defined before they are used (the reason for this will be discussed in the next section).","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Let us define a symbolic expression, representing the mathematical expression x + 2y.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nWhile symbols may be used in the same manner as the Python code, the use of the @syms macro is used in this translation of the tutorial to Julia.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"@syms x, y\nexpr = x + 2y\n","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> from sympy import symbols\n   >>> x, y = symbols('x y')\n   >>> expr = x + 2*y\n   >>> expr\n   x + 2*y","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Note that we wrote x + 2*y just as we would if x and y were ordinary Python variables. But in this case, instead of evaluating to something, the expression remains as just x + 2*y.  Now let us play around with it:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"expr + 1\nexpr = x","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> expr + 1\n   x + 2*y + 1\n   >>> expr - x\n   2*y","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Notice something in the above example.  When we typed expr - x, we did not get x + 2*y - x, but rather just 2*y.  The x and the -x automatically canceled one another.  This is similar to how sqrt(8) automatically turned into 2*sqrt(2) above.  This isn't always the case in SymPy, however:","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"x * expr","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> x*expr\n   x*(x + 2*y)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Here, we might have expected x(x + 2y) to transform into x^2 + 2xy, but instead we see that the expression was left alone.  This is a common theme in SymPy.  Aside from obvious simplifications like x - x = 0 and \\sqrt{8} = 2\\sqrt{2}, most simplifications are not performed automatically.  This is because we might prefer the factored form x(x + 2y), or we might prefer the expanded form x^2 + 2xy.  Both forms are useful in different circumstances. In SymPy, there are functions to go from one form to the other","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe expand and factor functions of SymPy are wrapped and exported. For non-exported functions from SymPy, the sympy module can be utilized.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"expanded_expr = expand(x * expr)\nfactor(expanded_expr)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"   >>> from sympy import expand, factor\n   >>> expanded_expr = expand(x*expr)\n   >>> expanded_expr\n   x**2 + 2*x*y\n   >>> factor(expanded_expr)\n   x*(x + 2*y)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/#The-Power-of-Symbolic-Computation","page":"Introduction","title":"The Power of Symbolic Computation","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"The real power of a symbolic computation system such as SymPy is the ability to do all sorts of computations symbolically.  SymPy can simplify expressions, compute derivatives, integrals, and limits, solve equations, work with matrices, and much, much more, and do it all symbolically.  It includes modules for plotting, printing (like 2D pretty printed output of math formulas, or mathrmLaTeX), code generation, physics, statistics, combinatorics, number theory, geometry, logic, and more. Here is a small sampling of the sort of symbolic power SymPy is capable of, to whet your appetite.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"@syms x, t, z, nu","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> from sympy import *\n >>> x, t, z, nu = symbols('x t z nu')","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"This will make all further examples pretty print with unicode characters.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe ASCII pretty printing is used by show by default","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"nothing","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> init_printing(use_unicode=True)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Take the derivative of \\sin{(x)}e^x.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"diff(sin(x) * exp(x), x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> diff(sin(x)*exp(x), x)\n  x           x\n ℯ ⋅sin(x) + ℯ ⋅cos(x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Compute \\int(e^x\\sin{(x)} + e^x\\cos{(x)})\\,dx.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"integrate(exp(x)*sin(x) + exp(x)*cos(x), x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> integrate(exp(x)*sin(x) + exp(x)*cos(x), x)\n  x\n ℯ ⋅sin(x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Compute int_-infty^infty sin(x^2)dx.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe oo variable is exposed (along with PI, E, IM, zoo)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"integrate(sin(x^2), (x, -oo, oo))","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> integrate(sin(x**2), (x, -oo, oo))\n √2⋅√π\n ─────\n   2","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Find lim_xto 0fracsin(x)x.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe limit function is wrapped and exported. The wrapping is given an interface which accepts a pair","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"limit(sin(x)/x, x => 0)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> limit(sin(x)/x, x, 0)\n 1","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Solve x^2 - 2 = 0.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe solve function is wrapped and exported, as it and solveset are workhorses.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"solve(x^2 - x, x)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> solve(x**2 - 2, x)\n [-√2, √2]","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Solve the differential equation y - y = e^t.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nIn Julia, following the Symbolics.jl interface, We provide a the Differential function. It cleans up the calls to diff a bit, though using diff is an option.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"@syms t, y()\nD = Differential(t)\nD² = D∘D\ndsolve(D²(y(t)) - y(t) ~ exp(t), y(t))","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> y = Function('y')\n >>> dsolve(Eq(y(t).diff(t, t) - y(t), exp(t)), y(t))\n            -t   ⎛     t⎞  t\n y(t) = C₂⋅ℯ   + ⎜C₁ + ─⎟⋅ℯ\n                 ⎝     2⎠","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Find the eigenvalues of leftbeginsmallmatrix1  22 2endsmallmatrixright.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe package extends some generic function from the LinearAlgebra package","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"using LinearAlgebra\nM = Sym[1 2; 2 2]\neigvals(M)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":" >>> Matrix([[1, 2], [2, 2]]).eigenvals()\n ⎧3   √17     3   √17   ⎫\n ⎨─ - ───: 1, ─ + ───: 1⎬\n ⎩2    2      2    2    ⎭","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Rewrite the Bessel function J_nuleft(zright) in terms of the spherical Bessel function j_nu(z).","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe package extends some generic function from the SpecialFunctions package. Special functions defined in sympy but not SpecialFunctions, such as several orthogonal polynomial related function can be qualified using the sympy module.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"using SpecialFunctions\nbesselj(nu, z).rewrite(\"jn\")","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"  >>> besselj(nu, z).rewrite(jn)\n  √2⋅√z⋅jn(ν - 1/2, z)\n  ────────────────────\n           √π","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Print int_0^pi cos^2left (x right ) dx using mathrmLaTeX.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nThe Latexify package has a recipe for producing LaTeX output. The Integral function below constructs an integral, but does not evaluate it. Either use integrate or the method doit to evaluate the integral.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"using Latexify\nout = sympy.Integral(cos(x)^2, (x, 0, PI))\nlatexify(out)","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"<details><summary>Expand for Python example</summary>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"  >>> latex(Integral(cos(x)**2, (x, 0, pi)))\n  \\int\\limits_{0}^{\\pi} \\cos^{2}{\\left(x \\right)}\\, dx","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"Tutorial/intro/#Why-SymPy?","page":"Introduction","title":"Why SymPy?","text":"","category":"section"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"There are many computer algebra systems out there.  This Wikipedia article lists many of them.  What makes SymPy a better choice than the alternatives?","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"First off, SymPy is completely free. It is open source, and licensed under the liberal BSD license, so you can modify the source code and even sell it if you want to.  This contrasts with popular commercial systems like Maple or Mathematica that cost hundreds of dollars in licenses.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Second, SymPy uses Python.  Most computer algebra systems invent their own language. Not SymPy. SymPy is written entirely in Python, and is executed entirely in Python. This means that if you already know Python, it is much easier to get started with SymPy, because you already know the syntax (and if you don't know Python, it is really easy to learn).  We already know that Python is a well-designed, battle-tested language.  The SymPy developers are confident in their abilities in writing mathematical software, but programming language design is a completely different thing.  By reusing an existing language, we are able to focus on those things that matter: the mathematics.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"Another computer algebra system, Sage also uses Python as its language.  But Sage is large, with a download of over a gigabyte.  An advantage of SymPy is that it is lightweight.  In addition to being relatively small, it has no dependencies other than Python, so it can be used almost anywhere easily. Furthermore, the goals of Sage and the goals of SymPy are different.  Sage aims to be a full featured system for mathematics, and aims to do so by compiling all the major open source mathematical systems together into one. When you call some function in Sage, such as integrate, it calls out to one of the open source packages that it includes.  In fact, SymPy is included in Sage.  SymPy on the other hand aims to be an independent system, with all the features implemented in SymPy itself.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"A final important feature of SymPy is that it can be used as a library. Many computer algebra systems focus on being usable in interactive environments, but if you wish to automate or extend them, it is difficult to do.  With SymPy, you can just as easily use it in an interactive Python environment or import it in your own Python application.  SymPy also provides APIs to make it easy to extend it with your own custom functions.","category":"page"},{"location":"Tutorial/intro/","page":"Introduction","title":"Introduction","text":"tip: Julia differences\nIn Juila there are a few other choices for symbolic math, primarily Symbolics.jl, SymEngine.jl. Symbolics.jl is a Julia only solution. It is performant and widely used within the suite of SciML packages. The SymEngine package is much more limited in features, but extremely fast. Using SymPy may be slower, but the library has many more features available.","category":"page"},{"location":"#SymPyCore.jl","page":"Home","title":"SymPyCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SymPyCore.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymPy is Python library for symbolic mathematics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As there are two means to call Python code from Julia, two packages have been developed to call into SymPy:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymPy.jl is a Julia package using PyCall.jl to provide a \"Julian\" interface to SymPy.\nSymPyPythonCall.jl is a Julia package using PythonCall.jl to provide a \"Julian\" interface to SymPy providing a nearly identical experience as SymPy.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SymPyCore package aims to unify the underlying code, leaving only a small amount of glue code in the primary packages. Currently these are called SymPyPyCall and SymPyPythonCall to avoid the name collision, but it is expected that the next breaking versions of SymPy  will use SymPyCore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"While both glue packages provide a means to interact directly with the sympy library in Python, SymPyCore adds some conveniences, including many Julian idioms for easier use within Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Example usage page shows basic usages. The translation of the SymPy Tutorial is extensive.","category":"page"}]
}
